<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>www.blogways.net</title>
 <link href="http://www.blogways.net/atom.xml" rel="self"/>
 <link href="http://www.blogways.net/"/>
 <updated>2015-05-07T11:44:37+08:00</updated>
 <id>http://www.blogways.net/</id>
 <author>
   <name>www.blogways.net</name>
   <email>tangzhi@asiainfo-linkage</email>
 </author>

 
 <entry>
   <title>Solr 应用（六）－API 操作</title>
   <link href="http://www.blogways.net/blog/2015/05/07/solr-usage-6.html"/>
   <updated>2015-05-07T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/05/07/solr-usage-6</id>
   <content type="html">&lt;h3&gt;创建 Java 项目&lt;/h3&gt;

&lt;p&gt;使用 eclipse 新建一个 Java 项目，导入 apache-tomcat-7.0.42\webapps\solr\WEB-INF\lib 下面所有的 jar 包，再添加一个 junit4.8.1 的 jar 包&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/solr-6-1.png&quot; alt=&quot;Solr 工程导入的 jar 包&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;新建一个测试类&lt;/h3&gt;

&lt;p&gt;废话不多说，直接上代码，API 操作还是比较简单的，就不分开说了。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SolrTest.java&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import org.apache.solr.client.solrj.SolrClient;
import org.apache.solr.client.solrj.SolrQuery;
import org.apache.solr.client.solrj.SolrQuery.ORDER;
import org.apache.solr.client.solrj.SolrServerException;
import org.apache.solr.client.solrj.impl.HttpSolrClient;
import org.apache.solr.client.solrj.response.FacetField;
import org.apache.solr.client.solrj.response.FacetField.Count;
import org.apache.solr.client.solrj.response.QueryResponse;
import org.apache.solr.common.SolrDocument;
import org.apache.solr.common.SolrDocumentList;
import org.apache.solr.common.SolrInputDocument;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class SolrTest {

    private static String url = &quot;http://localhost:8080/solr/test&quot;;
    private SolrClient client;

    @Before
    public void init() {
        client = new HttpSolrClient(url);
    }

    @After
    public void destroy() {
        client = null;
    }

    // 单文档插入
    public void addDoc() throws Exception {
        SolrInputDocument doc = new SolrInputDocument();
        doc.addField(&quot;id&quot;, 10000001);
        doc.addField(&quot;name&quot;, &quot;Solr Input Document&quot;);
        doc.addField(&quot;manu&quot;, &quot;this is SolrInputDocument content&quot;);

        client.add(doc);
        client.commit();
    }

    // 批量文档插入
    public void addDocList() throws Exception {
        Collection&amp;lt;SolrInputDocument&amp;gt; docs = new ArrayList&amp;lt;SolrInputDocument&amp;gt;();
        for (int i = 1; i &amp;lt; 11; i++) {
            SolrInputDocument doc = new SolrInputDocument();
            doc.addField(&quot;id&quot;, 1000000 + i);
            doc.addField(&quot;name&quot;, &quot;batch solr document insert &quot; + i);
            doc.addField(&quot;manu&quot;, &quot;batch solr document content insert &quot; + i);
            docs.add(doc);
        }

        client.add(docs);
        client.commit();
    }

    @Test
    // 单个文档对应的 Java Bean 插入
    public void addDocBean() throws Exception {
        Index doc = new Index();
        doc.setId(&quot;100000000&quot;);
        doc.setName(&quot;add bean document&quot;);
        doc.setManu(&quot;index bean manu 中文测试&quot;);
        doc.setCat(new String[] { &quot;a1&quot;, &quot;b2&quot; });

        client.addBean(doc);
        client.commit();
    }

    // 批量文档 Bean 插入
    public void addDocBeanList() throws Exception {
        Collection&amp;lt;Index&amp;gt; docs = new ArrayList&amp;lt;Index&amp;gt;();
        for (int i = 1; i &amp;lt; 11; i++) {
            Index doc = new Index();
            doc.setId(&quot;10000000&quot; + i);
            doc.setName(&quot;add bean document &quot; + i);
            doc.setManu(&quot;bean document manu &quot; + i);
            docs.add(doc);
        }

        client.addBeans(docs);
        client.commit();
    }

    // 根据 id 删除单个文档
    public void remove() throws Exception {
        client.deleteById(&quot;100000000&quot;);
        client.commit();
    }

    // 根据批量 id 删除文档
    public void removeList() throws Exception {
        List&amp;lt;String&amp;gt; ids = new ArrayList&amp;lt;String&amp;gt;();
        for (int i = 1; i &amp;lt; 6; i++) {
            ids.add(&quot;10000000&quot; + i);
        }

        client.deleteById(ids);
        client.commit();
    }

    // 根据查询条件删除文档
    public void removeByQuery() throws Exception {
        client.deleteByQuery(&quot;id:100000007&quot;);
        client.commit();
    }

    // 查询操作
    public void queryAll() throws Exception {
        SolrQuery query = new SolrQuery();
        query.set(&quot;q&quot;, &quot;*:*&quot;);
        query.setStart(0);
        query.setRows(Integer.MAX_VALUE);
        // query.set(&quot;start&quot;, 0);
        // query.set(&quot;row&quot;, Integer.MAX_VALUE);
        query.set(&quot;id&quot;, &quot;id desc&quot;);
        query.set(&quot;fl&quot;, &quot;*, score&quot;);

        QueryResponse response = client.query(query);

        SolrDocumentList docs = response.getResults();

        for (SolrDocument doc : docs) {
            log(doc);
        }
    }

    // 一些附属操作
    public void otherMethod() throws Exception {
        client.getBinder();
        client.optimize(); // 合并索引文件，可以优化索引、提供性能，但需要一定的时间
        client.ping(); // ping服务器是否连接成功
        client.rollback();
        client.commit();
    }

    // query 基本用法测试
    public void queryCase() {
        // AND 并且
        SolrQuery params = new SolrQuery(&quot;name:apple AND manu:inc&quot;);

        // OR 或者
        params.setQuery(&quot;name:apple OR manu:apache&quot;);
        // 空格 等同于 OR
        params.setQuery(&quot;name:server manu:dell&quot;);

        // params.setQuery(&quot;name:solr - manu:inc&quot;);
        // params.setQuery(&quot;name:server + manu:dell&quot;);

        // 查询name包含solr apple
        params.setQuery(&quot;name:solr,apple&quot;);
        // manu不包含inc
        params.setQuery(&quot;name:solr,apple NOT manu:inc&quot;);

        // 50 &amp;lt;= price &amp;lt;= 200
        params.setQuery(&quot;price:[50 TO 200]&quot;);
        params.setQuery(&quot;popularity:[5 TO 6]&quot;);

        // 50 &amp;lt;= price &amp;lt;= 200 AND 5 &amp;lt;= popularity &amp;lt;= 6
        params.setQuery(&quot;price:[50 TO 200] AND popularity:[5 TO 6]&quot;);
        params.setQuery(&quot;price:[50 TO 200] OR popularity:[5 TO 6]&quot;);

        // 过滤器查询，可以提高性能 filter 类似多个条件组合，如and
        // params.addFilterQuery(&quot;id:VA902B&quot;);
        // params.addFilterQuery(&quot;price:[50 TO 200]&quot;);
        // params.addFilterQuery(&quot;popularity:[* TO 5]&quot;);
        // params.addFilterQuery(&quot;weight:*&quot;);
        // 0 &amp;lt; popularity &amp;lt; 6 没有等于
        // params.addFilterQuery(&quot;popularity:{0 TO 6}&quot;);

        // 排序
        params.addSort(&quot;id&quot;, ORDER.asc);

        // 分页：start开始页，rows每页显示记录条数
        // params.add(&quot;start&quot;, &quot;0&quot;);
        // params.add(&quot;rows&quot;, &quot;200&quot;);
        // params.setStart(0);
        // params.setRows(200);

        // 设置高亮
        params.setHighlight(true); // 开启高亮组件
        params.addHighlightField(&quot;name&quot;);// 高亮字段
        params.setHighlightSimplePre(&quot;&amp;lt;font color='red'&amp;gt;&quot;);// 标记，高亮关键字前缀
        params.setHighlightSimplePost(&quot;&amp;lt;/font&amp;gt;&quot;);// 后缀
        params.setHighlightSnippets(1);// 结果分片数，默认为1
        params.setHighlightFragsize(1000);// 每个分片的最大长度，默认为100

        // 分片信息
        params.setFacet(true).setFacetMinCount(1).setFacetLimit(5)// 段
                .addFacetField(&quot;name&quot;)// 分片字段
                .addFacetField(&quot;inStock&quot;);

        // params.setQueryType(&quot;&quot;);

        try {
            QueryResponse response = client.query(params);

            /*
             * List&amp;lt;Index&amp;gt; indexs = response.getBeans(Index.class); for (int i =
             * 0; i &amp;lt; indexs.size(); i++) { fail(indexs.get(i)); }
             */

            // 输出查询结果集
            SolrDocumentList list = response.getResults();
            log(&quot;query result nums: &quot; + list.getNumFound());
            for (int i = 0; i &amp;lt; list.size(); i++) {
                log(list.get(i));
            }

            // 输出分片信息
            List&amp;lt;FacetField&amp;gt; facets = response.getFacetFields();
            for (FacetField facet : facets) {
                log(facet);
                List&amp;lt;Count&amp;gt; facetCounts = facet.getValues();
                for (FacetField.Count count : facetCounts) {
                    System.out.println(count.getName() + &quot;: &quot;
                            + count.getCount());
                }
            }
        } catch (SolrServerException e) {
            e.printStackTrace();
        }
    }

    // 分片查询， 可以统计关键字及出现的次数、或是做自动补全提示
    public void facetQueryCase() {
        SolrQuery params = new SolrQuery(&quot;*:*&quot;);

        // 排序
        params.addSort(&quot;id&quot;, ORDER.asc);

        params.setStart(0);
        params.setRows(200);

        // Facet为solr中的层次分类查询
        // 分片信息
        params.setFacet(true).setQuery(&quot;*:*&quot;).setFacetMinCount(1)
                .setFacetLimit(5)   // 段
                // .setFacetPrefix(&quot;electronics&quot;, &quot;cat&quot;)
                .setFacetPrefix(&quot;cor&quot;)  // 查询manu、name中关键字前缀是cor的
                .addFacetField(&quot;manu&quot;).addFacetField(&quot;name&quot;);   // 分片字段

        try {
            QueryResponse response = client.query(params);

            // 输出查询结果集
            SolrDocumentList list = response.getResults();
            log(&quot;Query result nums: &quot; + list.getNumFound());

            for (int i = 0; i &amp;lt; list.size(); i++) {
                log(list.get(i));
            }

            log(&quot;All facet filed result: &quot;);
            // 输出分片信息
            List&amp;lt;FacetField&amp;gt; facets = response.getFacetFields();
            for (FacetField facet : facets) {
                log(facet);
                List&amp;lt;Count&amp;gt; facetCounts = facet.getValues();
                for (FacetField.Count count : facetCounts) {
                    // 关键字 - 出现次数
                    log(count.getName() + &quot;: &quot; + count.getCount());
                }
            }

            log(&quot;Search facet [name] filed result: &quot;);
            // 输出分片信息
            FacetField facetField = response.getFacetField(&quot;name&quot;);
            List&amp;lt;Count&amp;gt; facetFields = facetField.getValues();
            for (Count count : facetFields) {
                // 关键字 - 出现次数
                log(count.getName() + &quot;: &quot; + count.getCount());
            }
        } catch (SolrServerException e) {
            e.printStackTrace();
        }
    }

    private void log(Object obj) {
        System.out.println(obj);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;里面用到一个 java bean &lt;code&gt;Index.java&lt;/code&gt;，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import org.apache.solr.client.solrj.beans.Field;

public class Index {  
    @Field  
    private String id;  
    @Field
    private String name;  
    @Field  
    private String manu;  
    @Field  
    private String[] cat;  
    @Field  
    private String[] features;  
    @Field  
    private float price;  
    @Field  
    private int popularity;  
    @Field  
    private boolean inStock;  

    public String getId() {  
        return id;  
    }  

    @Field  
    public void setId(String id) {  
        this.id = id;  
    }  

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getManu() {
        return manu;
    }

    public void setManu(String manu) {
        this.manu = manu;
    }

    public String[] getCat() {
        return cat;
    }

    public void setCat(String[] cat) {
        this.cat = cat;
    }

    public String[] getFeatures() {
        return features;
    }

    public void setFeatures(String[] features) {
        this.features = features;
    }

    public float getPrice() {
        return price;
    }

    public void setPrice(float price) {
        this.price = price;
    }

    public int getPopularity() {
        return popularity;
    }

    public void setPopularity(int popularity) {
        this.popularity = popularity;
    }

    public boolean isInStock() {
        return inStock;
    }

    public void setInStock(boolean inStock) {
        this.inStock = inStock;
    }

    public String toString() {  
        return this.id + &quot;#&quot; + this.name + &quot;#&quot; + this.manu + &quot;#&quot; + this.cat;  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>Solr 应用（五）－中文分词</title>
   <link href="http://www.blogways.net/blog/2015/05/06/solr-usage-5.html"/>
   <updated>2015-05-06T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/05/06/solr-usage-5</id>
   <content type="html">&lt;h3&gt;简介&lt;/h3&gt;

&lt;p&gt;solr5.0 默认的分词器是一元分词器，这个本来就是对英文进行分词的，英文大部分就是典型的根据空格进行分词，而中文如果按照这个规则，那么显然是要有很多的冗余词被分出来，一些没有用的虚词，数词，都会被分出来，影响效率不说，关键是分词效果不好，所以可以利用 solr 的同步发行包 smartcn 进行中文切词，smartcn 的分词准确率不错，但就是不能自己定义新的词库，不过 smartcn 是跟 solr 同步的，所以不需要额外的下载，只需在 solr 的例子中拷贝进去即可，下面给出路径图和安装 solr5.0 的 smartcn 分词过程&lt;/p&gt;

&lt;p&gt;无论安装那种分词器，大部分都有2个步骤&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;拷贝jar包到solr的lib中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 将 `solr-5.0.0\server\solr\test\contrib\analysis-extras\lucene-libs\lucene-analyzers-smartcn-5.0.0.jar` 拷贝到 `solr-5.0.0\server\solr\test\contrib\analysis-extras\lib` 目录下
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改相关配置&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;&lt;code&gt;solr-5.0.0\server\solr\test\conf\solrconfig.xml&lt;/code&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- annotating for smartcn, replaced by the blow config
  &amp;lt;lib dir=&quot;${solr.install.dir:../../../..}/contrib/extraction/lib&quot; regex=&quot;.*\.jar&quot; /&amp;gt;
  &amp;lt;lib dir=&quot;${solr.install.dir:../../../..}/dist/&quot; regex=&quot;solr-cell-\d.*\.jar&quot; /&amp;gt;

  &amp;lt;lib dir=&quot;${solr.install.dir:../../../..}/contrib/clustering/lib/&quot; regex=&quot;.*\.jar&quot; /&amp;gt;
  &amp;lt;lib dir=&quot;${solr.install.dir:../../../..}/dist/&quot; regex=&quot;solr-clustering-\d.*\.jar&quot; /&amp;gt;

  &amp;lt;lib dir=&quot;${solr.install.dir:../../../..}/contrib/langid/lib/&quot; regex=&quot;.*\.jar&quot; /&amp;gt;
  &amp;lt;lib dir=&quot;${solr.install.dir:../../../..}/dist/&quot; regex=&quot;solr-langid-\d.*\.jar&quot; /&amp;gt;

  &amp;lt;lib dir=&quot;${solr.install.dir:../../../..}/contrib/velocity/lib&quot; regex=&quot;.*\.jar&quot; /&amp;gt;
  &amp;lt;lib dir=&quot;${solr.install.dir:../../../..}/dist/&quot; regex=&quot;solr-velocity-\d.*\.jar&quot; /&amp;gt;
  --&amp;gt;

&amp;lt;!-- smartcn config, instead of the previous code --&amp;gt;
&amp;lt;lib dir=&quot;E:\tools\solr-5.0.0\server\solr\test\contrib\analysis-extras\lib&quot; regex=&quot;.*\.jar&quot; /&amp;gt;  

&amp;lt;lib dir=&quot;E:\tools\solr-5.0.0\server\solr\test\contrib\extraction\lib&quot; regex=&quot;.*\.jar&quot; /&amp;gt;  
&amp;lt;lib dir=&quot;E:\tools\solr-5.0.0\server\solr\test\dist\&quot; regex=&quot;solr-cell-\d.*\.jar&quot; /&amp;gt;  

&amp;lt;lib dir=&quot;E:\tools\solr-5.0.0\server\solr\test\contrib\clustering\lib\&quot; regex=&quot;.*\.jar&quot; /&amp;gt;  
&amp;lt;lib dir=&quot;E:\tools\solr-5.0.0\server\solr\test\dist\&quot; regex=&quot;solr-clustering-\d.*\.jar&quot; /&amp;gt;  

&amp;lt;lib dir=&quot;E:\tools\solr-5.0.0\server\solr\test\contrib\langid\lib\&quot; regex=&quot;.*\.jar&quot; /&amp;gt;  
&amp;lt;lib dir=&quot;E:\tools\solr-5.0.0\server\solr\test\dist\&quot; regex=&quot;solr-langid-\d.*\.jar&quot; /&amp;gt;  

&amp;lt;lib dir=&quot;E:\tools\solr-5.0.0\server\solr\test\contrib\velocity\lib&quot; regex=&quot;.*\.jar&quot; /&amp;gt;  
&amp;lt;lib dir=&quot;E:\tools\solr-5.0.0\server\solr\test\dist\&quot; regex=&quot;solr-velocity-\d.*\.jar&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;code&gt;solr-5.0.0\server\solr\test\conf\schema.xml&lt;/code&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- Smartcn --&amp;gt;
&amp;lt;fieldType name=&quot;text_smartcn&quot; class=&quot;solr.TextField&quot; positionIncrementGap=&quot;0&quot;&amp;gt;  
  &amp;lt;analyzer type=&quot;index&quot;&amp;gt;  
    &amp;lt;tokenizer class=&quot;org.apache.lucene.analysis.cn.smart.SmartChineseSentenceTokenizerFactory&quot;/&amp;gt;  
    &amp;lt;filter class=&quot;org.apache.lucene.analysis.cn.smart.SmartChineseWordTokenFilterFactory&quot;/&amp;gt;  
        &amp;lt;/analyzer&amp;gt;  
  &amp;lt;analyzer type=&quot;query&quot;&amp;gt;  
     &amp;lt;tokenizer class=&quot;org.apache.lucene.analysis.cn.smart.SmartChineseSentenceTokenizerFactory&quot;/&amp;gt;  
    &amp;lt;filter class=&quot;org.apache.lucene.analysis.cn.smart.SmartChineseWordTokenFilterFactory&quot;/&amp;gt;  
  &amp;lt;/analyzer&amp;gt;  
&amp;lt;/fieldType&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将需要使用中文分词的字段类型改成 &lt;code&gt;text_smartcn&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;field name=&quot;goods_name&quot; type=&quot;text_smartcn&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后来验证下中文分词安装是否成功&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/solr-5-1.png&quot; alt=&quot;Web 控制台 中文分词测试&quot; /&gt;&lt;/p&gt;

&lt;p&gt;除了中文分词，另外还有一个拼音分词，这个网上可以搜到，需要下载一个 jar 包，其他配置、使用都跟上面类似，有兴趣的可以自己去试下。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Solr 应用（四）－企业应用</title>
   <link href="http://www.blogways.net/blog/2015/05/05/solr-usage-4.html"/>
   <updated>2015-05-05T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/05/05/solr-usage-4</id>
   <content type="html">&lt;h3&gt;需求分析&lt;/h3&gt;

&lt;p&gt;相信很多人都用过类似淘宝或者京东的产品搜索功能，输入想要查找的商品，点搜索很快列出一堆你想要的东东，我们的产品也想实现这个功能。&lt;/p&gt;

&lt;p&gt;我们都知道数据库的瓶颈主要在 IO 这块，虽然通过分库分表能分担一部分负载，但当网站访问量比较大的时候，不应该也不可能搜索一次都去执行一次数据库 IO 操作，这个时候 Solr 也就派上用途了，我们可以通过将产品相关数据刷到 Solr 的搜索实例中，通过 Solr 应用服务器对外提供 Rest 查询接口，定时去更新数据，刷新搜索索引，这样就大大降低了查询数据库服务器的压力。&lt;/p&gt;

&lt;h3&gt;数据导入&lt;/h3&gt;

&lt;p&gt;那么问题来了，如果将数据库相关数据导入搜索实例中呢？前面我们使用了 &lt;code&gt;bin/post&lt;/code&gt; 将 json 文档直接导入搜索实例，接下来我们看下如何将 mysql 中表数据导入到搜索实例中。&lt;/p&gt;

&lt;h4&gt;&lt;em&gt;使用DIH(DataImportHandler)从数据库导入数据&lt;/em&gt;&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先数据库准备一张表&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; CREATE TABLE `comment` (
     `id` INT(11) NULL DEFAULT NULL,
     `writetime` VARCHAR(50) NULL DEFAULT NULL,
     `title` VARCHAR(500) NULL DEFAULT NULL
 )
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;往表里面插入几条测试数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; INSERT INTO `test`.`comment` (`id`, `writetime`, `title`) VALUES (10001, '2015-04-11', 'Step 1: Set up a personal account');
 INSERT INTO `test`.`comment` (`id`, `writetime`, `title`) VALUES (10002, '2015-04-12', 'Step 2: Choose your plan');
 INSERT INT3 `test`.`comment` (`id`, `writetime`, `title`) VALUES (10003, '2015-04-13', 'Step 3: Go to your dashboard');
 INSERT INTO `test`.`comment` (`id`, `writetime`, `title`) VALUES (10004, '2015-04-14', 'There were problems creating your account.');
 INSERT INTO `test`.`comment` (`id`, `writetime`, `title`) VALUES (10005, '2015-04-15', 'You will occasionally receive account related emails. We promise not to share your email with anyone.');
 INSERT INTO `test`.`comment` (`id`, `writetime`, `title`) VALUES (10006, '2015-04-16', 'Use at least one lowercase letter, one numeral, and seven characters.');
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;导入相关jar包
在 &lt;code&gt;solr-5.0.0/server/solr/test/conf/solrconfig.xml&lt;/code&gt; 加入如下代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   &amp;lt;lib dir=&quot;${solr.install.dir:../../../..}/dist/&quot; regex=&quot;solr-dataimporthandler-.*\.jar&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置handler
在 &lt;code&gt;solr-5.0.0/server/solr/test/conf/solrconfig.xml&lt;/code&gt; 加入如下代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   &amp;lt;requestHandler name=&quot;/dataimport&quot; class=&quot;solr.DataImportHandler&quot;&amp;gt;  
       &amp;lt;lst name=&quot;defaults&quot;&amp;gt;   
         &amp;lt;str name=&quot;config&quot;&amp;gt;db-data-config.xml&amp;lt;/str&amp;gt;   
       &amp;lt;/lst&amp;gt;  
   &amp;lt;/requestHandler&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置数据源,源数据与索引的隐射关系
在 &lt;code&gt;solr-5.0.0/server/solr/test/conf/下新建db-data-config.xml&lt;/code&gt; ,配置如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   &amp;lt;dataConfig&amp;gt;
      &amp;lt;dataSource type=&quot;JdbcDataSource&quot; 
                 driver=&quot;com.mysql.jdbc.Driver&quot;
                 url=&quot;jdbc:mysql://localhost/test&quot; 
                 user=&quot;root&quot; 
                 password=&quot;root&quot;/&amp;gt;
      &amp;lt;document&amp;gt;
       &amp;lt;entity name=&quot;comment&quot; 
       query=&quot;SELECT id, DATE_FORMAT(writetime, '%Y-%m-%dT%TZ') as 'writetime', title from comment&quot;
       deltaImportQuery=&quot;SELECT id, DATE_FORMAT(writetime, '%Y-%m-%dT%TZ') as 'writetime', title from comment where id='${dih.delta.id}'&quot;
       deltaQuery=&quot;SELECT id FROM comment WHERE DATE(updatetime) &amp;gt;= '${dih.last_index_time}' OR DATE(writetime) &amp;gt;= '${dih.last_index_time}'&quot;&amp;gt;       
          &amp;lt;field column=&quot;id&quot; name=&quot;id&quot;/&amp;gt;      
          &amp;lt;field column=&quot;writetime&quot; name=&quot;writetime&quot;/&amp;gt;
          &amp;lt;field column=&quot;title&quot; name=&quot;title&quot;/&amp;gt;           
       &amp;lt;/entity&amp;gt;      
     &amp;lt;/document&amp;gt;
   &amp;lt;/dataConfig&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;注：查询 sql 可以是多表关联查询，只要查询字段跟下面的 field 对应起来就可以。另外 field 对应的name值必须在 config 目录下的 schema.xml 文件中存在。如上述的 writetime 不存在，则在schema.xml中添加&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;field name=&quot;writetime&quot; type=&quot;tdate&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;indexed 表示需不需要建立索引，以便之后对这个 field 进行查询；&lt;/p&gt;

&lt;p&gt;stored 表示需不需要随索引同时存储这个 field 本身的内容，以便查询时直接从结果中获取该内容，一般大数据（比如文件内容本身）不会和索引一起保存，节省资源，防止索引过大。 索引本身和被索引的内容要分清，不理解的话，倒排索引：&lt;code&gt;http://zh.wikipedia.org/wiki/&lt;/code&gt;倒排索引&lt;/p&gt;

&lt;p&gt;6.Reload test 搜索实例，利用图形界面执行dataimport&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/solr-4-1.png&quot; alt=&quot;Web 控制台 dataimport&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因为这个文件我已经导过了，所以上面显示是 reload，第一次使用时有一点点差别。导完数据以后我们查询验证下 &lt;code&gt;http://localhost:8080/solr/test/select?q=title%3Astep&amp;amp;wt=json&amp;amp;indent=true&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;返回结果：&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &quot;responseHeader&quot;:{
    &quot;status&quot;:0,
    &quot;QTime&quot;:2,
    &quot;params&quot;:{
      &quot;indent&quot;:&quot;true&quot;,
      &quot;q&quot;:&quot;title:step&quot;,
      &quot;wt&quot;:&quot;json&quot;}},
  &quot;response&quot;:{&quot;numFound&quot;:3,&quot;start&quot;:0,&quot;docs&quot;:[
      {
        &quot;id&quot;:&quot;10002&quot;,
        &quot;title&quot;:[&quot;Step 2: Choose your plan&quot;],
        &quot;writetime&quot;:&quot;2015-04-10T00:00:00Z&quot;,
        &quot;_version_&quot;:1498574060831899648},
      {
        &quot;id&quot;:&quot;10001&quot;,
        &quot;title&quot;:[&quot;Step 1: Set up a personal account&quot;],
        &quot;writetime&quot;:&quot;2015-04-10T00:00:00Z&quot;,
        &quot;_version_&quot;:1498574060739624960},
      {
        &quot;id&quot;:&quot;10003&quot;,
        &quot;title&quot;:[&quot;Step 3: Go to your dashboard&quot;],
        &quot;writetime&quot;:&quot;2015-04-10T00:00:00Z&quot;,
        &quot;_version_&quot;:1498574060832948224}]
  }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里面我们使用的是 &lt;code&gt;title:step&lt;/code&gt; 将 title 包含 step 的三条记录都查了出来。&lt;/p&gt;

&lt;h4&gt;&lt;em&gt;编程的方式来自定义导入（这个编程部分再讲）&lt;/em&gt;&lt;/h4&gt;

&lt;p&gt;当然除了数据库数据，Solr 还能导入 csv,json,word,pdf，这部分有兴趣可以自己去试验下。&lt;/p&gt;

&lt;p&gt;至此，一个简单的 Solr 的应用演示算是完成了。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>MongoDB 入库速度和分片的关系</title>
   <link href="http://www.blogways.net/blog/2015/05/05/mongodb-sharding-io-rate.html"/>
   <updated>2015-05-05T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/05/05/mongodb-sharding-io-rate</id>
   <content type="html">&lt;h2&gt;一、背景&lt;/h2&gt;

&lt;p&gt;实时采集主机的日志文件，发送到 node.js 处理程序( 暂时叫做 &lt;strong&gt;load&lt;/strong&gt; )，经过一些数据处理后插入到 MongoDB 持久存储。由于采集的主机数量较多，导致了如下问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每秒需要入库的数据量很大，单个 MongoDB 无法满足这些数据的入库要求，导致插入的拥堵，导致 MongoDB 中的不是实时的数据；&lt;/li&gt;
&lt;li&gt;MongoDB 缓存到内存中的热数据量太多，单台主机无法满足如此大的内存需求；&lt;/li&gt;
&lt;li&gt;MongoDB 持久化存储到本地磁盘的数据非常大( 有些表一天的数据量有上千万条 )，需要的存储空间很大，单台无法满足要求。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;考虑到&lt;strong&gt;纵向扩展&lt;/strong&gt;的代价较高，决定采用 MongoDB 的分片机制来实现，需要探究的问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;单个 MongoDB 实例的入库速率极限是多少；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;load&lt;/strong&gt;( 处理接收到的日子文件，并入库到MongoDB )的数量与入库速率的关系；&lt;/li&gt;
&lt;li&gt;分片的片数与入库速率的关系；&lt;/li&gt;
&lt;li&gt;单台主机( 8核心，16G )启动&lt;strong&gt;load&lt;/strong&gt;和 MongoDB 实例的最合适个数；&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;二、测试单个MongoDB入库极限&lt;/h2&gt;

&lt;p&gt;启动一个 MongoDB 实例，分别测试启动多个&lt;strong&gt;load&lt;/strong&gt;时，MongoDB的入库速率( 10min中入库的记录条数 )，发往&lt;strong&gt;load&lt;/strong&gt;的日子数量充足；&lt;/p&gt;

&lt;p&gt;MongoDB 实例启动：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongod --dbpath /data/mongodb/db --logpath /data/mongodb/logs/mongod.log --nojournal --fork
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体命令吃处不在讲解，详见&lt;a href=&quot;http://www.blogways.net/blog/2015/05/04/mongodb-install-and-distribution-deploy.html&quot;&gt;MongoDB 安装与分布式部署&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;测试结果&lt;/h3&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th&gt;load 个数&lt;/th&gt;&lt;th&gt;十分钟入库数&lt;/th&gt;&lt;th&gt;入库速率( 条/sec )&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;222902&lt;/td&gt;&lt;td&gt;372&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;260933&lt;/td&gt;&lt;td&gt;435&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;259581&lt;/td&gt;&lt;td&gt;433&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;260966&lt;/td&gt;&lt;td&gt;435&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


&lt;h3&gt;结论&lt;/h3&gt;

&lt;p&gt;针对当前&lt;strong&gt;load&lt;/strong&gt; 应用处理程序，单个 MongoDB 实例的入库极限速度为：&lt;code&gt;435 条/sec&lt;/code&gt;。&lt;/p&gt;

&lt;h3&gt;注意&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;测试中还记录并且计算了其它时间长度的入库速度，有一些差异，但都在误差的范围内；&lt;/li&gt;
&lt;li&gt;针对不同的处理入库逻辑，测出的入库极限速度都不同，本内容的所有数据都是基于自己的&lt;strong&gt;load&lt;/strong&gt;，仅供参考。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;三、分片数与入库速率的关系( python )&lt;/h2&gt;

&lt;p&gt;考虑到日志的抓去、&lt;strong&gt;load&lt;/strong&gt;的处理和数据入库中间存在很多的不确定性，因而首先只选择测试每秒钟插入记录数来表面存在的关系。&lt;/p&gt;

&lt;h3&gt;测试方案&lt;/h3&gt;

&lt;p&gt;分别在 3 台不同的主机上部署3个配置服务器(Config Server)，在其中的一台上面部署 3 个查询路由(Query Router)，最后在另一台主机上( 不包含在部署Config Server 和 Query Router主机内 )，分别启动1、2、3、4个分片(按照 &lt;code&gt;host&lt;/code&gt;字段，&lt;strong&gt;&lt;em&gt;Hash 分片&lt;/em&gt;&lt;/strong&gt;)；&lt;/p&gt;

&lt;p&gt;通过&lt;code&gt;ruby&lt;/code&gt;语言编写插入记录程序( 需要pymongo插件 )，部分代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/env python

from pymongo import MongoClient
import time,datetime,random
# 启动的3个查询路由
db1 = MongoClient('10.20.16.78:27017').test
db2 = MongoClient('10.20.16.78:27018').test
db3 = MongoClient('10.20.16.78:27019').test

def insert(num):
    for i in range(num):
        rand = random.randint(1,3)
        host = random.randint(1,3)
        if rand == 1:
            db = db1
        elif rand == 2:
            db = db2
        else:
            db = db3
        obj = {
            &quot;host&quot;: host,
            # 生成插入的对象
        }
        db.objInsert.insert_one(obj)

insert(300000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的每个脚本表示插入 300000 条记录到分片表中，此处为测试分三片时候的入库速率；&lt;/p&gt;

&lt;h3&gt;配置&lt;/h3&gt;

&lt;p&gt;将&lt;code&gt;test.objInsert&lt;/code&gt;表按照&lt;code&gt;host&lt;/code&gt;字段哈希分片：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sh.shardCollection('test.objInsert', {'host': 'hashed'})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动&lt;code&gt;python&lt;/code&gt;脚本向数据库插入数据，记录10s、1min的插入速率。&lt;/p&gt;

&lt;h3&gt;测试数据&lt;/h3&gt;

&lt;p&gt;应该很多次测试，此处只贴出一次结果：&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th&gt;分片 片数&lt;/th&gt;&lt;th&gt;10s入库数&lt;/th&gt;&lt;th&gt;入库速率( 条/sec )&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;1 (不分片)&lt;/td&gt;&lt;td&gt;120263&lt;/td&gt;&lt;td&gt;12026&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;148543&lt;/td&gt;&lt;td&gt;14854&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;185022&lt;/td&gt;&lt;td&gt;18502&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;绘制的平滑标记散点连线图，如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/sharding-rate-result.png&quot; alt=&quot;sharding-rate-result&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;结论&lt;/h3&gt;

&lt;p&gt;由上图可得到一个大概的猜想：&lt;strong&gt;&lt;em&gt;入库速率与分片片数呈线性关系！&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;注意&lt;/h3&gt;

&lt;p&gt;由于主机数、主机内存等愿意的限制，没法启动太多的&lt;code&gt;python&lt;/code&gt;脚本用于数据插入，实际测试用用的两台机器来插入测试；&lt;/p&gt;

&lt;p&gt;测试主机还有其它程序占用CPU等，没法长时间处于&lt;code&gt;python&lt;/code&gt;脚步执行状态，测试只记录 10s 中的数据；还有可能涉及到其它原因，长时间插入会出现速率波动；&lt;/p&gt;

&lt;h2&gt;四、入库速度与load数量的关系&lt;/h2&gt;

&lt;p&gt;由于 node.js 连接 MongoDB 的所有数据库操作都是异步调用的，所以很多操作只能在回调函数中进行，或通过其它方式将其转换为同步操作( 如：&lt;code&gt;async&lt;/code&gt;、&lt;code&gt;EventProxy&lt;/code&gt; )。&lt;/p&gt;

&lt;p&gt;在测试的初期，发现有时候&lt;strong&gt;load&lt;/strong&gt;占用的内存会不断的升高，有时候甚至会导致&lt;strong&gt;load&lt;/strong&gt;程序崩溃，后来实验发现，是因为MongoDB 的入库速率达到了瓶颈，而又有不断的数据插入，导致回掉函数无法立即执行并积压在内存中，是的占用内存越来越高，最后程序崩溃。&lt;/p&gt;

&lt;p&gt;根据上述原因，可以通过load的内存占用来侧面反应&lt;strong&gt;load&lt;/strong&gt;和MongoDB的工作状态：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;内存占用过高，&lt;strong&gt;load&lt;/strong&gt;对接收到的日志处理不过来，或MongoDB的入库速率到达极限；&lt;/li&gt;
&lt;li&gt;内存占用正常或稍微偏高( 10 ~ 100M之内 )，&lt;strong&gt;load&lt;/strong&gt;和 MongoDB都处在比较理想的工作状态；&lt;/li&gt;
&lt;li&gt;内存占用偏低，&lt;strong&gt;load&lt;/strong&gt;或 MongoDB的性能部分处于闲置状态。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;在做本项测试的时候，需要保证 MongoDB的出来能力能满足所有&lt;strong&gt;load&lt;/strong&gt;个数的限制，观察不同个数时的入库记录条数；因而在必要的时候需要启动多个分片；&lt;/p&gt;

&lt;h3&gt;测试方案&lt;/h3&gt;

&lt;p&gt;分别启动1、2、3、4个&lt;strong&gt;load&lt;/strong&gt;，并启动相应的分片数( 使得每个&lt;strong&gt;load&lt;/strong&gt;的内存占用正常 )，启动3个配置服务器；考虑到多个&lt;strong&gt;load&lt;/strong&gt;的情况，传递过来的日子数据通过&lt;code&gt;nginx&lt;/code&gt;按 &lt;strong&gt;响应时间&lt;/strong&gt; 做负载均衡处理。&lt;/p&gt;

&lt;h3&gt;测试数据&lt;/h3&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th&gt;load 个数&lt;/th&gt;&lt;th&gt;10min入库数&lt;/th&gt;&lt;th&gt;入库速率( 条/sec )&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;227079&lt;/td&gt;&lt;td&gt;379&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;447980&lt;/td&gt;&lt;td&gt;747&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;614332&lt;/td&gt;&lt;td&gt;1024&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;782492&lt;/td&gt;&lt;td&gt;1304&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;绘制的平滑标记散点连线图，如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/sharding-rate-load-num.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;多次测量的过程中，&lt;strong&gt;load&lt;/strong&gt;的内存占用都在100 ~ 250 M之间，CPU 占用率100%左右( 完全占用一个物理CPU核心 )。&lt;/p&gt;

&lt;h3&gt;结论&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;由上图可发现，&lt;strong&gt;load&lt;/strong&gt;个数和入库速率所呈现的基本是一条直线，因而得到结论&lt;strong&gt;load&lt;/strong&gt;的个数与入库速率成线性关系；&lt;/li&gt;
&lt;li&gt;由于&lt;strong&gt;load&lt;/strong&gt;在正常工作情况下内存占用补不超过300M，这相对于一台主机的16G的内存来说很小，因而一台机器能启动的&lt;strong&gt;load&lt;/strong&gt;的个数取决于其核心数，还要留一些用作它用，因而8核心CPU主机，启动 &lt;strong&gt;4 ~ 7&lt;/strong&gt;个&lt;strong&gt;load&lt;/strong&gt;是比较合适的。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;注意&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;在测试4个&lt;strong&gt;load&lt;/strong&gt;的时候，开始使用了3个配置服务器，4个分片，结果每个&lt;strong&gt;load&lt;/strong&gt;的内存占用都高达600M以上，说明分4片没法满足4个&lt;strong&gt;load&lt;/strong&gt;的入库请求；&lt;/li&gt;
&lt;li&gt;然后使用3个配置服务器，6个分片，&lt;strong&gt;load&lt;/strong&gt;的内存占用在400M以上，同样6个分片也无法满足要求；&lt;/li&gt;
&lt;li&gt;最后在启用8个分片后，内存占用降到了100M多一点，说明此时的MongoDB的处理入库速度完全够4个&lt;strong&gt;load&lt;/strong&gt;使用。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;五、分片数与入库速率的关系( load )&lt;/h2&gt;

&lt;p&gt;有测试四的注意可知，4个&lt;strong&gt;load&lt;/strong&gt;，3个配置服务器即可完成测试不分片、分2、3、4片时的入库速率。&lt;/p&gt;

&lt;h3&gt;测试数据&lt;/h3&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th&gt;分片 片数&lt;/th&gt;&lt;th&gt;20min入库数&lt;/th&gt;&lt;th&gt;入库速率( 条/sec )&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;不分片&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;435&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;854605&lt;/td&gt;&lt;td&gt;712&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;1127365&lt;/td&gt;&lt;td&gt;940&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;14220( 2min )&lt;/td&gt;&lt;td&gt;1185&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;绘制的平滑标记散点连线图，如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/sharding-rate-result-load.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每个&lt;code&gt;mongod&lt;/code&gt;进程( 分片实例 )的CPU占用在繁忙的时候会接近100%，有时候甚至超过100%；&lt;/p&gt;

&lt;h3&gt;结论&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;由上图可知，分片的片数与入库速率亦是成线性关系；&lt;/li&gt;
&lt;li&gt;由于CPU会超过100%的考虑，单台8核心的服务器，最多启动6个分片；&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;注意&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;单台主机的MongoDB 分片的片数选择主要考虑 CPU 的核心数；&lt;/li&gt;
&lt;li&gt;MongoDB 分片进程会讲插入的数据都保存到内存中，直到内存完全被耗光，后续的数据会持久化到磁盘空间，内存中只会保存热数据和索引。&lt;/li&gt;
&lt;li&gt;如果主机内存吃紧的话，启动分片实例的时候最好带&lt;code&gt;--nojurounal&lt;/code&gt;启动。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;六、总结&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;load&lt;/strong&gt; 的个数和入库速率成线性关系；&lt;/li&gt;
&lt;li&gt;MongoDB 分片的片数和入库速率成线性关系；&lt;/li&gt;
&lt;li&gt;单台主机启动&lt;strong&gt;load&lt;/strong&gt;的个数主要考虑因素是 CPU 核心数，最多启动 &lt;code&gt;n - 2 (n 为 cpu 核心数)&lt;/code&gt;个；&lt;/li&gt;
&lt;li&gt;单台主机启动MongoDB 分片实例的个数，参考因素为 CPU 核心数，最多启动 &lt;code&gt;n - 2 (n 为 cpu 核心数)&lt;/code&gt;个；&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;/br&gt;
&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;后续修改中。。。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>MongoDB 分片介绍</title>
   <link href="http://www.blogways.net/blog/2015/05/05/mongodb-sharding-introduction-by-docs.html"/>
   <updated>2015-05-05T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/05/05/mongodb-sharding-introduction-by-docs</id>
   <content type="html">&lt;h2&gt;一、分片介绍&lt;/h2&gt;

&lt;p&gt;分片是一个遍及多台机器存储数据的方法，MongoDB 使用分片来实现对大数据集合部署与高吞吐量操纵的支持。&lt;/p&gt;

&lt;h3&gt;分片的目的&lt;/h3&gt;

&lt;p&gt;对一个单一数据库系统服务来说，大数据集合和高吞吐量的应用程序将会是一个非常严峻的考验。高的查询速率会“吃光”服务器的所有CPU，更大的数据集合超出一个单一机器的存储空间。最后，工作集合的大小比系统内存容量( 磁盘驱动的I/O性能 )大。&lt;/p&gt;

&lt;p&gt;解决上诉问题的方式有两个：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;纵向扩展 ( vertical scaling )&lt;/li&gt;
&lt;li&gt;分片 ( sharding )&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;Vertical scaling&lt;/strong&gt;，增加更多的CPU数和存储资源来增加容纳量，但是扩展存在限制：更多核心数的CPU和更多RAM的高性能系统比更小的系统昂贵，而且其 CPU 和 RAM 的增加与得到的性能不是曾比例的。另外，云服务提供商可能只允许用户提供更小的例子。因此，纵向扩展存在一个性能的最大极限。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sharding&lt;/strong&gt;，或者说是水平扩展，相反地将大数据集合拆分并将数据分布到多个服务器，或分片上。每个分片都是一个独立的数据库，所有的分片组成一个逻辑数据库。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/sharded-collection.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;分片地址扩展到支持高吞吐率和大数据集合的难点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;分片降低了每个分片处理操作的数量，随着集群的增长，每个分片将会处理更少的操作。其结果是，一个集群能够&lt;em&gt;水平地&lt;/em&gt;增加容纳量和高吞吐量。例如：插入数据时，应用程序只需要访问负责该记录的碎片。&lt;/li&gt;
&lt;li&gt;分片减少了每个服务器需要存储的数据量，随着集群的增长，每个分片将会保存更少的数据。例如：一个数据库有 1TB 的数据，分4个分片后，每个分片只要保存 256GB 的数据；如果有40个分片的话，每个分片只需要保存 25GB 的数据。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;二、MongoDB 分片&lt;/h2&gt;

&lt;p&gt;MongoDB 支持通过配置一个分片集群来支持分片。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/sharded-cluster-production-architecture.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;分片集群由分片、查询路由和配置服务器三个组件构成：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Shards&lt;/strong&gt; 用于保存数据。为了提供高可用性和数据一致性，在一个生产环境分片集群中，每个分片都有一个复制集( Replica Set )。关于复制集更多的信息，见&lt;a href=&quot;http://docs.mongodb.org/manual/core/replication/&quot; title=&quot;http://docs.mongodb.org/manual/core/replication/&quot;&gt;Replica Sets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Query Routers&lt;/strong&gt;，或者说&lt;code&gt;mongos&lt;/code&gt;实例，客户端应用程序操作的接口，直接操作合适的分片或分片集。查询路由处理并将操作定位到分片，然后将结果返回给客户端。一个分片集群能够包含多个查询路由( Query Router )，用以分担客户端请求的负载。一个客户端和一个查询路由一一对应，更多的分片集群需要很多的查询路由。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Config Server&lt;/strong&gt; 保存集群的元数据( metadata )，包含集群数据集到分片的映射，查询路由通过元数据将操作定位到指定的分片上。生产环境下，拥有确切的 &lt;strong&gt;&lt;em&gt;3&lt;/em&gt;&lt;/strong&gt;个配置服务器。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;数据分割&lt;/h3&gt;

&lt;p&gt;MongoDB 在集合的水平上分割数据和分片，通过一个分片键( shard key )来分割分片。&lt;/p&gt;

&lt;h4&gt;分片键( Shard Keys )&lt;/h4&gt;

&lt;p&gt;为了将一个集合分片，需要选择一个分片关键字。一个分片关键字是一个索引字段，或存在于每个集合文档中的一个复合索引字段。MongoDB 按分片字段将集合划分为块( chunks )，然后讲所有的块均匀的分布到所有分片上。为了划分集合为区块，MongoDB 提供了&lt;strong&gt;&lt;em&gt;范围分片(Range Based Sharding)&lt;/em&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;em&gt;哈希分片(Hash Based Sharding)&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;h4&gt;范围分片( Range Based Sharding )&lt;/h4&gt;

&lt;p&gt;在&lt;em&gt;范围分片&lt;/em&gt;中，MongoDB 通过范围划分字段值提供的范围分割，将数据集合划分为不同的范围边界。就像一个数字分片字段：将负无穷到正无穷的所有数形象化为一条线，每个分片字段的值都落在该线上的某个点上。此线段被 MongoDB 划分为的更小的，没有重叠的范围叫做块( chunks )，一个块是某最小值到某最大值之间值的范围。&lt;/p&gt;

&lt;p&gt;已知的一个范围分割系统，文档中分片字段值为“close”的值在同一个块上，因此也在同一个分片上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/sharding-range-based.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;哈希分片( Hash Based Sharding )&lt;/h4&gt;

&lt;p&gt;在&lt;em&gt;哈希分片&lt;/em&gt;中，MongoDB 计算一个字段值的哈希值，然后使用此哈希值创建一个区块。&lt;/p&gt;

&lt;p&gt;如果使用哈希分割，分片字段值为“close”的两个文档可能不在同一个区块中，这确保了一个集合在集群中更大限度的随机分布。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/sharding-hash-based.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;范围分片和哈希分片的性能差异&lt;/h4&gt;

&lt;p&gt;基于范围的分片方式提供了更高效的范围查询，给定一个片键的范围，分发路由可以很简单地确定哪个数据块存储了请求需要的数据，并将请求转发到相应的分片中。&lt;/p&gt;

&lt;p&gt;不过，基于范围的分片会导致数据在不同分片上的不均衡，有时候，带来的消极作用会大于查询性能的积极作用。比如，如果片键所在的字段是线性增长的，一定时间内的所有请求都会落到某个固定的数据块中，最终导致分布在同一个分片中。在这种情况下，一小部分分片承载了集群大部分的数据，系统并不能很好地进行扩展。&lt;/p&gt;

&lt;p&gt;与此相比，基于哈希的分片方式以范围查询性能的损失为代价，保证了集群中数据的均衡。哈希值的随机性使数据随机分布在每个数据块中，因此也随机分布在不同分片中。但是也正由于随机性，一个范围查询很难确定应该请求哪些分片，通常为了返回需要的结果，需要请求所有分片。&lt;/p&gt;

&lt;h4&gt;使用标记自定义集群中数据的分布&lt;/h4&gt;

&lt;p&gt;MongoDB允许管理员使用 &lt;strong&gt;Tag Aware Sharding&lt;/strong&gt; 直接决定集群的均衡策略。管理员使用标记与片键的范围做绑定，并将标记与分片直接绑定，之后，均衡器会将满足标记的数据直接分发到与之绑定的分片上，并且确保之后满足标记的数据一直存储在相应的分片上。&lt;/p&gt;

&lt;p&gt;标记是控制均衡器行为和数据块分布的首要条件，一般来讲，在拥有多个数据中心时，才会使用标记自定义集群中数据块的分布，以提高不同地域之间数据访问的效率。&lt;/p&gt;

&lt;p&gt;参考 &lt;strong&gt;&lt;a href=&quot;http://docs.mongodb.org/manual/core/tag-aware-sharding/&quot; title=&quot;http://docs.mongodb.org/manual/core/tag-aware-sharding/&quot;&gt;Tag Aware Sharding&lt;/a&gt;&lt;/strong&gt; 获得更多相关信息。&lt;/p&gt;

&lt;h4&gt;数据分布均衡的维护&lt;/h4&gt;

&lt;p&gt;新数据的加入或者新分片的加入可能会导致集群中数据的不均衡，即表现为有些分片保存的数据块数目显著地大于其他分片保存的数据块数。&lt;/p&gt;

&lt;p&gt;MongoBD使用两个过程维护集群中数据的均衡：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;分裂；&lt;/p&gt;

&lt;p&gt; 分裂是防止某个数据块过大而进行的一个后台任务。当一个数据块的大小超过&lt;a href=&quot;http://docs.mongodb.org/manual/core/sharding-chunk-splitting/#sharding-chunk-size&quot; title=&quot;http://docs.mongodb.org/manual/core/sharding-chunk-splitting/#sharding-chunk-size&quot;&gt;设定的数据块大小&lt;/a&gt;时，MongoDB会将其一分为二，插入与更新触发分裂过程。分裂改变了元信息。但是效率很高，进行分裂时，MongoDB 不会迁移任何数据，对集群性能也没有影响。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;/images/post/sharding-splitting.png&quot; alt=&quot;sharding-splitting&quot; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;均衡器。&lt;/p&gt;

&lt;p&gt; 均衡器是一个管理区块迁移的后台进程，均衡器在一个集群中所有的查询路由上运行。&lt;/p&gt;

&lt;p&gt; 当集群中数据的不均衡发生时，均衡器会将数据块从数据块数目最多的分片迁移到数据块最少的分片上，举例来讲：如果集合 &lt;strong&gt;users&lt;/strong&gt; 在 &lt;em&gt;shard1&lt;/em&gt; 上有100个数据块，在 &lt;em&gt;shard2&lt;/em&gt; 上有50个数据块，均衡器会将数据块从 &lt;em&gt;shard1&lt;/em&gt; 一直向 &lt;em&gt;shard2&lt;/em&gt; 迁移，一直到数据均衡为止。&lt;/p&gt;

&lt;p&gt; 分片管理在后台管理从 &lt;em&gt;源分片&lt;/em&gt; 到 &lt;em&gt;目标分片&lt;/em&gt; 的数据块迁移，在迁移过程中，&lt;em&gt;目标分片&lt;/em&gt;首先会接收源分片在迁移数据块上的所有数据，之后，目标分片应用在上一迁移步骤之间发生在源分片上的迁移数据块的更改，最后，存储在&lt;em&gt;配置服务器&lt;/em&gt; 上的元信息被更新。&lt;/p&gt;

&lt;p&gt; 如果迁移中发生错误，源分片上的数据不会被修改，迁移会停止。在迁移成功结束之后MongoDB才会在源分片上将数据删除。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;/images/post/sharding-migrating.png&quot; alt=&quot;sharding-migrating&quot; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;在集群中增加或者删除分片&lt;/h4&gt;

&lt;p&gt;在集群中增加分片时，由于新的分片上并没有数据块，会造成数据的不均衡。此时MongoDB会立即开始向新分片迁移数据，集群达到数据均衡的状态需要花费一些时间。&lt;/p&gt;

&lt;p&gt;当删除一个分片时，均衡器需要将被删除的分片上的数据全部迁移到其他分片上，在全部迁移结束且元信息更新完毕之后，你可以安全地将这个分片移除。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>JAXB使用教程一:简介与基本用法</title>
   <link href="http://www.blogways.net/blog/2015/05/05/jaxb-tutorial-1.html"/>
   <updated>2015-05-05T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/05/05/jaxb-tutorial-1</id>
   <content type="html">&lt;h2&gt;一、简介&lt;/h2&gt;

&lt;p&gt;JAXB（Java Architecture for XML Binding简称JAXB）允许Java开发人员将Java类映射为XML表示方式。JAXB提供两种主要特性：将一个Java对象序列化为XML，以及反向操作，将XML解析成Java对象。换句话说，JAXB允许以XML格式存储和读取数据，而不需要程序的类结构实现特定的读取XML和保存XML的代码！&lt;/p&gt;

&lt;p&gt;JAXB 已经是 Java SE平台的一部分，Java EE平台API之一，也是Java Web服务开发包(JWSDP)的一部分。&lt;/p&gt;

&lt;p&gt;JAXB在Java SE平台上，对应版本分别为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Java SE 8: JAXB 2.2.8&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Java SE 7: JAXB 2.2.3 (JSR 222, maintenance release 2)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Java SE 6: JAXB 2.0 (JSR 222)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;二、JAXB和Dom/SAX/JDOM/Dom4J对比&lt;/h2&gt;

&lt;p&gt;其实，JAXB不能直接拿来和Dom/SAX/Dom4j进行比较。他们的设计理念不同。后者提供的API都是解析XML的底层API，而前者设计的目的是将XML文件中的元素及属性和JAVA对象建立绑定关系，可以自动相互转换。&lt;/p&gt;

&lt;p&gt;JAXB没有提供解析XML的新方法，它是调用后者(Dom/SAX/JDOM/Dom4J)来解析XML的。（JAXB默认是调用SAX来实现XML解析的）&lt;/p&gt;

&lt;p&gt;如果，你仅仅是想把XML的内容转换成Java对象，那么JAXB比起后者更容易实现，它可以让你少些一些代码。特别是，当XML的结构非常复杂时，他的代码量比后者要少很多。&lt;/p&gt;

&lt;p&gt;当然，他们之间的取舍，主要还是以你的使用目的所决定。&lt;/p&gt;

&lt;p&gt; &lt;em&gt;另外，关于DOM和SAX的更多信息，可以看看我的另一篇博文:&lt;a href=&quot;javax-xml-parsers.html&quot;&gt;javax.xml.parsers使用简介及源码探究:DOM与SAX&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;下面，我们就来看看，如何在xml文件和java对象间，使用JAXB进行转换。&lt;/p&gt;

&lt;h2&gt;三、编组(marshal)&lt;/h2&gt;

&lt;p&gt;将Java对象，转换为Xml文件，我们称之为编组(marshal).&lt;/p&gt;

&lt;p&gt;转换代码很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void main( String[] args )
{
    try
    {

        /* 初始化java对象 */
        Person person = new Person();
        person.setFirstName(&quot;net&quot;);
        person.setLastName(&quot;blogways&quot;);
        person.setCity(&quot;NanJing&quot;);
        person.setPostalCode(210000);
        person.setBirthday(LocalDate.of(2013, 10, 11));

        /* 初始化 jaxb marshaler */
        JAXBContext jaxbContext = JAXBContext.newInstance( Person.class );
        Marshaller jaxbMarshaller = jaxbContext.createMarshaller();

        /* 设置为格式化输出 */
        jaxbMarshaller.setProperty( Marshaller.JAXB_FORMATTED_OUTPUT, true );

        /* 将java对象 编组 为xml (输出到文件或标准输出) */
        jaxbMarshaller.marshal( person, new File( &quot;person.xml&quot; ) );
        jaxbMarshaller.marshal( person, System.out );
    }
    catch( JAXBException e )
    {
        e.printStackTrace();
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而在&lt;code&gt;Person.java&lt;/code&gt;中，你只需要通过注释，就可以告诉程序，要转换为什么格式的Xml文件。&lt;/p&gt;

&lt;p&gt;比如, &lt;strong&gt;Person.java：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package net.blogways.jaxb.example.model;

import java.time.LocalDate;

import javax.xml.bind.annotation.XmlRootElement;

@XmlRootElement( name = &quot;Person&quot; )
public class Person {
    private String firstName;
    private String lastName;
    private Integer postalCode;
    private String city;
    private LocalDate birthday;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public Integer getPostalCode() {
        return postalCode;
    }

    public void setPostalCode(Integer postalCode) {
        this.postalCode = postalCode;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public LocalDate getBirthday() {
        return birthday;
    }

    public void setBirthday(LocalDate birthday) {
        this.birthday = birthday;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;@XmlRootElement 定义了根节点的名字&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;是不是很简单？！&lt;/p&gt;

&lt;p&gt;另外，需要说明的是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;Person.java&lt;/code&gt;中，你可以通过更多的&lt;a href=&quot;#5&quot;&gt;注释&lt;/a&gt;，来定义编组后的xml格式。&lt;/li&gt;
&lt;li&gt;在一个复杂的项目中，XML文件结构可能很复杂。这时，不需要手工编写对应的Java类文件，我们可以通过工具从xml schema文件获得java类文件，甚至可以从xml文件中转换得到java类文件。这些我们在后续的文章中介绍。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;四、反编组(Un-marshal)&lt;/h2&gt;

&lt;p&gt;将Xml文件的内容，转换为Java对象，我们称之为反编组(un-marshal).&lt;/p&gt;

&lt;p&gt;反编组，也很简单。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
    try
    {

        File file = new File( &quot;list.xml&quot; );
        JAXBContext jaxbContext = JAXBContext.newInstance( Persons.class );

        Unmarshaller jaxbUnmarshaller = jaxbContext.createUnmarshaller();

        Persons persons = (Persons)jaxbUnmarshaller.unmarshal( file );
        System.out.println( persons );

    }
    catch( JAXBException e )
    {
        e.printStackTrace();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;转换的对应关系，都在Persons.java里面。这里为了示例更简单清晰，我们只加了一行注释&lt;code&gt;XmlRootElement&lt;/code&gt;,代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package net.blogways.jaxb.example.model;

import java.util.List;

import javax.xml.bind.annotation.XmlRootElement;

@XmlRootElement( name = &quot;Persons&quot; )
public class Persons {

    private List&amp;lt;Person&amp;gt; persons;

    public List&amp;lt;Person&amp;gt; getPersons() {
        return persons;
    }

    public void setPersons(List&amp;lt;Person&amp;gt; persons) {
        this.persons = persons;
    }

    @Override
    public String toString()
    {
        StringBuffer str = new StringBuffer();
        for( Person person : this.persons )
        {
            str.append( person.toString() );
            str.append(&quot;\n&quot;);
        }
        return str.toString();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;list.xml内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&amp;gt;
&amp;lt;Persons&amp;gt;
    &amp;lt;persons&amp;gt;
        &amp;lt;city&amp;gt;NanJing&amp;lt;/city&amp;gt;
        &amp;lt;firstName&amp;gt;Li&amp;lt;/firstName&amp;gt;
        &amp;lt;lastName&amp;gt;si&amp;lt;/lastName&amp;gt;
        &amp;lt;postalCode&amp;gt;210000&amp;lt;/postalCode&amp;gt;
    &amp;lt;/persons&amp;gt;
    &amp;lt;persons&amp;gt;
        &amp;lt;city&amp;gt;NanJing&amp;lt;/city&amp;gt;
        &amp;lt;firstName&amp;gt;zhang&amp;lt;/firstName&amp;gt;
        &amp;lt;lastName&amp;gt;san&amp;lt;/lastName&amp;gt;
        &amp;lt;postalCode&amp;gt;210000&amp;lt;/postalCode&amp;gt;
    &amp;lt;/persons&amp;gt;
&amp;lt;/Persons&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&quot;5&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;五、注释&lt;/h2&gt;

&lt;p&gt;在本文前面部分，为了简化示例。我们仅使用了JAXB中的&lt;code&gt;@XmlRootElement&lt;/code&gt;注解来编组和反编组XML。&lt;/p&gt;

&lt;p&gt;我们在下面列出了最重要的一些注解:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XmlAccessorOrder&lt;/code&gt;: 本注解控制类里的字段和属性在XML中出现的顺序。更多信息请看: &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlAccessorOrder.html&quot;&gt;https://docs.oracle.com/javase/8/docs/.../XmlAccessOrder.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XmlAccessorType&lt;/code&gt;: 表示一个元素是否可以被序列化。它可以和 &lt;code&gt;javax.xml.bind.annotation.XMLAccessType&lt;/code&gt;一起使用。 更多信息请看: &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlAccessorType.html&quot;&gt;https://docs.oracle.com/javase/8/docs/.../XmlAccessorType.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XmlAnyAttribute&lt;/code&gt;: 映射一个元素到通配符（wildcard ）属性的Map。更多信息请看&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlAnyAttribute.html&quot;&gt;https://docs.oracle.com/javase/8/docs/.../XmlAnyAttribute.html&lt;/a&gt; .&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XmlAnyElement&lt;/code&gt;: 在没有映射被预定义时，作为反编组操作的一个缺省。 更多信息请看&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlAnyElement.html&quot;&gt;https://docs.oracle.com/javase/8/docs/.../XmlAnyElement.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XmlAttribute&lt;/code&gt;: 本注解是最基础和最常使用的一个。它映射一个Java元素(property, attribute, field) 到一个XML节点属性. 本教程中多个例子中用到了它。 更多信息请看 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlAttribute.html&quot;&gt;https://docs.oracle.com/javase/8/docs/.../XmlAttribute.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XmlElement&lt;/code&gt;: 使用name映射一个Java元素到XML节点。 更多信息请看 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlElement.html&quot;&gt;https://docs.oracle.com/javase/8/docs/.../XmlElement.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XmlElementRef&lt;/code&gt;: 使用type (不同于上者, name被用来做映射)映射一个Java元素到一个XML节点 . 更多信息请看 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlElementRef.html&quot;&gt;https://docs.oracle.com/javase/8/docs/.../XmlElementRef.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XmlElementRefs&lt;/code&gt;: 标记一个指向XmlElement 和JAXBElement所注解的类。更多信息请看&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlElementRefs.html&quot;&gt;https://docs.oracle.com/javase/8/docs/.../XmlElementRefs.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XmlElements&lt;/code&gt;: 这是一个包含多个XMLElement 注解的容器。更多信息请看&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlElements.html&quot;&gt;https://docs.oracle.com/javase/8/docs/.../XmlElements.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XmlElementWrapper&lt;/code&gt;: 它生成一个围绕XML结构的包装器，旨在和集合一起使用，本教程中我们看到了有不同的方式来处理集合。更多信息请看&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlElementWrapper.html&quot;&gt;https://docs.oracle.com/javase/8/docs/.../XmlElementWrapper.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XmlEnum&lt;/code&gt;: 提供emum到XML的映射。它和XmlEnumValue一起工作。更多信息请看&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlEnum.html&quot;&gt;https://docs.oracle.com/javase/8/docs/.../XmlEnum.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XmlEnumValue&lt;/code&gt;:映射一个enum常量到一个XML元素。更多信息请看&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlEnumValue.html&quot;&gt;https://docs.oracle.com/javase/8/docs/.../XmlEnumValue.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XmlID&lt;/code&gt;: 映射一个属性到XML id。更多信息请看 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlID.html&quot;&gt;https://docs.oracle.com/javase/8/docs/.../XmlID.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XmlList&lt;/code&gt;: 另一种在JAXB中处理list的方式。更多信息请看 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlList.html&quot;&gt;https://docs.oracle.com/javase/8/docs/.../XmlList.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XmlMimeType&lt;/code&gt;: 控制被注解的属性的表现形式。更多信息请看&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlMimeType.html&quot;&gt;https://docs.oracle.com/javase/8/docs/.../XmlMimeType.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XmlMixed&lt;/code&gt;: 被注解的元素包含混合的内容。内容可以是文本或未知的（unknown）。更多信息请看&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlMixed.html&quot;&gt;https://docs.oracle.com/javase/8/docs/.../XmlMixed.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XmlRootElement&lt;/code&gt;: 这可能是JAXB中使用最多的注解了。它用于映射一个类到XML元素。它基本上是每一个JAXB的入口点。更多信息请看&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlRootElement.html&quot;&gt;https://docs.oracle.com/javase/8/docs/.../XmlRootElement.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XmlSchema&lt;/code&gt;: 映射一个package到XML命名空间。更多信息请看&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlSchema.html&quot;&gt;https://docs.oracle.com/javase/8/docs/.../XmlSchema.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XmlSchemaType&lt;/code&gt;: 映射一个Java类型到一个内置的simple schema。更多信息请看&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlSchemaType.html&quot;&gt;https://docs.oracle.com/javase/8/docs/.../XmlSchemaType.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XmlSeeAlso&lt;/code&gt;: 告诉JAXB在绑定被注解类时，去绑定其他类。这是必须的，因为Java很难列出一个类的所有子类，使用这种机制，你可以告诉JAXB在处理一个特定类的时候哪一个子类（或其他类）应该被绑定。更多信息请看 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlSeeAlso.html&quot;&gt;https://docs.oracle.com/javase/8/docs/.../XmlSeeAlso.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XmlType&lt;/code&gt;: 用于map一个类或enum到XML Schema中的一个type。更多信息请看&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlType.html&quot;&gt;https://docs.oracle.com/javase/8/docs/.../XmlType.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XmlValue&lt;/code&gt;: 允许map一个类到一个包含simpleContent 的XML Schema复杂类型或一个XML Schema的简单类型。更多信息请看&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlValue.html&quot;&gt;https://docs.oracle.com/javase/8/docs/.../XmlValue.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;这是一个很长的列表，但是并不是所有的JAXB的注解。要查看JAXB的所有注解的列表，请查看package 的 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/package-summary.html&quot;&gt;summary&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;六、适配器(Adapters)&lt;/h2&gt;

&lt;p&gt;细心的读者，可能发现在前面编组的例子中，&lt;code&gt;birthday&lt;/code&gt;是&lt;code&gt;LocalDate&lt;/code&gt;类型，作为复杂类型，不能很好地被编组和反编组。这时需要一个适配器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DateAdapter.java:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package net.blogways.jaxb.example.adapter;

import java.time.LocalDate;
import javax.xml.bind.annotation.adapters.XmlAdapter;

public class DateAdapter extends XmlAdapter&amp;lt;String, LocalDate&amp;gt;
{

    public LocalDate unmarshal( String date ) throws Exception
    {
        return LocalDate.parse( date );
    }

    public String marshal( LocalDate date ) throws Exception
    {
        return date.toString();
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改Person.java，添加&lt;code&gt;@XmlJavaTypeAdapter&lt;/code&gt;注释，如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@XmlJavaTypeAdapter( DateAdapter.class )
public void setBirthday(LocalDate birthday) {
    this.birthday = birthday;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再次运行本文前面部分的编组程序，标准输出如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&amp;gt;
&amp;lt;Person&amp;gt;
    &amp;lt;birthday&amp;gt;2013-10-11&amp;lt;/birthday&amp;gt;
    &amp;lt;city&amp;gt;NanJing&amp;lt;/city&amp;gt;
    &amp;lt;firstName&amp;gt;net&amp;lt;/firstName&amp;gt;
    &amp;lt;lastName&amp;gt;blogways&amp;lt;/lastName&amp;gt;
    &amp;lt;postalCode&amp;gt;210000&amp;lt;/postalCode&amp;gt;
&amp;lt;/Person&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完美了，日期也可以显示出来了！&lt;/p&gt;

&lt;h2&gt;七、总结&lt;/h2&gt;

&lt;p&gt;好了，至此，你已经掌握了基本的JAXB的使用方法。可以编组、反编组、编写适配器，并且对相关注释也有了一个基本的了解，至少，你知道可以去哪查询都有哪些注释了。：）&lt;/p&gt;

&lt;p&gt;后面，我们将会继续介绍关于JAXB的一些复杂的应用。比如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;介绍如何通过XML Schema文件来校验XML文件格式的正确与否&lt;/li&gt;
&lt;li&gt;介绍JAXBContext.newInstance的逻辑&lt;/li&gt;
&lt;li&gt;介绍对XML文件中名字空间的操作&lt;/li&gt;
&lt;li&gt;介绍对XML文件中processing instruction的操作&lt;/li&gt;
&lt;li&gt;介绍一些和JAXB有关的常见工具的使用&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;本文，所使用的示例完整代码，可以在本系列文章完结时提供。&lt;/p&gt;

&lt;h2&gt;八、参考文献&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/zh/JAXB&quot;&gt;http://zh.wikipedia.org/zh/JAXB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Java_Architecture_for_XML_Binding&quot;&gt;http://en.wikipedia.org/wiki/Java_Architecture_for_XML_Binding&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/7709928/jaxb-vs-dom-and-sax&quot;&gt;http://stackoverflow.com/questions/7709928/jaxb-vs-dom-and-sax&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/607141/what-is-jaxb-and-why-would-i-use-it&quot;&gt;http://stackoverflow.com/questions/607141/what-is-jaxb-and-why-would-i-use-it&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javacodegeeks.com/2014/12/jaxb-tutorial-xml-binding.html&quot;&gt;http://www.javacodegeeks.com/2014/12/jaxb-tutorial-xml-binding.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javacodegeeks.com/zh-hans/2015/04/%E7%94%A8%E4%BA%8Ejava%E5%92%8Cxml%E7%BB%91%E5%AE%9A%E7%9A%84jaxb%E6%95%99%E7%A8%8B.html&quot;&gt;http://www.javacodegeeks.com/zh-hans/2015/04/%E7%94%A8%E4%BA%8Ejava%E5%92%8Cxml%E7%BB%91%E5%AE%9A%E7%9A%84jaxb%E6%95%99%E7%A8%8B.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>javax.xml.parsers使用简介及源码探究:DOM与SAX</title>
   <link href="http://www.blogways.net/blog/2015/05/05/javax-xml-parsers.html"/>
   <updated>2015-05-05T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/05/05/javax-xml-parsers</id>
   <content type="html">&lt;h2&gt;一、简介&lt;/h2&gt;

&lt;p&gt;Java SE 平台提供的 XML 处理主要包括两个功能：JAXP（XML 处理，Java Architecture XML Processing）和 JAXB（XML 绑定，Java Architecture XML Binding）。&lt;/p&gt;

&lt;h3&gt;1.1 关于JAXB&lt;/h3&gt;

&lt;p&gt;JAXB 则是负责将 XML 文件和 Java 对象绑定，在新版 JDK 中，被大量的使用在 Web 服务技术中。&lt;/p&gt;

&lt;h3&gt;1.2 关于JAXP&lt;/h3&gt;

&lt;p&gt;JAXP 包括 SAX 框架 —— 遍历元素，做出处理；DOM 框架 —— 构造 XML 文件的树形表示；StAX 框架 —— 拖拽方式的解析；XSLT 框架 —— 将 XML 数据转换成其他格式。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;SAX 框架（Simple API for XML）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SAX 全称 Simple API for XML，该框架使用了事件处理机制来处理 XML 文件。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;DOM 框架（Document Object Model）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;DOM 框架的全称是 Document Object Model。顾名思义，这个框架会建立一个对象模型。针对每个节点，以及节点之间的关系在内存中生成一个树形结构。这个特点与 SAX 框架截然相反。需要注意的是，DOM 框架提供的对象树模型与我们通常理解的 XML 文件结构树模型是有一定的区别的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;StAX 框架（Streaming API for XML）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SAX 框架的缺点是不能记录正在处理元素的上下文。但是优点是运行时占内存空间比较小，效率高。DOM 框架由于在处理 XML 时需要为其构造一棵树，所以特点正好相反。StAX 框架出现于 Java SE 6 中，它的设计目标就是要结合 SAX 框架和 DOM 框架的优点。既要求运行时效率，也要求保持元素的上下文状态。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;XSLT 数据转换框架（The Extensible Stylesheet Language Transformations APIs）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一般来说 XML 文件格式被认为是一种很好的数据交换格式。于是 Java SE 6 SDK 基于以上介绍的三种 XML 处理机制，提供了一个 XML 转换框架。XSLT 框架负责进行转换 —— 包括将 XML 文件转换成其他形式如 HTML，和将其他形式的文件转换成 XML 文件。更进一步说，这个框架可以接受 DOM 作为其输入和输出；可以接受 SAX 解析器作为输入或者产生 SAX 事件作为输出；可以接受 I/O Stream 作为输入和输出；当然也支持用户自定义形式的输入和输出。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;JDK中&lt;code&gt;javax.xml.parsers&lt;/code&gt;包下是SAX和DOM的实现。下面，我们将简单介绍该包的使用。&lt;/p&gt;

&lt;h2&gt;二、对比(SAX与DOM)&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;DOM思想：将整个XML加载内存中，形成文档对象，所以对XML操作都对内存中文档对象进行。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SAX思想：一边解析，一边处理，一边释放内存资源。不允许在内存中保留大规模XML数据。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DOM和SAX的区别：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DOM：支持回写，会将整个XML载入内存，以树形结构方式存储；XML比较复杂的时候，或者当你需要随机处理文档中数据的时候不建议使用&lt;/li&gt;
&lt;li&gt;SAX：相比DOM是一种更为轻量级的方案；无法在读取过程中修改XML数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解析速度： SAX &gt; StAX &gt; DOM&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;三、使用示例&lt;/h2&gt;

&lt;h3&gt;3.1 staffs.xml&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
&amp;lt;company&amp;gt;
    &amp;lt;staff&amp;gt;
        &amp;lt;firstname&amp;gt;yong&amp;lt;/firstname&amp;gt;
        &amp;lt;lastname&amp;gt;mook kim&amp;lt;/lastname&amp;gt;
        &amp;lt;nickname&amp;gt;mkyong&amp;lt;/nickname&amp;gt;
        &amp;lt;salary&amp;gt;100000&amp;lt;/salary&amp;gt;
    &amp;lt;/staff&amp;gt;
    &amp;lt;staff&amp;gt;
        &amp;lt;firstname&amp;gt;low&amp;lt;/firstname&amp;gt;
        &amp;lt;lastname&amp;gt;yin fong&amp;lt;/lastname&amp;gt;
        &amp;lt;nickname&amp;gt;fong fong&amp;lt;/nickname&amp;gt;
        &amp;lt;salary&amp;gt;200000&amp;lt;/salary&amp;gt;
    &amp;lt;/staff&amp;gt;
&amp;lt;/company&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3.2 DOM的使用示例&lt;/h3&gt;

&lt;p&gt;DOM的使用，分为两步：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将XML文件解析为Document对象&lt;/li&gt;
&lt;li&gt;对Document对象进行处理&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;解析代码，主体如下：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void main(String[] args) throws Exception {

    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();

    DocumentBuilder builder = factory.newDocumentBuilder();

    Document document = builder.parse(new InputSource(new FileInputStream(&quot;staffs.xml&quot;)));

    forEachNode(document);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;其中，对Document对象的处理方法如下：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static void forEachNode(Document doc) {
    NodeList nodeList =  doc.getDocumentElement().getChildNodes();

    for(int i=0; i&amp;lt;nodeList.getLength(); ++i) {
        Node staff = nodeList.item(i);
        if (staff instanceof Element) {
            NodeList props = staff.getChildNodes();

            for (int j=0; j&amp;lt;props.getLength(); ++j) {
                Node prop = props.item(j) ;
                if (prop instanceof Element) {
                    String content = prop.getLastChild().getTextContent().trim();
                    switch(prop.getNodeName()) {
                    case &quot;firstname&quot;: 
                        System.out.println(&quot;firstname:&quot;+content);
                        break;
                    case &quot;lastname&quot;:
                        System.out.println(&quot;lastname:&quot;+content);
                        break;
                    case &quot;nickname&quot;:
                        System.out.println(&quot;nickname:&quot;+content);
                        break;
                    case &quot;salary&quot;:
                        System.out.println(&quot;salary:&quot;+content);
                        break;
                    }
                }
            }

            System.out.println();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3.3 SAX的使用示例&lt;/h3&gt;

&lt;p&gt;SAX的使用，在于需要自定义一个&lt;code&gt;org.xml.sax.ContentHandler&lt;/code&gt;处理器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解析的主体代码如下：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void main(String[] args) throws Exception {

    SAXParserFactory spf = SAXParserFactory.newInstance();
    spf.setNamespaceAware( true );

    XMLReader xmlReader = spf.newSAXParser().getXMLReader();

    xmlReader.setContentHandler(new StaffHandler());

    xmlReader.parse(new InputSource(new FileInputStream(&quot;staffs.xml&quot;)));

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;自定义的处理器 StaffHandler:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class StaffHandler extends DefaultHandler {

    boolean bfname = false;
    boolean blname = false;
    boolean bnname = false;
    boolean bsalary = false;

    public void startElement (String uri, String localName,
            String qName, Attributes attributes) throws SAXException {

        System.out.println(&quot;Start Element :&quot; + qName);

        if (qName.equalsIgnoreCase(&quot;FIRSTNAME&quot;)) {
            bfname = true;
        }

        if (qName.equalsIgnoreCase(&quot;LASTNAME&quot;)) {
            blname = true;
        }

        if (qName.equalsIgnoreCase(&quot;NICKNAME&quot;)) {
            bnname = true;
        }

        if (qName.equalsIgnoreCase(&quot;SALARY&quot;)) {
            bsalary = true;
        }

    }

    public void endElement(String uri, String localName,
        String qName) throws SAXException {

        System.out.println(&quot;End Element :&quot; + qName);

    }

    public void characters(char ch[], int start, int length) throws SAXException {

        if (bfname) {
            System.out.println(&quot;First Name : &quot; + new String(ch, start, length));
            bfname = false;
        }

        if (blname) {
            System.out.println(&quot;Last Name : &quot; + new String(ch, start, length));
            blname = false;
        }

        if (bnname) {
            System.out.println(&quot;Nick Name : &quot; + new String(ch, start, length));
            bnname = false;
        }

        if (bsalary) {
            System.out.println(&quot;Salary : &quot; + new String(ch, start, length));
            bsalary = false;
        }

    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;四、关于 SAXParserFactory 和 DocumentBuilderFactory&lt;/h2&gt;

&lt;h3&gt;4.1 相似的代码，相同的设计模式&lt;/h3&gt;

&lt;p&gt;对比前面的代码，可以发现两者主体部分代码，十分相似，使用了相同的设计模式。&lt;/p&gt;

&lt;p&gt;再看一下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DOM:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//获取工厂实例
DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();

//由工厂实例，获得DocumentBuilder
DocumentBuilder builder = factory.newDocumentBuilder();

//解析ing
Document document = builder.parse(new InputSource(new FileInputStream(&quot;staffs.xml&quot;)));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;SAX:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//获取工厂实例
SAXParserFactory spf = SAXParserFactory.newInstance();
spf.setNamespaceAware( true );

//由工厂实例，获得XMLReader
XMLReader xmlReader = spf.newSAXParser().getXMLReader();

xmlReader.setContentHandler(...);

//解析ing 
xmlReader.parse(new InputSource(new FileInputStream(&quot;staffs.xml&quot;)));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里，我想探讨一下两者的工厂实例是如何获取的。&lt;/p&gt;

&lt;p&gt;查了下jdk 1.8 源码。&lt;/p&gt;

&lt;h3&gt;4.2 两者工厂实例的相同实现&lt;/h3&gt;

&lt;p&gt;两者工厂实例，都是由&lt;code&gt;FactoryFinder.find&lt;/code&gt;方法实现&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;javax.xml.parsers.DocumentBuilderFactory:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static DocumentBuilderFactory newInstance() {
    return FactoryFinder.find(
            /* The default property name according to the JAXP spec */
            DocumentBuilderFactory.class, // &quot;javax.xml.parsers.DocumentBuilderFactory&quot;
            /* The fallback implementation class name */
            &quot;com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;javax.xml.parsers.SAXParserFactory:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static SAXParserFactory newInstance() {
    return FactoryFinder.find(
            /* The default property name according to the JAXP spec */
            SAXParserFactory.class,
            /* The fallback implementation class name */
            &quot;com.sun.org.apache.xerces.internal.jaxp.SAXParserFactoryImpl&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;4.3 FactoryFinder.find 的逻辑&lt;/h3&gt;

&lt;p&gt;继续阅读源码，获知&lt;code&gt;FactoryFinder.find&lt;/code&gt;的逻辑包括两个部分：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;查找定位工厂类&lt;/li&gt;
&lt;li&gt;根据查到的工厂类，生成最终实例&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;如何查找定位工厂类？按下面顺序，使用找到的第一个：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用系统属性。对DocumentBuilderFactory而言，是&lt;code&gt;javax.xml.parsers.DocumentBuilderFactory&lt;/code&gt;；对SAXParserFactory而言，是&lt;code&gt;javax.xml.parsers.SAXParserFactory&lt;/code&gt;。所以，你可以在启动java时，使用&lt;code&gt;-Djavax.xml.parsers.DocumentBuilderFactory=...&lt;/code&gt;来设置DocmentBuilder的工厂类，SAXParser类似。&lt;/li&gt;
&lt;li&gt;读取JRE目录下的属性文件 &quot;lib/jaxp.properties&quot;，其中属性名分别为&lt;code&gt;javax.xml.parsers.DocumentBuilderFactory&lt;/code&gt;和&lt;code&gt;javax.xml.parsers.SAXParserFactory&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;使用jar包的&lt;code&gt;Service Provider&lt;/code&gt;机制，加载工厂类。也就是说，查找所有加载的jar包中&lt;code&gt;META-INF/services&lt;/code&gt;目录下的配置文件，文件名分别为&lt;code&gt;javax.xml.parsers.DocumentBuilderFactory&lt;/code&gt;和&lt;code&gt;javax.xml.parsers.SAXParserFactory&lt;/code&gt;。文件的内容就是该jar包内提供的类实例。比如&lt;code&gt;xercesImple-2.x.x.jar&lt;/code&gt;提供的&lt;code&gt;org.apache.xerces.jaxp.SAXParserFactoryImpl&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;使用系统默认的工厂类。分别为：&lt;code&gt;com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl&lt;/code&gt;和&lt;code&gt;com.sun.org.apache.xerces.internal.jaxp.SAXParserFactoryImpl&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;五、总结&lt;/h2&gt;

&lt;p&gt;好了，至此，你已经掌握了JDK中自带的DOM和SAX的基本使用方法了。&lt;/p&gt;

&lt;p&gt;本文，所使用的示例代码，可以从&lt;a href=&quot;/attachment/src-jaxp20150504.zip&quot;&gt;这里&lt;/a&gt;获取。&lt;/p&gt;

&lt;h2&gt;八、参考文献&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/java/j-lo-jse67/&quot;&gt;https://www.ibm.com/developerworks/cn/java/j-lo-jse67/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/evanliu/p/3665113.html&quot;&gt;http://www.cnblogs.com/evanliu/p/3665113.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.mkyong.com/java/how-to-read-xml-file-in-java-sax-parser/&quot;&gt;http://www.mkyong.com/java/how-to-read-xml-file-in-java-sax-parser/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javacodegeeks.com/2013/05/parsing-xml-using-dom-sax-and-stax-parser-in-java.html&quot;&gt;http://www.javacodegeeks.com/2013/05/parsing-xml-using-dom-sax-and-stax-parser-in-java.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>Solr 应用（三）－查询数据</title>
   <link href="http://www.blogways.net/blog/2015/05/04/solr-usage-3.html"/>
   <updated>2015-05-04T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/05/04/solr-usage-3</id>
   <content type="html">&lt;h3&gt;常用查询参数说明&lt;/h3&gt;

&lt;table class=&quot;table table-bordered table-striped table-condensed&quot;&gt;
    &lt;thead&gt;
        &lt;th width=&quot;20%&quot;&gt;Field&lt;/td&gt;
        &lt;th width=&quot;80%&quot;&gt;Description&lt;/td&gt;
    &lt;/thead&gt;
    &lt;tr&gt;
        &lt;td&gt;Request-handler(qt)&lt;/td&gt;
        &lt;td&gt;指定请求的查询处理。如果没有指定一个查询处理，Solr进程将以标准的查询处理响应。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;q&lt;/td&gt;
        &lt;td&gt;查询字符串，这个是必须的。如果查询所有*:* ，根据指定字段查询（Name:张三 AND Address:北京）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;fq&lt;/td&gt;
        &lt;td&gt;（filter query）过虑查询，作用：在q查询符合结果中同时是fq查询符合的，例如：q=Name:张三&amp;fq=CreateDate:[20081001 TO 20091031],找关键字mm，并且CreateDate是20081001&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;fl&lt;/td&gt;
        &lt;td&gt;指定返回那些字段内容，用逗号或空格分隔多个。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;start&lt;/td&gt;
        &lt;td&gt;返回第一条记录在完整找到结果中的偏移位置，0开始，一般分页用。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;rows&lt;/td&gt;
        &lt;td&gt;指定返回结果最多有多少条记录，配合start来实现分页。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;sort&lt;/td&gt;
        &lt;td&gt;排序，格式：sort=&lt;field name&gt;+&lt;desc|asc&gt;[,&lt;field name&gt;+&lt;desc|asc&gt;]… 。示例：（score desc, price asc）表示先 “score” 降序, 再 “price” 升序，默认是相关性降序。 &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;wt&lt;/td&gt;
        &lt;td&gt;(writer type)指定输出格式，可以有 xml, json, php, phps。 &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;indent&lt;/td&gt;
        &lt;td&gt;是否需要将请求响应的结果以缩进的方式显示出来，使结果更具可读性，类似格式化显示 xml、json 等功能&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;debugQuery&lt;/td&gt;
        &lt;td&gt;是否需要显示调试信息，包括每个文档返回的“解释信息”，以便理解和管理程序的执行过程&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;dismax&lt;/td&gt;
        &lt;td&gt;是否启用 Dismax 查询解析器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;edismax&lt;/td&gt;
        &lt;td&gt;是否启用扩展查询解析器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;fl&lt;/td&gt;
        &lt;td&gt;表示索引显示那些field( *表示所有field,如果想查询指定字段用逗号或空格隔开（如：Name,SKU,ShortDescription或Name SKU ShortDescription【注：字段是严格区分大小写的】）) &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;q.op&lt;/td&gt;
        &lt;td&gt;表示q 中 查询语句的 各条件的逻辑操作 AND(与) OR(或)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;hl&lt;/td&gt;
        &lt;td&gt;是否高亮 ,如hl=true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;hl.fl&lt;/td&gt;
        &lt;td&gt;高亮field ,hl.fl=Name,SKU&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;hl.snippets&lt;/td&gt;
        &lt;td&gt;默认是1,这里设置为3个片段&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;hl.simple.pre&lt;/td&gt;
        &lt;td&gt;高亮前面的格式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;hl.simple.post&lt;/td&gt;
        &lt;td&gt;高亮后面的格式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;facet&lt;/td&gt;
        &lt;td&gt;是否启动统计&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;facet.field&lt;/td&gt;
        &lt;td&gt;统计field&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;spatial&lt;/td&gt;
        &lt;td&gt;是否启用位置数据，该功能在地理或者空间搜索中使用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;spellcheck&lt;/td&gt;
        &lt;td&gt;是否启用拼写检查，提供在线的模糊匹配或者专业术语匹配等建议&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;


&lt;h3&gt;Solr运算符&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;(1) “:” 指定字段查指定值，如返回所有值*:*

(2) “?” 表示单个任意字符的通配

(3) “*” 表示多个任意字符的通配（不能在检索的项开始使用*或者?符号）

(4) “~” 表示模糊检索，如检索拼写类似于”roam”的项这样写：roam~将找到形如foam和roams的单词；roam~0.8，检索返回相似度在0.8以上的记录。

(5) 邻近检索，如检索相隔10个单词的”apache”和”jakarta”，”jakarta apache”~10

(6) “^” 控制相关度检索，如检索jakarta apache，同时希望去让”jakarta”的相关度更加好，那么在其后加上”^”符号和增量值，即jakarta^4 apache

(7) 布尔操作符AND、||

(8) 布尔操作符OR、&amp;amp;&amp;amp;

(9) 布尔操作符NOT、!、- （排除操作符不能单独与项使用构成查询）

(10) “+” 存在操作符，要求符号”+”后的项必须在文档相应的域中存在

(11) ( ) 用于构成子查询

(12) [] 包含范围检索，如检索某时间段记录，包含头尾，date:[200707 TO 200710]

(13) {} 不包含范围检索，如检索某时间段记录，不包含头尾，date:{200707 TO 200710}

(14) / 转义操作符，特殊字符包括+ - &amp;amp;&amp;amp; || ! ( ) { } [ ] ^ ” ~ * ? : /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; &lt;em&gt;注：①“+”和”-“表示对单个查询单元的修饰，and 、or 、 not 是对两个查询单元是否做交集或者做差集还是取反的操作的符号&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;　　 比如:AB:china +AB:america ,表示的是AB:china忽略不计可有可无，必须满足第二个条件才是对的,而不是你所认为的必须满足这两个搜索条件&lt;/p&gt;

&lt;p&gt;　　 如果输入:AB:china AND AB:america ,解析出来的结果是两个条件同时满足，即+AB:china AND +AB:america或+AB:china +AB:america&lt;/p&gt;

&lt;p&gt;　　 总而言之，查询语法：  修饰符 字段名:查询关键词 AND/OR/NOT 修饰符 字段名:查询关键词&lt;/p&gt;

&lt;h3&gt;Solr查询语法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;(1) 最普通的查询，比如查询姓张的人（ Name:张）,如果是精准性搜索相当于SQL SERVER中的LIKE搜索这需要带引号（&quot;&quot;）,比如查询含有北京的（Address:&quot;北京&quot;）    

(2) 多条件查询，注：如果是针对单个字段进行搜索的可以用（Name:搜索条件加运算符(OR、AND、NOT) Name：搜索条件）,比如模糊查询（ Name:张 OR Name:李 ）单个字段多条件搜索不建议这样写，一般建议是在单个字段里进行条件筛选，如（ Name:张 OR 李），多个字段查询（Name:张 + Address:北京 ）   

(3) 排序，比如根据姓名升序（Name asc）,降序（Name desc）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本文参考了 &lt;code&gt;http://blog.csdn.net/cgddm/article/details/44303203&lt;/code&gt; 这篇文章中的 &lt;code&gt;Solr查询数据&lt;/code&gt; 部分来写的，参数部分增加了一些官方文档里面多出来参数&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>MongoDB 安装与分布式部署</title>
   <link href="http://www.blogways.net/blog/2015/05/04/mongodb-install-and-distribution-deploy.html"/>
   <updated>2015-05-04T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/05/04/mongodb-install-and-distribution-deploy</id>
   <content type="html">&lt;h2&gt;一、概述&lt;/h2&gt;

&lt;p&gt;NoSQL数据库与传统的关系型数据库相比，它具有操作简单、完全免费、源码公开、随时下载等特点，并可以用于各种商业目的。这使NoSQL产品广泛应用于各种大型门户网站和专业网站，大大降低了运营成本。&lt;/p&gt;

&lt;p&gt;MongoDB的文档模型自由灵活，可以让你在开发过程中畅顺无比。对于大数据量、高并发、弱事务的互联网应用，MongoDB可以应对自如。MongoDB内置的水平扩展机制提供了从百万到十亿级别的数据量处理能力，完全可以满足Web2.0和移动互联网的数据存储需求，其开箱即用的特性也大大降低了中小型网站的运维成本。&lt;/p&gt;

&lt;h2&gt;二、安装MongoDB&lt;/h2&gt;

&lt;p&gt;到官网下载对应的版本&lt;a href=&quot;http://www.mongodb.org/downloads&quot;&gt;http://www.mongodb.org/downloads&lt;/a&gt;，下载完成后解压即可使用。也可以下载源码自己编译&lt;a href=&quot;https://github.com/mongodb/mongo&quot;&gt;https://github.com/mongodb/mongo&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;下载编译好的文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/tools
wget -c https://fastdl.mongodb.org/osx/mongodb-osx-x86_64-3.0.2.tgz
# 等待下载完成
tar zxf mongodb-osx-x86_64-3.0.2
ln -s mongodb-osx-x86_64-3.0.2 mongodb
echo &quot;export MONGODB_HOME=~/tools/mongodb&quot; &amp;gt;&amp;gt; ~/.bash_profile &amp;amp;&amp;amp; source ~/.bash_profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命令行启动 MongoDB 后台驻留程序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongod --dbpath /data/mongodb/db --logpath /data/mongodb/logs/mongod.log --nojournal --fork --port 27037
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后台mongodb 主流程序，监听本机 27037 号端口，数据库文件保存在&lt;code&gt;/data/mongodb/db&lt;/code&gt;目录下，日志文件输出到&lt;code&gt;/data/mongodb/logs/mongod.log&lt;/code&gt;文件下，并禁用&lt;code&gt;journaling&lt;/code&gt;( 启用 journaling 后，会将数据库相关操作等以日志的形式保存下来，会占用较大的硬盘空间和虚拟内存，64位mongodb，默认开启；32位版本默认关闭 )。&lt;/p&gt;

&lt;p&gt;通过 &lt;code&gt;mongo&lt;/code&gt; 连接 MongoDB 服务：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#mongo --help 可以查看mongo命令介绍
mongo test # 连接本地，27017端口的test数据库
mongo 192.168.20.1/test # 连接192.168.20.1主机，27017端口的数据库test
mongo 192.168.20.1:66666/test #连接192.168.20.1主角，66666端口的数据库test
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;三、常用命令&lt;/h3&gt;

&lt;p&gt;一般数据操作都有一些常用的客户端命令( 此处为：mongo shell )，MongoDB 的基本存储单元是集合 (collection)，想到于关系数据库mysql、oracle或sql server的表；&lt;/p&gt;

&lt;h4&gt;查询数据库&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; show dbs    # or show databases
admin   (empty)
local   0.078GB
test    0.078GB
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;切换数据库&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; use test
switched to db test
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;查看数据集合&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; show collections
system.indexes
users
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;集合操作&lt;/h4&gt;

&lt;p&gt;集合的基本操作命令如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.&amp;lt;collectionName&amp;gt;.&amp;lt;operate&amp;gt;(&amp;lt;argument&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用的集合操作有：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;查找记录 ( find )
查询记录数 ( count )
插入记录 ( insert )
删除记录 ( remove )
更新尽量 ( update )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这所有的集合操作接受的参数都是通过 JSON    的形式传递的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#查询所有记录
db.users.find()
# 查找 users 集合中，姓名为 小王的记录
db.users.find({name: '小王'})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为MongoDB是 NoSQL 数据库，因此不需要预定义表结构，直接通过 insert 插入数据即可。&lt;/p&gt;

&lt;h3&gt;四、分布式部署&lt;/h3&gt;

&lt;p&gt;本机部署3个shard、1个mongos和3个 configsvr；&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Shard1：27037&lt;/li&gt;
&lt;li&gt;Shard2：27038&lt;/li&gt;
&lt;li&gt;Shard3：27039&lt;/li&gt;
&lt;li&gt;Mongos：27017&lt;/li&gt;
&lt;li&gt;Config1：27027&lt;/li&gt;
&lt;li&gt;Config2：27028&lt;/li&gt;
&lt;li&gt;COnfig3：27029&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;在&lt;code&gt;/data/mongodb&lt;/code&gt;目录下创建文件夹&lt;code&gt;shard0001&lt;/code&gt;，&lt;code&gt;shard0002&lt;/code&gt;，&lt;code&gt;shard0003&lt;/code&gt;，&lt;code&gt;config0001&lt;/code&gt;，&lt;code&gt;config0002``config0003&lt;/code&gt;和&lt;code&gt;logs&lt;/code&gt;，分别用以保持分片数据、配置服务器数据和日志文件&lt;/p&gt;

&lt;h4&gt;启动配置服务器&lt;/h4&gt;

&lt;p&gt;首先启动3个配置服务器，测试环境使用一个配置服务器也可以，但是生产环境必须是3个，MongoDB最多支持3个配置服务器；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongod --configsvr --port 27027 --dbpath /data/mongodb/config0001 --logpath /data/mongodb/logs/config0001.log --fork
mongod --configsvr --port 27028 --dbpath /data/mongodb/config0001 --logpath /data/mongodb/logs/config0001.log --fork
mongod --configsvr --port 27029 --dbpath /data/mongodb/config0001 --logpath /data/mongodb/logs/config0001.log --fork
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行上诉命令将启动3个配置服务器，其中的参数介绍：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--configsvr&lt;/code&gt;，指定启动的是分配操作的配置服务器，该参数仅仅指定了默认的端口号( 27019 )和默认数据存放位置( /data/configdb )，并没有其它的任何用途，可以显示指定以覆盖默认设置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--port [端口号]&lt;/code&gt;，指定该配置服务器监听的端口号，如果设置了&lt;code&gt;--configsvr&lt;/code&gt;参数则默认为&lt;code&gt;27019&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--dbpath [数据存放路径]&lt;/code&gt;，指定配置服务器存放文件目录，如果设置了&lt;code&gt;--configsvr&lt;/code&gt;参数则默认为&lt;code&gt;/data/configdb&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--logpath [日志存放路径]&lt;/code&gt;，指定配置服务器的日志存放地；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--fork&lt;/code&gt;，指定该配置服务器位后台驻留程序；&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;启动路由服务器&lt;/h4&gt;

&lt;p&gt;路由服务器可以根据需求启动一个或多个，启动个数没有限制，作为MongoDB集群的访问点，提供与未分配中&lt;code&gt;mongod&lt;/code&gt;类似的功能，是MongoDB集群对外的“接口”；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongos --port 27017 --configdb localhost:27027,localhost:27028,localhost:27029 logpath /data/mongodb/logs/mongos.log --fork
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命令、参数介绍：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mongos&lt;/code&gt;，此处启动的命令是&lt;strong&gt;&lt;em&gt;mongos&lt;/em&gt;&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--configdb&lt;/code&gt;，指定配置服务器的主机/IP地址 + 端口号，只能是3个或1个，多个之间通过 &lt;strong&gt;&lt;em&gt;&lt;code&gt;,&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt;分割；&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;启动分片&lt;/h4&gt;

&lt;p&gt;分片实例其实就是通过命令&lt;code&gt;mongod&lt;/code&gt;启动的 MongoDB 实例；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongod --port 27037 --dbpath /data/mongodb/shard0001 --logpath /data/mongodb/logs/shard0001.log --fork
mongod --port 27038 --dbpath /data/mongodb/shard0002 --logpath /data/mongodb/logs/shard0002.log --fork
mongod --port 27039 --dbpath /data/mongodb/shard0003 --logpath /data/mongodb/logs/shard0003.log --fork
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此所有分布式启动的后台程序都已启动完毕，后面就是分片操作了。&lt;/p&gt;

&lt;h4&gt;Mongo Shell 分片&lt;/h4&gt;

&lt;p&gt;在按照上诉顺序启动完所有MongoDB 实例后，打开一个命令行参数，想前面说的那样，通过&lt;code&gt;mongo&lt;/code&gt;命令连接路由服务器；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongo localhost:27017/admin
# or
$ mongo admin
MongoDB shell version: 2.6.7
connecting to: admin
mongos&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加分片，MongoDB 会将启动的分片的信息保持到配置服务器上；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongos&amp;gt; sh.addShard('localhost:27037')
{ &quot;shardAdded&quot; : &quot;shard0000&quot;, &quot;ok&quot; : 1 }
mongos&amp;gt; sh.addShard('localhost:27038')
{ &quot;shardAdded&quot; : &quot;shard0001&quot;, &quot;ok&quot; : 1 }
mongos&amp;gt; sh.addShard('localhost:27039')
{ &quot;shardAdded&quot; : &quot;shard0002&quot;, &quot;ok&quot; : 1 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过&lt;code&gt;sh.status()&lt;/code&gt; 查看分片结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongos&amp;gt; sh.status()
--- Sharding Status --- 
  sharding version: {
    &quot;_id&quot; : 1,
    &quot;version&quot; : 4,
    &quot;minCompatibleVersion&quot; : 4,
    &quot;currentVersion&quot; : 5,
    &quot;clusterId&quot; : ObjectId(&quot;55471025f722cd42a930ecee&quot;)
}
  shards:
    {  &quot;_id&quot; : &quot;shard0000&quot;,  &quot;host&quot; : &quot;localhost:27037&quot; }
    {  &quot;_id&quot; : &quot;shard0001&quot;,  &quot;host&quot; : &quot;localhost:27038&quot; }
    {  &quot;_id&quot; : &quot;shard0002&quot;,  &quot;host&quot; : &quot;localhost:27039&quot; }
  databases:
    {  &quot;_id&quot; : &quot;admin&quot;,  &quot;partitioned&quot; : false,  &quot;primary&quot; : &quot;config&quot; }
    {  &quot;_id&quot; : &quot;test&quot;,  &quot;partitioned&quot; : true,  &quot;primary&quot; : &quot;shard0000&quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动数据库分片；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 格式 : sh.enableSharding(&amp;lt;databaseName&amp;gt;)
mongos&amp;gt; sh.enableSharding('test')
{ &quot;ok&quot; : 1 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当启动数据库&lt;strong&gt;&lt;em&gt; test &lt;/em&gt;&lt;/strong&gt;的分片过后，再通过&lt;code&gt;sh.status()&lt;/code&gt;命令查看，可发现相应的改变：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ... 前面相同
  databases:
    {  &quot;_id&quot; : &quot;admin&quot;,  &quot;partitioned&quot; : false,  &quot;primary&quot; : &quot;config&quot; }
    {  &quot;_id&quot; : &quot;test&quot;,  &quot;partitioned&quot; : true,  &quot;primary&quot; : &quot;shard0000&quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现在&lt;strong&gt;&lt;em&gt;databases&lt;/em&gt;&lt;/strong&gt;一项中，对应的多了一向分片的&lt;strong&gt;&lt;em&gt; test &lt;/em&gt;&lt;/strong&gt;数据库，其中：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_id&lt;/code&gt;，表示分片的数据库名，此处为&lt;strong&gt;&lt;em&gt; test &lt;/em&gt;&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;partitioned&lt;/code&gt;，表示是否启动分片，为 &lt;strong&gt;&lt;em&gt; true &lt;/em&gt;&lt;/strong&gt;表示启用分片；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;primary&lt;/code&gt;，表示数据库存放的“主片”，一旦主片存放满了，或达到了分片设置的阈值，才会将数据存放到其它片，否则将一直存放于该主片上。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;至此 MongoDB 的分布式部署完成。&lt;/p&gt;

&lt;h3&gt;五、集合分片&lt;/h3&gt;

&lt;p&gt;在集合分片之前，说明单片( 不分片 )的局限性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;单台主机的硬盘资源限制，一台主机的硬盘空间是一定的，当存放数据量达到硬盘的容量极限后，就只能为主机增加硬盘空间；&lt;/li&gt;
&lt;li&gt;入库速度的限制，如果某个功能实现每分每秒有大量的数据插入 (如：日志收集、网页抓取等)，单台主机入库的速度存在则极限( 后面会介绍 )，一旦入库请求操作此极限，入库速度会急剧下降；&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;由此，分片的好处就不言而喻了，它可以进行水平扩展，一旦现行的设备无法满足需求之后，只需要添加分片即可，添加之后 MongoDB 会根据设置&lt;strong&gt;&lt;em&gt;自动平衡&lt;/em&gt;&lt;/strong&gt;数据( 将数据移动到新插入的分片中 )；&lt;/p&gt;

&lt;p&gt;还有就是如果集合分片之后，入库将会是分布式方式入库，&lt;strong&gt;&lt;em&gt;mongos &lt;/em&gt;&lt;/strong&gt;会将所有的入库请求，根据设置分配到各个分片上，降低耽搁分片入库的极限，使得一些对入库要求很高的的程序能稳定运行；&lt;/p&gt;

&lt;p&gt;有得必有失，分片增加的入库速度，相应的查询更新速度就有所降低，如果不合理的查询( 没有提供分配字段 )，将导致遍历整个数据集合，这里的不合理查询一般都是查询条件中不包含分片的字段，MongoDB 则无法定位查询在哪个分配上进行，进而导致遍历整个集合。&lt;/p&gt;

&lt;h4&gt;Range 分片&lt;/h4&gt;

&lt;p&gt;根据给定的列( 如：age )，按分片数的范围分片，如此处分为三片，则分配范围：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;minKey ~ 30         30 ~ 60         60 ~ maxKey 
shard0001         shard0002        shard0003
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;年龄在&lt;code&gt;minKey ~ 30&lt;/code&gt;之间的信息，将会保存在分片&lt;strong&gt;&lt;em&gt;shard0001&lt;/em&gt;&lt;/strong&gt;上，&lt;code&gt;30 ~ 60&lt;/code&gt;的则会保持在&lt;strong&gt;&lt;em&gt;shard0002&lt;/em&gt;&lt;/strong&gt;上，依次类推。&lt;/p&gt;

&lt;p&gt;分片方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# sh.shardCollection('&amp;lt;database&amp;gt;.&amp;lt;collection&amp;gt;', {'colName' : 1/-1})
sh.shardCollection('test.users', {'age': 1})
{ &quot;collectionsharded&quot; : &quot;test.users&quot;, &quot;ok&quot; : 1 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以通过&lt;code&gt;db.users.stats()&lt;/code&gt;来查看分片过后集合的状态信息，因为是按范围分布的，相同范围之内的存放于同一个分片中，要提升入库速度的话，必须选择合适的分片依据，防止同一时间段内入口同一范围的数据；&lt;/p&gt;

&lt;p&gt;可以通过设置多个分片健来解决，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sh.shardCollections('test.users', {'age': 1, 'name': 1})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以合理选择分片Key很重要&lt;/p&gt;

&lt;h4&gt;Hash 分片&lt;/h4&gt;

&lt;p&gt;顾名思义，Hash 分片就是将数据根据分配字段 Hash 分布到各个片中，好处是即使同一时刻分配字段连续递增，入库结果基本也是均衡分配的；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                 Hash Function
     _________________|_____________________
    |                 |                     |
shard0001         shard0002             shard0003
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;入库记录会经过&lt;strong&gt;&lt;em&gt;mongos&lt;/em&gt;&lt;/strong&gt;的Hash 函数的处理，将不同的记录分发到各个分片中入库。&lt;/p&gt;

&lt;p&gt;分片方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# sh.shardCollection('&amp;lt;database&amp;gt;.&amp;lt;collection&amp;gt;', {'age': 'hashed'})
mongos&amp;gt; sh.shardCollection('test.info', {'phone': 'hashed'})
{ &quot;collectionsharded&quot; : &quot;test.info&quot;, &quot;ok&quot; : 1 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分片信息&lt;code&gt;db.info.stats()&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongos&amp;gt; db.info.stats()
{
    &quot;sharded&quot; : true,
    &quot;systemFlags&quot; : 1,
    &quot;userFlags&quot; : 1,
    &quot;ns&quot; : &quot;test.info&quot;,
    &quot;count&quot; : 0,
    &quot;numExtents&quot; : 3,
    &quot;size&quot; : 0,
    &quot;storageSize&quot; : 24576,
    &quot;totalIndexSize&quot; : 49056,
    &quot;indexSizes&quot; : {
        &quot;_id_&quot; : 24528,
        &quot;phone_hashed&quot; : 24528
    },
    &quot;avgObjSize&quot; : 0,
    &quot;nindexes&quot; : 2,
    &quot;nchunks&quot; : 6,
    &quot;shards&quot; : {
        &quot;shard0000&quot; : {
            &quot;ns&quot; : &quot;test.info&quot;,
            &quot;count&quot; : 0,
            &quot;size&quot; : 0,
            &quot;storageSize&quot; : 8192,
            &quot;numExtents&quot; : 1,
            &quot;nindexes&quot; : 2,
            &quot;lastExtentSize&quot; : 8192,
            &quot;paddingFactor&quot; : 1,
            &quot;systemFlags&quot; : 1,
            &quot;userFlags&quot; : 1,
            &quot;totalIndexSize&quot; : 16352,
            &quot;indexSizes&quot; : {
                &quot;_id_&quot; : 8176,
                &quot;phone_hashed&quot; : 8176
            },
            &quot;ok&quot; : 1
        },
        &quot;shard0001&quot; : {
            ...
        },
        &quot;shard0002&quot; : {
            ...
        }
    },
    &quot;ok&quot; : 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在再去插入一些记录看下，所有的记录分别被插入到了不同的分当中去了。&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;分片部分完成，后续还有 MongoDB 分片等的，根据官方文档的详细介绍。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Solr 应用（二）－初次体验</title>
   <link href="http://www.blogways.net/blog/2015/04/30/solr-usage-2.html"/>
   <updated>2015-04-30T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/04/30/solr-usage-2</id>
   <content type="html">&lt;h2&gt;Solr 初次体验&lt;/h2&gt;

&lt;h3&gt;创建搜索实例&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4&gt;命令创建实例&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ bin/solr create -c test
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;查看创建可选参数&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ bin/solr create -help
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;Web 控制台创建&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Core Admin / Add Core
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/images/solr-2-1.png&quot; alt=&quot;Web 控制台创建索引&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里我们创建一个 test 测试实例&lt;/p&gt;

&lt;hr /&gt;

&lt;h3&gt;导入测试文档&lt;/h3&gt;

&lt;p&gt;导入一些 solr 自带的 json 测试文档数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ bin/post -c test example/exampledocs/*.json
SimplePostTool version 5.0.0
Posting files to [base] url http://localhost:8983/solr/gettingstarted/update...
Entering auto mode. File endings considered are
xml,json,csv,pdf,doc,docx,ppt,pptx,xls,xlsx,odt,odp,ods,ott,otp,ots,rtf,htm,html,txt,log
POSTing file books.json (application/json) to [base]
1 files indexed.
COMMITting Solr index changes to http://localhost:8983/solr/gettingstarted/update...
Time spent: 0:00:00.450
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Web 控制台搜索体验&lt;/h3&gt;

&lt;p&gt;例如：查询作者为 &lt;code&gt;Rick Riordan&lt;/code&gt; 所有的书&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/solr-2-2.png&quot; alt=&quot;Web 控制台 query 测试&quot; /&gt;&lt;/p&gt;

&lt;p&gt;http://localhost:8983/solr/test/select?q=author%3A%22Rick+Riordan%22&amp;amp;wt=json&amp;amp;indent=true&lt;/p&gt;

&lt;p&gt;返回结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &quot;responseHeader&quot;:{
    &quot;status&quot;:0,
    &quot;QTime&quot;:1,
    &quot;params&quot;:{
      &quot;indent&quot;:&quot;true&quot;,
      &quot;q&quot;:&quot;author:\&quot;Rick Riordan\&quot;&quot;,
      &quot;wt&quot;:&quot;json&quot;}},
  &quot;response&quot;:{&quot;numFound&quot;:2,&quot;start&quot;:0,&quot;docs&quot;:[
      {
        &quot;id&quot;:&quot;978-0641723445&quot;,
        &quot;cat&quot;:[&quot;book&quot;,
          &quot;hardcover&quot;],
        &quot;name&quot;:[&quot;The Lightning Thief&quot;],
        &quot;author&quot;:[&quot;Rick Riordan&quot;],
        &quot;series_t&quot;:[&quot;Percy Jackson and the Olympians&quot;],
        &quot;sequence_i&quot;:1,
        &quot;genre_s&quot;:&quot;fantasy&quot;,
        &quot;inStock&quot;:[true],
        &quot;price&quot;:[12.5],
        &quot;pages_i&quot;:384,
        &quot;_version_&quot;:1497865383114178560},
      {
        &quot;id&quot;:&quot;978-1423103349&quot;,
        &quot;cat&quot;:[&quot;book&quot;,
          &quot;paperback&quot;],
        &quot;name&quot;:[&quot;The Sea of Monsters&quot;],
        &quot;author&quot;:[&quot;Rick Riordan&quot;],
        &quot;series_t&quot;:[&quot;Percy Jackson and the Olympians&quot;],
        &quot;sequence_i&quot;:2,
        &quot;genre_s&quot;:&quot;fantasy&quot;,
        &quot;inStock&quot;:[true],
        &quot;price&quot;:[6.49],
        &quot;pages_i&quot;:304,
        &quot;_version_&quot;:1497865383259930624}]
  }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，这个只是简单的查询示例，可以只输入一部分查询，或者按价钱区间来查询（例：查询 10-20 这个价钱区间的书就可以写成 &lt;code&gt;price:[ 10 TO 20 ]&lt;/code&gt;），也可以组合条件查询，当然也可以限制查询结果只返回需要的字段，或者高亮显示匹配部分等等。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Solr 应用（一）－初次体验</title>
   <link href="http://www.blogways.net/blog/2015/04/29/solr-usage-1.html"/>
   <updated>2015-04-29T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/04/29/solr-usage-1</id>
   <content type="html">&lt;h2&gt;Solr 的简介以及安装&lt;/h2&gt;

&lt;h3&gt;Solr 简介&lt;/h3&gt;

&lt;p&gt;Solr 是一个高性能，采用 java5 开发，基于 Lucene 的全文搜索服务器。提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，拥有强大的全文检索功能，高亮显示检索结果，动态集群，数据库接口和电子文档（Word ，PDF 等）的处理。而且Solr 具有高度的可扩展，支持分布搜索和索引的复制。是一款非常优秀的全文搜索引擎。&lt;/p&gt;

&lt;h3&gt;安装&lt;/h3&gt;

&lt;h4&gt;环境参数&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;Jdk1.7+（下载地址 http://www.oracle.com/technetwork/java/javase/downloads/index.html）
Tomcat7（Solr5.0 自带 Jetty 服务器，可以直接启动）
Solr5.0（下载地址 http://lucene.apache.org/solr/）
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;安装步骤&lt;/h4&gt;

&lt;hr /&gt;

&lt;h5&gt;Linux&lt;/h5&gt;

&lt;p&gt;这里直接使用自带的 Jetty 服务器测试&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;直接解压 Solr&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ cd ~/
  $ tar zxf solr-5.0.0.tgz
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动 Solr&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ bin/solr start
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;脚本帮助&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ bin/solr -help
  $ bin/solr start -help
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;前台启动 Solr&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ bin/solr start -f
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;指定端口启动&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ bin/solr start -p 8984
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;停止 Solr&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ bin/solr stop -p 8983
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动一个特殊示例配置的 Solr&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ bin/solr -e techproducts
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;检查 Solr 运行状态&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ bin/solr status
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;至此，Solr 就算成功启动了，可以去 web 控制台验证下 &lt;code&gt;http://localhost:8983/solr/&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h5&gt;Windows&lt;/h5&gt;

&lt;p&gt;这里我们用自己的服务器 Tomcat7 来部署运行&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;解压 Solr &amp;amp;&amp;amp; 部署&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;在目录 &lt;code&gt;solr-5.0.0/server/webapps&lt;/code&gt; 目录下面有个 solr.war 包，把这个拷贝到 tomcat webapp 目录下，启动 tomcat，自动解压 solr 工程&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;修改 web.xml&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;env-entry&amp;gt;
     &amp;lt;env-entry-name&amp;gt;solr/home&amp;lt;/env-entry-name&amp;gt;
     &amp;lt;env-entry-value&amp;gt;E:\tools\solr-5.0.0\server\solr&amp;lt;/env-entry-value&amp;gt;
     &amp;lt;env-entry-type&amp;gt;java.lang.String&amp;lt;/env-entry-type&amp;gt;
  &amp;lt;/env-entry&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  将 &lt;code&gt;env-entry-value&lt;/code&gt; 节点值改成 solr 的目录&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;添加 jar 包&lt;/p&gt;

&lt;p&gt;  将 &lt;code&gt;solr-5.0.0\server\lib\ext&lt;/code&gt; 目录下所有的 jar 包拷贝到 &lt;code&gt;apache-tomcat-7.0.42\webapps\solr\WEB-INF\lib&lt;/code&gt; 下面&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;添加 log4j 配置&lt;/p&gt;

&lt;p&gt;  将 &lt;code&gt;solr-5.0.0\server\resources\log4j.properties&lt;/code&gt; 拷贝到 &lt;code&gt;apache-tomcat-7.0.42\webapps\solr\WEB-INF\classes&lt;/code&gt; 目录下（classes 目录需要手动创建）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;启动 tomcat，打开控制台可以看到跟上面效果一样的&lt;/p&gt;

&lt;hr /&gt;

&lt;h4&gt;Web 控制台&lt;/h4&gt;

&lt;p&gt;搞了半天，看下控制台长什么样子~&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/solr-1-1.png&quot; alt=&quot;Solr5.0 Web 控制台&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>使用Redis实现TOP500排行功能( 列表和有序集合 )</title>
   <link href="http://www.blogways.net/blog/2015/04/29/rank-by-redis.html"/>
   <updated>2015-04-29T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/04/29/rank-by-redis</id>
   <content type="html">&lt;h2&gt;一、背景介绍&lt;/h2&gt;

&lt;p&gt;通过 node.js 将系统产生的日志入库到 mongodb，并统计最大耗时的TOP500，因为 node.js 操作 mongodb 都是通过异步调用的回调函数来完成的，所以在获取表中记录数的时候操作起来特别的烦琐，还有一个原因就是启动多个 node.js 实例来入库数据的时候，并发请求太多，可能多个 node.js 删除的时同一条记录，导致在实际测试过程中，统计表中的记录条数不是 500，而可能时几十、几百万条数据。&lt;/p&gt;

&lt;h2&gt;二、数据结构&lt;/h2&gt;

&lt;p&gt;通过采集系统的日志文件发送到 node.js，经过分析过后的数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var obj = {
    &quot;MAX&quot; : 123214,
    &quot;MIN&quot; : 234,
    &quot;AVERAGE&quot; : 3245,
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据 MAX 或 MIN 排序；&lt;/p&gt;

&lt;h2&gt;三、实现&lt;/h2&gt;

&lt;p&gt;TOP500 统计有两个阶段：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;表中记录数不满 500 条时，在此阶段任何新插入的数据都是TOP500，直接插入数据即可&lt;/li&gt;
&lt;li&gt;表中数据大于 500 条时，在此阶段若插入一条数据，就需要删除一条数据；&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;上述第二阶段时，一般数据库的操作方式就是找到并删除 &lt;code&gt;MAX 最小&lt;/code&gt;( &lt;strong&gt;当按MAX排行时，只要比表中最小的大，就是TOP500&lt;/strong&gt; )或&lt;code&gt;MIN 最大&lt;/code&gt;( &lt;strong&gt;当按MIN排行时，只要比表中最大的大，就是TOP500&lt;/strong&gt; )的一条记录，然后将新纪录插入数据库即可。&lt;/p&gt;

&lt;h3&gt;有序集合( Sorted sets )&lt;/h3&gt;

&lt;p&gt;在 node.js 中连接 redis 的所有操作都是异步回调的，而在判断表中记录数的时候需要等待结果，然后才能进行后续的操作，此处需要同步等待，因而使用 async 来实现：&lt;/p&gt;

&lt;p&gt;因为有序集合会将插入的数据的值自动排序，所有表中第一条、或最后一条记录即是最小、最大值，操作不复杂，使用起来也很方便；操作有两种实现方式：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;手动判断数据个数，在表中记录不满500条时插入数据，超过500条之后根据排行榜功能返回表中第一条或最后一条记录，与当前值比较判断是否插入并删除取出的数据；&lt;/li&gt;
&lt;li&gt;不管表中有多少条数据，先讲记录插入到表中，然后删除500条之后的记录、或倒数500条之前的记录；&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;实现方式一&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var env = process.env.NODE_ENV || 'development',
    config = require('../../config/config')[env];
    logger = require('../../log').logger,
    redis = require('redis'),
    client = redis.createClient(config.redis.port,config.redis.host),
    async = require('async');

...  省略中间代码  ...

var value = obj[field];
async.auto({
    step1: function (callback) {
        client.zcard(['test'], callback);
    },
    step2: ['step1', function (callback, result) {
        if (result.step1 &amp;lt; 500) {
            client.zadd(['test', value, JSON.stringify(obj)], function (err, rest){
                if (err) {
                    logger.error(err);
                } else {
                    callback('redis insert successfully!')
                }
            })
        } else {
            if (type == 'max') {
                client.zrange(['test', 0, 0, 'withscores'], callback)
            } else {
                client.zrange(['test', -1, -1, 'withscores'], callback)
            }
        }
    }],
    step3: ['step2', function (callback, result) {
        if ( (type == 'max' &amp;amp;&amp;amp; value &amp;gt; result.step2[1]) || 
                (type == 'min' &amp;amp;&amp;amp; obj.MIN &amp;lt; result.step2[1]) ) {
            client.rem(['test', result.step2[0]], redis.print);
            client.zadd(['test', value, JSON.stringify(obj)], redis.print);
        }
    }]
}, function(err, results) {
    client.quit();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方法很符合传统的思路，比较容易理解，但是很明显操作比较多，还使用了一些插件、判断等，效率应该不是很高。&lt;/p&gt;

&lt;h4&gt;实现方式二&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var env = process.env.NODE_ENV || 'development',
    config = require('../../config/config')[env];
    logger = require('../../log').logger,
    redis = require('redis'),
    client = redis.createClient(config.redis.port,config.redis.host);

...  省略中间代码  ...

var value = obj[field];
client.zadd(['test', value, JSON.stringify(obj)], redis.print);
if (type == 'MAX') {
    client.zremrangebyrank(['test', 0, -500], redis.print);
} else {
    client.zremrangebyrank(['test', 500, -1], redis.print);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二种实现方式代码量很少，所有的实现都是调用的 redis 提供的接口方法来实现，因而运行效率比方式一要高很多，比较推荐此种方式。&lt;/p&gt;

&lt;p&gt;因为按 MAX 字段统计排行榜时，要保留MAX最大的TOP500，而表按照数值升序排序的，所以需要保留表中后500跳记录( 删除表中后500条之前的数据，即第一条记录到倒数第500条之间的数据：&lt;code&gt;zremrangebyrank(['test', 0, -500], redis.print)&lt;/code&gt; );&lt;/p&gt;

&lt;p&gt;同理，按照 MIN 字段统计排行榜时，只需要删除500条之后的数据( 升序排序，则第一条到第500条即为TOP500，&lt;code&gt;zremrangebyrank(['test', 500, -1], redis.print)&lt;/code&gt; )。&lt;/p&gt;

&lt;h3&gt;使用到的方法介绍&lt;/h3&gt;

&lt;p&gt;redis 对 node.js 的所有接口方法都有两个参数，第一个为一个数组( &lt;code&gt;[]&lt;/code&gt; )，数组中的参数即为在&lt;code&gt;redis-cli&lt;/code&gt;客户端执行命令时的参数，第二个参数为一个回调函数，通常为 &lt;code&gt;function (err, result){ ... }&lt;/code&gt;，方法执行的结果保存在 result 中。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;client.zcard([ tabname ], callback)&lt;/code&gt;：同客户端命令 &lt;code&gt;ZCARD&lt;/code&gt;，得到的有序集合成员的数量；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;client.zadd([ tabname, value, key ], callback)&lt;/code&gt;：同客户端命令 &lt;code&gt;ZADD&lt;/code&gt;，添加一个或多个成员到有序集合，或者如果它已经存在更新其数据值；添加多个记录：&lt;code&gt;client.zadd(['test', 1, 'a1', 2, 'a2'.....], callback)&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;client.zrange([ tabname, start stop, 'withscores' ], callback)&lt;/code&gt;：同客户端命令 &lt;code&gt;ZRANGE&lt;/code&gt;，由索引返回一个成员范围的有序集合，如果有&lt;code&gt;withscores&lt;/code&gt;参数，则对于 key 的值也会返回，如：&lt;code&gt;[ 'a1', '1' ]&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;client.rem([ tabname, key], callback)&lt;/code&gt;：同客户端命令&lt;code&gt;ZREM&lt;/code&gt;，从有序集合中删除一个或多个成员；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;client.zremrangebyrank([ tabname, start, stop ], callback)&lt;/code&gt;，同客户端命令 &lt;code&gt;ZREMRANGEBYRANK&lt;/code&gt;，在给定的索引之内删除所有成员的有序集合，下标从 0 开始，-1 表示最后一条记录，-500 表示倒数第500条记录。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;列表&lt;/h3&gt;

&lt;p&gt;因为列表只有一个key，不存在 value的说法，因而通过 Lists 来实现的时候，需要将比较字段通过一些处理，并放到转换为字符串的前面，如在按照如下对象的 MAX 字段统计时：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var obj = {
    &quot;MAX&quot; : 123214,
    &quot;MIN&quot; : 234,
    &quot;AVERAGE&quot; : 3245,
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;转化成的字符串需为：&lt;code&gt;&quot;{\&quot;KEY\&quot;:\&quot;00000000002.342424\&quot;,\&quot;MAX\&quot;:2.342424,\&quot;MIN\&quot;:0.023212,\&quot;AVERAGE\&quot;:0.065464, ....}&quot;&lt;/code&gt;，因为没有 value的说法，所以只能按照字符串的ASCII的方式来比较，所以比较字段需要将位数统一。&lt;/p&gt;

&lt;p&gt;redis 的 &lt;code&gt;sort&lt;/code&gt;命令能按照指定的顺序排序( desc，降序；asc，升序 )，同时可以截取排序结果并保存为一个单独的表( 或覆盖原来的表 )，如此则可以使用有序集合实现方式二的思想来实现：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;按 MAX 统计排行榜时，按降序排序，则前500条记录即为TOP500；&lt;/li&gt;
&lt;li&gt;按 MIN 统计排行榜时，按升序排序，则钱500条记录即为TOP500；&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;代码实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var env = process.env.NODE_ENV || 'development',
    config = require('../../config/config')[env];
    logger = require('../../log').logger,
    redis = require('redis'),
    client = redis.createClient(config.redis.port,config.redis.host);

...  省略中间代码  ...

var value = obj[field],
    adesc = type == &quot;max&quot; ? &quot;desc&quot; : &quot;asc&quot;,
    tmpstr = JSON.stringify(obj),
    tmpval = Array((11-(''+Math.floor(value)).length+1)).join(0)+value, //整数部分统一到 11 位
    multi = client.multi();

var str = tmpstr.replace('{','{&quot;KEY&quot;:&quot;'+tmpval+'&quot;,'); // 将 KEY 部分添加到 字符串中
multi.rpush([tabname, str], redis.print);
multi.sort([tabname, 'limit', 0, count, adesc, 'alpha', 'store', tabname], redis.print);
multi.exec(function(err,rest){
    if(err){
        logger.error(err);
    }else{
        logger.debug(rest);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码也很简洁，不过实际效率情况的高低就不得而知了，其中需要注意的就是要将统计字段取出做等长处理( &lt;code&gt;MAX: 1.23&lt;/code&gt; 和 &lt;code&gt;MAX: 11.3&lt;/code&gt;，前者比后者小，但是转换为字符串之后，前者比后者大，将它们的整数位等长到11位或更多后，可以解决这个问题)；&lt;/p&gt;

&lt;p&gt;这种实现方式的思路：将新的记录插入到表中，然后通过&lt;code&gt;sort&lt;/code&gt;命令排序，并截取前500条记录覆盖原来的表，虽然每次都有排序，但是实际情况没有想象中那么糟糕，因为每次插入数据钱的数据都是排序好了的，插入一条数据的排序花销可能不是很大( 具体要看redis的排序实现方式：如果是通过快速排序来实现的话，效率会很低；如果是通过冒泡方式来实现的话效率会高不少 )。&lt;/p&gt;

&lt;p&gt;这种方法只是一种探究，基本不会使用到生产环境中，推荐使用有序集合的实现方式二。&lt;/p&gt;

&lt;p&gt;使用的方法说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;multi = client.multi();&lt;/code&gt;，顾名思义，相当于一个client的命令序列，先将要执行的命令放入其中，带启动时顺序执行；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rpush([tabname, key], callback);&lt;/code&gt;，同客户端命令 &lt;code&gt;RPUSH&lt;/code&gt;，添加一个或多个值到列表右端( 尾部 )；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sort([tabname, 'limit', start, stop, 'asc'/'desc', 'alpha', 'store', tabname1], callback)&lt;/code&gt;：同客户端命令 &lt;code&gt;sort&lt;/code&gt;，将表 &lt;code&gt;tabname&lt;/code&gt;的key 按字母( 默认会将key 转换为 double类型再做排序 )的升序或降序排列，并截取下标&lt;code&gt;start&lt;/code&gt; 到 &lt;code&gt;stop&lt;/code&gt;之间的元素，保存到 &lt;code&gt;tabname1&lt;/code&gt;表中；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;multi.exec(callback)&lt;/code&gt;，按先后顺序运行&lt;code&gt;multi&lt;/code&gt;中的命令；&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;大概的通过 Redis 实现排行榜的就是这样，如果有什么好的想法也可以跟我联系，一起交流进步！&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Apache Flume-NG 介绍[5] 之 自定义组件</title>
   <link href="http://www.blogways.net/blog/2015/04/29/Apache-Flume-NG-Introduction-5.html"/>
   <updated>2015-04-29T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/04/29/Apache-Flume-NG-Introduction-5</id>
   <content type="html">&lt;h2&gt;一、Custom Source&lt;/h2&gt;

&lt;p&gt;实现 Source 接口即可定义Custom Sources，在启动Flume Agent的时候，用户自定义源的类及其依赖必须包括在agent 的 &lt;code&gt;classpath&lt;/code&gt;中。Custom Source 的类型是它的全限定性类名。&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;FQCN ( 全限定性类名，如：org.example.MyCustomSource )&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;selector.type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;replicating&lt;/code&gt; 或 &lt;code&gt;multiplexing&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;selector.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;依赖selector.type的值&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;interceptors&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Space-separated list of interceptors&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;interceptors.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;实例：&lt;code&gt;Agent a1&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a1.sources = r1
a1.channels = c1
a1.sources.r1.type = org.example.MyCustomSource
a1.sources.r1.channels = c1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;自定义 Source&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建工程：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; mvn archetype:create -DgroupId=org.apache.flume -DartifactId=flume-ng-db-source -DpackageName=com.ai.flume -Dversion=1.0
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编辑 &lt;code&gt;pom.xml&lt;/code&gt; 添加依赖：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;lt;/dependencies&amp;gt;
     &amp;lt;dependency&amp;gt;
         &amp;lt;groupId&amp;gt;org.apache.flume&amp;lt;/groupId&amp;gt;
         &amp;lt;artifactId&amp;gt;flume-ng-core&amp;lt;/artifactId&amp;gt;
         &amp;lt;version&amp;gt;1.5.2&amp;lt;/version&amp;gt;
     &amp;lt;/dependency&amp;gt;
     &amp;lt;dependency&amp;gt;
         &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
         &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
         &amp;lt;version&amp;gt;5.1.35&amp;lt;/version&amp;gt;
     &amp;lt;/dependency&amp;gt;
     &amp;lt;dependency&amp;gt;
         &amp;lt;groupId&amp;gt;com.oracle&amp;lt;/groupId&amp;gt;
         &amp;lt;artifactId&amp;gt;ojdbc14&amp;lt;/artifactId&amp;gt;
         &amp;lt;version&amp;gt;10.2.0.1.0&amp;lt;/version&amp;gt;
     &amp;lt;/dependency&amp;gt;
 &amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建一个类，继承 &lt;code&gt;AbstractSource&lt;/code&gt;，并实现接口 &lt;code&gt;Configurable&lt;/code&gt;和&lt;code&gt;PollableSource&lt;/code&gt;，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; package com.ai.flume.source;

 public class FlumeNGDBSource extends AbstractSource implements Configurable, PollableSource {
     private static final Logger logger = LoggerFactory.getLogger(FlumeNGDBSource.class);

     public void configure(Context context) {
         // 处理配置文件( 如：conf/example.conf )中的属性
     }

     @Override
     public synchronized void start() {
         // Source 启动时的初始化、开启进程等
     }

     public Status process() throws EventDeliveryException {
         // Source 真正的工作进程
         // 获取data，封装到event中，发送到channel
     }

     @Override
     public synchronized void stop() {
         // Source 结束时的变量释放、进程结束等
     }
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置文件创建和使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; private String sqlType;
 private String sqlHost;
 private int sqlPort;
 private String Db;
 private String sqlUser;
 private String sqlPwd;
 private String sql;

 ...  省略中间代码  ...

 public void configure(Context context) {
     // 在此方法中，通过context.getString(&quot;property&quot;, defaultValue)
     // context.getInteger(&quot;property&quot;, defaultValue)来读取配置文件
     sqlType = context.getString(&quot;sql-type&quot;, &quot;oracle&quot;);
     sqlHost = context.getString(&quot;sql-host&quot;, &quot;localhost&quot;);
     sqlPort = context.getInteger(&quot;sql-port&quot;, 3306);
     sqlDb = context.getString(&quot;sql-db&quot;, &quot;test&quot;);
     sqlUser = context.getString(&quot;sql-user&quot;, null);
     sqlPwd = context.getString(&quot;sql-pwd&quot;, null);
     sql = context.getString(&quot;sql&quot;, &quot;select * from info;&quot;);
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 上述文件的配置文件可以如下设置，&lt;code&gt;mydb.conf&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; a1.sources = r1
 a1.channels = c1
 a1.sources.r1.type = com.ai.flume.FlumeNGDBSource
 a1.sources.r1.sql-type = mysql
 a1.sources.r1.sql-host = 127.0.0.1
 # 这里的SQL不需要加双引号或单引号
 a1.sources.r1.sql = select * from users;
 # 使用默认端口 3306，默认数据库 test，默认没有用户和密码
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据封装为 Event，并发送到 Channel：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; private ChannelProcessor channelProcessor = null;
 // 用于存放需要发送的队列
 // 从数据库中取出，然后放到队列中
 private LinkedBlockingQueue&amp;lt;String&amp;gt; queue = null;

 ...  省略中间代码  ...

 public Status process() throws EventDeliveryException {
     Status status = Status.READY;
     // 获取连接Channel的对象
     channelProcessor = getChannelProcessor();

     try {
         // 取出一条要发送的数据
         String line = queue.take();
         // 通过logger以INFO的级别输出到Source的日志文件中
         logger.info(line);
         // 调用EventBuilder.withBody(String body, Charset set)，
         // 将要发送的数据封装为一个 event
         Event e = EventBuilder.withBody(line, Charset.forName(&quot;UTF8&quot;));
         // 将封装后的 event发送到连接的 Channel
         channelProcessor.processEvent(e);
     } catch (Exception e) {
         // 出现错误，返回Status.BACKOFF，告诉Source 发送失败
         // 当自定义 Sink 的时候，这里需要注意，详见后面
         status = Status.BACKOFF;

         logger.error(&quot;flume-ng mysql source error!&quot;, e);
         throw new EventDeliveryException(e);
     }

     return status;
 }       
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 到这基本自定义 Source已经完成了，其它要做的就是通过代码实现数据的生成或抓取，然后放到上述的&lt;code&gt;queue&lt;/code&gt;当中。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过&lt;code&gt;Timer&lt;/code&gt;定时从数据库中取数据放到&lt;code&gt;queue&lt;/code&gt;中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; private Timer scannerTimer;

 ...  省略中间代码  ...

 @Override
 public synchronized void start() {
     super.start();
     queue = new LinkedBlockingQueue&amp;lt;String&amp;gt;();

     scannerTimer = new Timer(&quot;FlumeNG_Scanner_Timer_Thread&quot;, true);
     scannerTimer.scheduleAtFixedRate(new TimerTask() {

         @Override
         public void run() {
             // 调用操作数据库方法，执行sql，返回数据
             list = ibd.selectAll(sql);

             if (list.size() &amp;lt;= 0) {
                 try {
                     Thread.sleep(10);
                 } catch (InterruptedException e) {
                     logger.error(&quot;[ Error ]:&quot;, e);
                 }
             }
             String res = &quot;&quot;;
             for (int i = 0; i &amp;lt; list.size(); i++) {
                 if (&quot;&quot; == res) {
                     res += list.get(i);
                 } else {
                     res += &quot;&amp;amp;data=&quot; + list.get(i);                      }
             }
             // 将结果缓存到queue当中
             queue.offer(res);
         }
     }, 0, runSpeed); // runSpeed为配置文件当中的查询间隔
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;stop&lt;/code&gt;方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; @Override
 public synchronized void stop() {
     super.stop();
     // 关闭与Channel的连接
     channelProcessor.close();
     // 结束数据获取线程
     if (scannerTimer != null) {
         try {
             scannerTimer.cancel();
         } catch (Exception e) {

         } finally {
             scannerTimer = null;
         }
     }
     queue = null;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 至此，自定义Source已经完成。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成&lt;code&gt;jar&lt;/code&gt;包：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; mvn clean package
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 在上面命令运行成功后，复制 &lt;code&gt;target/flume-ng-db-source-1.0.jar&lt;/code&gt;到&lt;code&gt;$FLUME_HOME/lib&lt;/code&gt;目录即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; cp target/flume-ng-db-source-1.0.jar $FLUME_HOME/lib
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;二、Custom Sink&lt;/h2&gt;

&lt;p&gt;实现 Sink 接口即可定义Custom Sink，在启动Flume Agent的时候，用户自定义Sink的类及其依赖必须包括在agent 的 &lt;code&gt;classpath&lt;/code&gt;中。Custom Sink 的类型是它的全限定性类名。&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;FQCN ( 全限定性类名，如：org.example.MyCustomSink )&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;selector.type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;replicating&lt;/code&gt; 或 &lt;code&gt;multiplexing&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;selector.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;依赖selector.type的值&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;interceptors&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Space-separated list of interceptors&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;interceptors.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;实例：&lt;code&gt;Agent a1&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a1.sources = r1
a1.channels = c1
a1.sources.r1.type = org.example.MyCustomSink
a1.sources.r1.channels = c1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;自定义 Sink&lt;/h3&gt;

&lt;p&gt;此 Sink从 Channel 获取 events，然后通过HTTP POST发送到远程的主机端口上。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;同样的，通过maven创建工程：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; mvn archetype:create -DgroupId=org.apache.flume -DartifactId=flume-ng-http-source -DpackageName=com.ai.flume -Dversion=1.0
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编辑 &lt;code&gt;pom.xml&lt;/code&gt; 添加依赖：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;lt;/dependencies&amp;gt;
     &amp;lt;dependency&amp;gt;
         &amp;lt;groupId&amp;gt;org.apache.flume&amp;lt;/groupId&amp;gt;
         &amp;lt;artifactId&amp;gt;flume-ng-core&amp;lt;/artifactId&amp;gt;
         &amp;lt;version&amp;gt;1.5.2&amp;lt;/version&amp;gt;
     &amp;lt;/dependency&amp;gt;
 &amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建一个类，继承 &lt;code&gt;AbstractSource&lt;/code&gt;，并实现接口 &lt;code&gt;Configurable&lt;/code&gt;和&lt;code&gt;PollableSource&lt;/code&gt;，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; package com.ai.flume.source;

 public class FlumeNGHttpSink extends AbstractSink implements Configurable {
     private static final Logger logger = LoggerFactory.getLogger(FlumeNGHttpSink.class);

     public void configure(Context context) {
         // 处理配置文件( 如：conf/example.conf )中的属性
     }

     public Status process() throws EventDeliveryException {
         // Source 真正的工作进程
         // 获取data，封装到event中，发送到channel
     }

     public String post(String url, String param) {
         // http发送post请求
     }
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置文件创建和使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; private String url;
 private String host;
 private String type;

 ...  省略中间代码  ...

 public void configure(Context context) {
     // 在此方法中，通过context.getString(&quot;property&quot;, defaultValue)
     // context.getInteger(&quot;property&quot;, defaultValue)来读取配置文件
     url = context.getString(&quot;node-url&quot;, &quot;http://127.0.0.1:5000/receive&quot;);
     host = context.getString(&quot;node-host&quot;, &quot;127.0.0.1&quot;);
     type = context.getString(&quot;node-type&quot;, &quot;TuxState&quot;);
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 上述文件的配置文件可以如下设置，&lt;code&gt;mydb.conf&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; a1.sources = r1
 a1.channels = c1
 a1.sources.r1.type = com.ai.flume.FlumeNGHttpSink
 a1.sources.r1.node-url = http://localhost:3000/receive
 a1.sources.r1.node-host = 127.0.0.1
 a1.sources.r1.node-type = TuxState
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从 Channel 获取 Event，并取出其中包含的数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; public Status process() throws EventDeliveryException {
     // TODO(ai) Auto-generated method stub
     Status status = Status.READY;

     Channel channel = getChannel();
     Transaction txn = null;   

     try {
         txn = channel.getTransaction();
         txn.begin();    // 开始从Channel获取Event的事务处理

         Event e = channel.take();   // 从Channel取一个Event
         if (null != e) {
             String line = EventHelper.dumpEvent(e);
             logger.info(line);
             // 取出 Event 中包含的内容，然后转换为需要的类型，此处为String
             byte[] body = e.getBody(); 
             String data = new String(body);
             //logger.info(data);
             String str = &quot;localhost=&quot; + host + &quot;&amp;amp;type=&quot; + type + &quot;&amp;amp;data=&quot; + data;
             //将配置文件的信息和数据组合成post方法的param，调用编写的post方法发送到目的地
             logger.info(post(url, str));
         } else {
             status = Status.BACKOFF;
         }

         txn.commit();
     } catch (Exception e) {
         // 前面提及过，在处理这的时候需要注意
         // 若发送错误的原因是数据处理的问题，则可能会出现死循环
         // 出错，而不执行txn.commit()，则出错的Event并不会从 Channel中删除
         // 下一次获取的仍然是出错的 Event
         logger.error(&quot;can't process events, drop it!&quot;, e);
         if (txn != null) {
             txn.commit();   //出现BUG，丢弃当前Event，防止出现死循环
         }
         throw new EventDeliveryException(e);
     } finally {
         if (null != txn) {
             txn.close();
         }
     }

     return status;
 }       
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; HTTP的post方法此处不再给出，到这基本自定义 Sink已经完成了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成&lt;code&gt;jar&lt;/code&gt;包：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; mvn clean package
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 在上面命令运行成功后，复制 &lt;code&gt;target/flume-ng-http-sink-1.0.jar&lt;/code&gt;到&lt;code&gt;$FLUME_HOME/lib&lt;/code&gt;目录即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; cp target/flume-ng-http-sink-1.0.jar $FLUME_HOME/lib
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;三、Custom Channel&lt;/h2&gt;

&lt;p&gt;...&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;未完待续。。。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Apache Flume-NG 介绍[4] 之 Channel</title>
   <link href="http://www.blogways.net/blog/2015/04/29/Apache-Flume-NG-Introduction-4.html"/>
   <updated>2015-04-29T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/04/29/Apache-Flume-NG-Introduction-4</id>
   <content type="html">&lt;h2&gt;一、常用Channel介绍&lt;/h2&gt;

&lt;p&gt;Channels 是一个 Agent上存储 events 的仓库，Source 向其中添加 events，而 Sink从中取走移除 events。&lt;/p&gt;

&lt;p&gt;此处介绍的 Channel 有：Memory Channel、File Channel 和 Spillable Memory Channel。&lt;/p&gt;

&lt;h3&gt;Memory Channel&lt;/h3&gt;

&lt;p&gt;Source 添加的 events 都暂存在内存队列中，它非常适合那些需要更高吞吐量的数据流，但代价是一旦一个 agent 失败后，其中存储的events数据将会丢失。其必须的属性如下：&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;memory&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;capacity&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;100&lt;/td&gt;&lt;td&gt;存储在 Channel 当中的最大 events 数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;transactionCapacity&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;100&lt;/td&gt;&lt;td&gt;同时刻从Source 获取，或发送到 Sink 的最大 events 数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;keep-alive&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;3&lt;/td&gt;&lt;td&gt;添加或删除一个 event 超时的秒数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;byteCapacityBufferPercentage&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;20&lt;/td&gt;&lt;td&gt;&lt;i&gt;&lt;b&gt;详见表后的链接&lt;/b&gt;&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;byteCapacity&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;20000&lt;/td&gt;&lt;td&gt;&lt;i&gt;&lt;b&gt;详见表后的链接&lt;/b&gt;&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;


&lt;p&gt;详情见：&lt;a href=&quot;http://flume.apache.org/FlumeUserGuide.html#memory-channel&quot;&gt;http://flume.apache.org/FlumeUserGuide.html#memory-channel&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;实例 &lt;code&gt;Agent a1&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a1.channels = c1
a1.channels.c1.type = memory
a1.channels.c1.capacity = 10000
a1.channels.c1.transactionCapacity = 10000
a1.channels.c1.byteCapacityBufferPercentage = 20
a1.channels.c1.byteCapacity = 800000
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;File Channel&lt;/h3&gt;

&lt;p&gt;必须的属性如下：&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;file&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;hostname&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;绑定的主机名或者 IP 地址&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;port&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;绑定的端口号&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;batch-size&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;100&lt;/td&gt;&lt;td&gt;一次同时发送的 event 数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;connect-timeout&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;20000&lt;/td&gt;&lt;td&gt;第一次握手请求时允许的时长。( ms )&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;request-timeout&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;20000&lt;/td&gt;&lt;td&gt;第一次过后，后续请求允许的时长 ( ms )&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;ireset-connection-interval&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;none&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;实例，&lt;code&gt;Agent a1&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a1.channels = c1
a1.channels.c1.type = file
a1.channels.c1.checkpointDir = /mnt/flume/checkpoint
a1.channels.c1.dataDirs = /mnt/flume/data
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Spillable Memory Channel&lt;/h3&gt;

&lt;p&gt;Logs Sink 属于 INFO 级别的，通常用作测试或调试目的，其属性：&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;SPILLABLEMEMORY&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;memoryCapacity&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;10000&lt;/td&gt;&lt;td&gt;存储在内存队列中的最大 events 数，设置为 &lt;code&gt;0&lt;/code&gt;，则禁用缓存到内存队列&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;overflowCapacity&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;100000000&lt;/td&gt;&lt;td&gt;存储在本地磁盘的最大 events 数，设置为 &lt;code&gt;0&lt;/code&gt;，则禁用缓存到本地文件&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;overflowTimeout&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;3&lt;/td&gt;&lt;td&gt;当内存队列溢出后，启用本地磁盘缓存的超时时间&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;byteCapacityBufferPercentage&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;见描述&lt;/td&gt;&lt;td&gt;&lt;i&gt;&lt;b&gt;详见表后的链接&lt;/b&gt;&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;byteCapacity&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;20&lt;/td&gt;&lt;td&gt;&lt;i&gt;&lt;b&gt;详见表后的链接&lt;/b&gt;&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;avgEventSize&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;500&lt;/td&gt;&lt;td&gt;估计将要缓存到 Channel 当中的 events 的平均大小 (单位：字节)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;&amp;lt;file channel properties&amp;gt;&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;见描述&lt;/td&gt;&lt;td&gt;&lt;i&gt;&lt;b&gt;详见表后的链接&lt;/b&gt;&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;详情见：&lt;a href=&quot;http://flume.apache.org/FlumeUserGuide.html#spillable-memory-channel&quot;&gt;http://flume.apache.org/FlumeUserGuide.html#spillable-memory-channel&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果 &lt;code&gt;memoryCapacity&lt;/code&gt;或&lt;code&gt;byteCapacity&lt;/code&gt;被设置为 0，则 Flume 理解为内存队列已经满了。&lt;/p&gt;

&lt;p&gt;实例，&lt;code&gt;Agnet a1&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a1.channels = c1
a1.channels.c1.type = SPILLABLEMEMORY
a1.channels.c1.memoryCapacity = 10000
a1.channels.c1.overflowCapacity = 1000000
a1.channels.c1.byteCapacity = 800000
a1.channels.c1.checkpointDir = /mnt/flume/checkpoint
a1.channels.c1.dataDirs = /mnt/flume/data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;禁用缓存 events 到内存队列，&lt;code&gt;memoryCapacity&lt;/code&gt;属性设为 0，则此 Channel 就像一个 File Channel：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a1.channels = c1
a1.channels.c1.type = SPILLABLEMEMORY
a1.channels.c1.memoryCapacity = 0
a1.channels.c1.overflowCapacity = 1000000
a1.channels.c1.checkpointDir = /mnt/flume/checkpoint
a1.channels.c1.dataDirs = /mnt/flume/data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;禁用缓存 events 到本地磁盘，&lt;code&gt;overflowCapacity&lt;/code&gt;属性设为 0，则此 Channel 就像一个纯粹的 Memory Channel：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a1.channels = c1
a1.channels.c1.type = SPILLABLEMEMORY
a1.channels.c1.memoryCapacity = 100000
a1.channels.c1.overflowCapacity = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;未完待续。。。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Apache Flume-NG 介绍[3] 之 Sink</title>
   <link href="http://www.blogways.net/blog/2015/04/29/Apache-Flume-NG-Introduction-3.html"/>
   <updated>2015-04-29T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/04/29/Apache-Flume-NG-Introduction-3</id>
   <content type="html">&lt;h2&gt;一、常用Sink介绍&lt;/h2&gt;

&lt;p&gt;此处介绍的 Sinks 有：HDFS Sink、Logger Sink、Avro/Thrift Sink、HBase Sink。&lt;/p&gt;

&lt;h3&gt;Avro Sink&lt;/h3&gt;

&lt;p&gt;Avro Sink 为 Flume 的层次连接提供了一半的支持( 另一半为 Avro Source )，发送到此 Sink 的 Flume 被转换为 Avro 事件，然后被发送到对应的主机：端口上。其必须的属性如下：&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;avro&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;hostname&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;绑定的主机名或者 IP 地址&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;port&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;绑定的端口号&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;batch-size&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;100&lt;/td&gt;&lt;td&gt;一次同时发送的 event 数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;connect-timeout&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;20000&lt;/td&gt;&lt;td&gt;第一次握手请求时允许的时长。( ms )&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;request-timeout&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;20000&lt;/td&gt;&lt;td&gt;第一次过后，后续请求允许的时长 ( ms )&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;ireset-connection-interval&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;none&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;compression-type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;none&lt;/td&gt;&lt;td&gt;可选项为“none”或“deflate”，compression-type必须符合匹配AvroSource的compression-type&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;compression-level&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;6&lt;/td&gt;&lt;td&gt;压缩 event 的压缩级别，0 为不压缩，1 - 9 为压缩，数字越大则压缩率越大。&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;ssl&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;false&lt;/td&gt;&lt;td&gt;设置为&lt;code&gt;true&lt;/code&gt;启用SSL加密，同时可以选择性设置“truststore”，“truststore-password”，“truststore-type”，并且指定是否打开“trust-all-certs”&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;trust-all-certs&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;false&lt;/td&gt;&lt;td&gt;如果设置为 &lt;code&gt;true&lt;/code&gt;，则远程服务( Avro Source )的 SSL 服务证书将不会进行校验，因而生产环境不能设置为 &lt;code&gt;true&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;truststore&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Java truststore文件的路径，需要启用SSL加密&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;truststore-password&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Java truststore的密码，需要启用SSl加密&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;truststore-type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;JKS&lt;/td&gt;&lt;td&gt;Java truststore的类型，可选项为：“JSK” 或其它支持的Java truststore 类型&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;exclude-protocols&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;SSLv2Hello SSLv3&lt;/td&gt;&lt;td&gt;Space-separated list of SSL/TLS protocols to exclude&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;maxIoWorkers&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;2 * 当前机器上可用的处理器数&lt;/td&gt;&lt;td&gt;I/O 处理线程的最大数，在 &lt;code&gt;NettyAvroRpcClient&lt;/code&gt; 和 &lt;code&gt;NioClientSocketChannelFactory&lt;/code&gt; 上被加载。&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;实例 &lt;code&gt;Agent a1&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a1.channels = c1
a1.sinks = k1
a1.sinks.k1.type = avro
a1.sinks.k1.channel = c1
a1.sinks.k1.hostname = 10.10.10.10
a1.sinks.k1.port = 4545
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Thrift Sink&lt;/h3&gt;

&lt;p&gt;Thrift Sink 为 Flume 的层次连接提供了一半的支持( 另一半为 Thrift Source )，发送到此 Sink 的 Flume 被转换为 Thrift 事件，然后被发送到对应的主机：端口上。其必须的属性如下：&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;thrift&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;hostname&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;绑定的主机名或者 IP 地址&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;port&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;绑定的端口号&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;batch-size&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;100&lt;/td&gt;&lt;td&gt;一次同时发送的 event 数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;connect-timeout&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;20000&lt;/td&gt;&lt;td&gt;第一次握手请求时允许的时长。( ms )&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;request-timeout&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;20000&lt;/td&gt;&lt;td&gt;第一次过后，后续请求允许的时长 ( ms )&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;ireset-connection-interval&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;none&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;实例，&lt;code&gt;Agent a1&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a1.channels = c1
a1.sinks = k1
a1.sinks.k1.type = thrift
a1.sinks.k1.channel = c1
a1.sinks.k1.hostname = 10.10.10.10
a1.sinks.k1.port = 4545
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;HDFS Sink&lt;/h3&gt;

&lt;p&gt;HDFS Sink 将 events 写入到 Hadoop 分布式文件系统( HDFS )当中，目前它支持创建文本文件和二进制序列化文件( SequenceFile )，这两种文件类型都支持压缩文件。数据库文件能够周期性地，在运行时间、数据大小或event数量的基础上轮转( 关闭当前文件，并创建一个新文件 )。It also buckets/partitions data by attributes like timestamp or machine where the event originated. The HDFS directory path may contain formatting escape sequences that will replaced by the HDFS sink to generate a directory/file name to store the events. 使用 HDFS Sink 需要安装 hadoop，如此 Flume 便能够通过 hadoop jars 连接 HDFS 集群，注意，Hadoop 的版本必须支持&lt;code&gt;sync()&lt;/code&gt;调用。&lt;/p&gt;

&lt;p&gt;下面是支持的转义序列：&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;20%&quot;&gt;别名&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%{host}&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%t&lt;/td&gt;&lt;td&gt;Unix 时间的秒数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%a&lt;/td&gt;&lt;td&gt;本地的星期缩写名称 (Mon, Tue, ...)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%A&lt;/td&gt;&lt;td&gt;本地的星期完整名称 (Monday, Tuesday, ...)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%b&lt;/td&gt;&lt;td&gt;本地的月份缩写名称 (Jan, Feb, ...)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%B&lt;/td&gt;&lt;td&gt;本地的月份完整名称 (January, February, ...)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%c&lt;/td&gt;&lt;td&gt;本地的日期和时间 (Thu Mar 3 23:05:25 2005)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%d&lt;/td&gt;&lt;td&gt;某月中的某天 (01)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%D&lt;/td&gt;&lt;td&gt;日期，与 &lt;code&gt;%m/%d/%y&lt;/code&gt; 一样&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%H&lt;/td&gt;&lt;td&gt;24 小时制的小时，&lt;b&gt;&lt;i&gt;补齐两位&lt;/i&gt;&lt;/b&gt; (00..23)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%I&lt;/td&gt;&lt;td&gt;12 小时制的小时，&lt;b&gt;&lt;i&gt;补齐两位&lt;/i&gt;&lt;/b&gt; (01..12)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%j&lt;/td&gt;&lt;td&gt;某年中的某天 (001..366)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%k&lt;/td&gt;&lt;td&gt;24 小时制的小时，&lt;b&gt;&lt;i&gt;不补齐两位&lt;/i&gt;&lt;/b&gt; ( 0..23)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%m&lt;/td&gt;&lt;td&gt;月份 (01..12)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%M&lt;/td&gt;&lt;td&gt;分钟数 (00..59)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%p&lt;/td&gt;&lt;td&gt;本地上午或下午 (am, pm)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%s&lt;/td&gt;&lt;td&gt;从 &lt;code&gt;1970-01-01 00:00:00 UTC&lt;/code&gt; 到现在的秒数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%S&lt;/td&gt;&lt;td&gt;秒数 (00..59)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%y&lt;/td&gt;&lt;td&gt;年份的后两位数字 (00..99)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%Y&lt;/td&gt;&lt;td&gt;年份 (2015)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%z&lt;/td&gt;&lt;td&gt;+hhmm numeric timezone (for example, -0400)&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;正在读取的文件的文件名会以 &lt;code&gt;.tmp&lt;/code&gt; 结尾，一旦文件被关闭，则扩展部分会被移除，这使排除目录中部分完成的文件称为可能。其config属性如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意：对于所有与时间相关的转义系列，一个包含 “timestamp” 的header必须在 event 的所有headers中存在( 除非 &lt;code&gt;hdfs.useLocalTimeStamp&lt;/code&gt; 被设置为 &lt;code&gt;true&lt;/code&gt; )。设置自动添加的一种方式是使用 &lt;code&gt;TimestampInterceptor&lt;/code&gt;。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;hdfs&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;hdfs.path&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;HDFS 目录路径 (如 &lt;code&gt;hdfs://namenode/flume/webdata/&lt;/code&gt;)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;hdfs.filePrefix&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;FlumeData&lt;/td&gt;&lt;td&gt;在 HDFS 目录中，Flume 创建的文件的前缀&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;hdfs.fileSuffix&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;文件的后缀 (如 &lt;code&gt;.avro&lt;/code&gt; - 注意：时间不是自动添加的)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;hdfs.inUsePrefix&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Flume 正在写入的临时文件的的前缀&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;hdfs.inUseSuffix&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;code&gt;.tmp&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Flume 正在写入的临时文件的后缀&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;更多属性配置详见：&lt;a href=&quot;http://flume.apache.org/FlumeUserGuide.html#hdfs-sink&quot;&gt;http://flume.apache.org/FlumeUserGuide.html#hdfs-sink&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;实例，&lt;code&gt;Agent a1&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a1.channels = c1
a1.sinks = k1
a1.sinks.k1.type = hdfs
a1.sinks.k1.channel = c1
a1.sinks.k1.hdfs.path = /flume/events/%y-%m-%d/%H%M/%S
a1.sinks.k1.hdfs.filePrefix = events-
a1.sinks.k1.hdfs.round = true
a1.sinks.k1.hdfs.roundValue = 10
a1.sinks.k1.hdfs.roundUnit = minute
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的配置将时间戳四舍五入到最近的10分钟，如：一个 event 的时间戳是 &lt;code&gt;11:54:34 AM, June 12, 2012&lt;/code&gt;，那么映射到 hdfs 路径则为 &lt;code&gt;/flume/events/2012-06-12/1150/00&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;HBase Sink&lt;/h3&gt;

&lt;p&gt;具体介绍等，详见：&lt;a href=&quot;http://flume.apache.org/FlumeUserGuide.html#hbasesink&quot;&gt;http://flume.apache.org/FlumeUserGuide.html#hbasesink&lt;/a&gt;&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;hbase&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;table&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;HBase 中写入数据的表&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;columnFamily&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;HBase 中写入数据列簇&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;zookeeperQuorum&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;The quorum spec. This is the value for the property hbase.zookeeper.quorum in hbase-site.xml&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;znodeParent&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;/hbase&lt;/td&gt;&lt;td&gt;The base path for the znode for the -ROOT- region. Value of zookeeper.znode.parent in hbase-site.xml&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;batchSize&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;100&lt;/td&gt;&lt;td&gt;每次事务处理写入的 event数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;coalesceIncrements&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;false&lt;/td&gt;&lt;td&gt;是否添加一个保存文件 &lt;code&gt;basename&lt;/code&gt; 的Header&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;serializer&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;org.apache.flume.sink.hbase.SimpleHbaseEventSerializer&lt;/td&gt;&lt;td&gt;Default increment column = “iCol”, payload column = “pCol”&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;serializer.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Properties to be passed to the serializer.&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;kerberosPrincipal&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Kerberos user principal for accessing secure HBase&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;kerberosKeytab&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Kerberos keytab for accessing secure HBase&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;实例，&lt;code&gt;Agent agent-1&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a1.channels = c1
a1.sinks = k1
a1.sinks.k1.type = hbase
a1.sinks.k1.table = foo_table
a1.sinks.k1.columnFamily = bar_cf
a1.sinks.k1.serializer = org.apache.flume.sink.hbase.RegexHbaseEventSerializer
a1.sinks.k1.channel = c1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Logger Sink&lt;/h3&gt;

&lt;p&gt;Logs Sink 属于 INFO 级别的，通常用作测试或调试目的，其属性：&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;logger&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;实例，&lt;code&gt;Agnet a1&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a1.channels = c1
a1.sinks = k1
a1.sinks.k1.type = logger
a1.sinks.k1.channel = c1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;未完待续。。。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Spring NoSuchBeanDefinitionException</title>
   <link href="http://www.blogways.net/blog/2015/04/28/spring-exception.html"/>
   <updated>2015-04-28T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/04/28/spring-exception</id>
   <content type="html">&lt;h3&gt;1. 概述&lt;/h3&gt;

&lt;p&gt;在这篇文章中，我们讨论一下 Spring &lt;code&gt;BeanFactory&lt;/code&gt; 在试图创建一个未在 Spring 上下文中定义的 Bean 时抛出的常见的异常 &lt;code&gt;org.springframework.beans.factory.NoSuchBeanDefinitionException&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;我们将在这里讨论下导致这个问题的可能的原因以及可用的解决方案。&lt;/p&gt;

&lt;h3&gt;2. Cause: No qualifying bean of type […] found for dependency&lt;/h3&gt;

&lt;p&gt;导致这个异常的最常见的原因是企图注入一个未被定义的 bean。例如－在 BeanA 中注入 BeanB：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Component
public class BeanA {

    @Autowired
    private BeanB dependency;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但如果 BeanB 没有在 Spring 的上下文中定义依赖关系，bootstrap 进程会终止并抛出 &lt;code&gt;NoSuchBeanDefinitionException&lt;/code&gt; 异常：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;org.springframework.beans.factory.NoSuchBeanDefinitionException: 
No qualifying bean of type [org.baeldung.packageB.BeanB] found for dependency: 
expected at least 1 bean which qualifies as autowire candidate for this dependency. 
Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Spring 已经明确指出：“至少需要一个 bean 作为 autowire 依赖注入”&lt;/p&gt;

&lt;p&gt;一个原因 BeanB 可能不在上下文中，需要 bean 在 classpath 扫描时自动加载，并且被成功注解为其中的一个 bean (@Component, @Repository, @Service, @Controller, etc)，那么很可能 BeanB 所在的包没有被 Spring 扫描到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package org.baeldung.packageB;
@Component
public class BeanB { ...}
While the classpath scanning may be configured as follows:

@Configuration
@ComponentScan(&quot;org.baeldung.packageA&quot;)
public class ContextWithJavaConfig {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果 bean 所在的目录没有配置扫描，那么 BeanB 也就不会定义在当前的 Spring 上下文中。&lt;/p&gt;

&lt;h3&gt;3. Cause: No qualifying bean of type […] is defined&lt;/h3&gt;

&lt;p&gt;另外一种情况就是上下文中存在重复的 bean 定义，不唯一。例如，假如有一个接口 &lt;code&gt;IBeanB&lt;/code&gt; 被两个 bean (&lt;code&gt;BeanB1&lt;/code&gt;和&lt;code&gt;BeanB2&lt;/code&gt;) 实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Component
public class BeanB1 implements IBeanB {
    //
}
@Component
public class BeanB2 implements IBeanB {
    //
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当 BeanA 依赖注入这个接口时，Spring 不知道到底注入哪个实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Component
public class BeanA {

    @Autowired
    private IBeanB dependency;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果是 &lt;code&gt;BeanFactory&lt;/code&gt; 再次抛出了异常：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: 
No qualifying bean of type [org.baeldung.packageB.IBeanB] is defined: 
expected single matching bean but found 2: beanB1,beanB2
Similarly, Spring clearly indicates the reason for the wiring failure: “expected single matching bean but found 2″.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是注意，这次抛出的异常不是 &lt;code&gt;NoSuchBeanDefinitionException&lt;/code&gt;，而是它的子类 &lt;code&gt;NoUniqueBeanDefinitionException&lt;/code&gt;。这个新的异常在 Spring 3.2.1 有介绍，具体的原因就是在上下文中存在重复的 bean 定义。&lt;/p&gt;

&lt;p&gt;如果不做指定，就会报如下的异常：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: 
No qualifying bean of type [org.baeldung.packageB.IBeanB] is defined: 
expected single matching bean but found 2: beanB1,beanB2
One solution to this problem is to use the @Qualifier annotation to specify exactly the name of the bean we want to wire:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Component
public class BeanA {

    @Autowired
    @Qualifier(&quot;beanB2&quot;)
    private IBeanB dependency;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过指定 &lt;code&gt;Qualifier&lt;/code&gt; 具体的注入 bean，Spring 将能决定使用哪个实现类来注入。&lt;/p&gt;

&lt;h3&gt;4. Cause: No Bean Named […] is defined&lt;/h3&gt;

&lt;p&gt;当 Spring 的上下文中不存在指定名称的 bean 时同样会抛出 &lt;code&gt;NoSuchBeanDefinitionException&lt;/code&gt; 异常：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Component
public class BeanA implements InitializingBean {

    @Autowired
    private ApplicationContext context;

    @Override
    public void afterPropertiesSet() {
        context.getBean(&quot;someBeanName&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个例子中，不存在 &lt;code&gt;someBeanName&lt;/code&gt; 名称定义的 bean 将会导致下面的异常：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: 
No bean named 'someBeanName' is defined
Again, Spring clearly and concisely indicates the reason for the failure: “No bean named X is defined“.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;5. Cause: Proxied Beans&lt;/h3&gt;

&lt;p&gt;当上下文中一个 bean 使用 JDK 的动态代理机制代理时，那么这个代理类不需要扩展目标 bean （然而它将实现相同的接口）&lt;/p&gt;

&lt;p&gt;正因为如此，如果一个接口被注入，它将被正确接入。然而如果一个 bean 被实际类注入，Spring  将找不到匹配的类的 bean 定义，由于代理类实际上不扩展该类。&lt;/p&gt;

&lt;p&gt;一个很常见的代理是 Spring 的事务支持，即被 &lt;code&gt;@Transactional&lt;/code&gt; 注解的 bean。&lt;/p&gt;

&lt;p&gt;例如，如果 ServiceA 注入 ServiceB，两个服务都有事务，通过类定义注入将无法工作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Service
@Transactional
public class ServiceA implements IServiceA{

    @Autowired
    private ServiceB serviceB;
    ...
}

@Service
@Transactional
public class ServiceB implements IServiceB{
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样的两个服务，这次通过接口注入就 OK：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Service
@Transactional
public class ServiceA implements IServiceA{

    @Autowired
    private IServiceB serviceB;
    ...
}

@Service
@Transactional
public class ServiceB implements IServiceB{
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;6. 结论&lt;/h3&gt;

&lt;p&gt;本文讨论了几种可能导致 &lt;code&gt;NoSuchBeanDefinitionException&lt;/code&gt; 的情况，重点是如何在实践中解决这些异常。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Apache Flume-NG 介绍[2] 之 Source</title>
   <link href="http://www.blogways.net/blog/2015/04/28/Apache-Flume-NG-Introduction-2.html"/>
   <updated>2015-04-28T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/04/28/Apache-Flume-NG-Introduction-2</id>
   <content type="html">&lt;h2&gt;一、常用Sources介绍&lt;/h2&gt;

&lt;p&gt;此处介绍的 Sources 有：Avro Source、Thrift Source、Exec Source、Spooling Directory Source。&lt;/p&gt;

&lt;h3&gt;Avro Source&lt;/h3&gt;

&lt;p&gt;监听 Avro 端口，接收外部 Avro 客户端发来的 Event 是流，当和另一个Agent (Event流上，前面一个) 的 Avro Sink 连接配对时，能够将两个 Agent 连接形成一个Event 链。其必须的属性如下：&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;avro&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;bind&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;监听的主机名或者 IP 地址&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;port&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;监听的端口号&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;threads&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;能生成的工作线程的最大数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;selector.type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;selector.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;interceptors&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Space-separated list of interceptors&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;interceptors.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;compression-type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;none&lt;/td&gt;&lt;td&gt;可选项为“none”或“deflate”，compression-type必须符合匹配AvroSource的compression-type&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;ssl&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;false&lt;/td&gt;&lt;td&gt;设置为&lt;code&gt;true&lt;/code&gt;启用SSL加密，同时必须制定一个“keystore”和一个“keystore-password”&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;keystore&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Java keystore文件的路径，需要启用SSL加密&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;keystore-password&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Java keystore的密码，需要启用SSl加密&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;keystore-type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;JKS&lt;/td&gt;&lt;td&gt;Java keystore的类型，可选项为：“JSK” 和 “PKCS12”&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;exclude-protocols&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;SSLv3&lt;/td&gt;&lt;td&gt;Space-separated list of SSL/TLS protocols to exclude. SSLv3 will always be excluded in addition to the protocols specified.&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;ipFilter&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;false&lt;/td&gt;&lt;td&gt;设置为&lt;code&gt;true&lt;/code&gt;启用ip过滤&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;ipFilter.rules&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;通过此配置，定义ip过滤的表达式规则&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;实例 &lt;code&gt;Agent a1&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a1.sources = r1
a1.channels = c1
a1.sources.r1.type = avro
a1.sources.r1.bind = localhost
a1.sources.r1.port = 4141
a1.sources.r1.ipFilter = true
a1.sources.r1.ipFilter.rules = allow:ip:127.*,allow:name:localhost,deny:ip:*

a1.sources.r1.channels = c1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ipFilter.rules&lt;/code&gt;定义格式如下 ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;allow or deny&amp;gt;:&amp;lt;ip or name for computer name&amp;gt;:&amp;lt;pattern&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;allow/deny:ip/name:pattern
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Thrift Source&lt;/h3&gt;

&lt;p&gt;监听 Thrift 端口，接收外部 Thrift 客户端发来的 Event 是流，当和另一个Agent (Event流上，前面一个) 的 Thrift Sink 连接配对时，能够将两个 Agent 连接形成一个Event 链。其必须的属性如下：&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;thrift&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;bind&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;监听的主机名或者 IP 地址&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;port&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;监听的端口号&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;threads&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;能生成的工作线程的最大数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;selector.type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;selector.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;interceptors&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Space-separated list of interceptors&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;interceptors.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;实例，&lt;code&gt;Agent a1&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a1.sources = r1
a1.channels = c1
a1.sources.r1.type = thrift
a1.sources.r1.channels = c1
a1.sources.r1.bind = 0.0.0.0
a1.sources.r1.port = 4141
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Exec Source&lt;/h3&gt;

&lt;p&gt;Exec Source 运行一个给定的 Unix 命令，此命令需要在启动后，进程能不断的产生数据到标准输出( 除非将 &lt;code&gt;logStdErr&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt;，否则标准错误输出stderr将会被抛弃 )。如果 Unix 命令进程意外退出了，Exec Source 也会退出，不会再产生数据。这意味着配置如 &lt;code&gt;cat [named pipe]&lt;/code&gt; 或 &lt;code&gt;tail -F [file]&lt;/code&gt; 命令的时候将会产生期望的结果，而使用 &lt;code&gt;date&lt;/code&gt; 命令的时候不会，前面两个命令会产生数据流，但是后面一个任务只会产生一个单一的 Event，然后马上退出。其config属性如下：&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;exec&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;command&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;需要执行的命令&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;shell&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;调用来运行命令的shell，如：&lt;code&gt;/bin/sh -c&lt;/code&gt;，Required only for commands relying on shell features like wildcards, back ticks, pipes etc.&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;restartThrottle&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;10000&lt;/td&gt;&lt;td&gt;重启之前的等待时间(ms
)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;resstart&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;false&lt;/td&gt;&lt;td&gt;设置是否重启命令，如果命令进程死了&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;logStdErr&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;false&lt;/td&gt;&lt;td&gt;设置是否命令的标准错误输出会被发送&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;batchSize&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;20&lt;/td&gt;&lt;td&gt;同时读取和发送的最大行数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;selector.type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;replicating&lt;/td&gt;&lt;td&gt;replicating 或 multiplexing&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;selector.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;依赖selector.type的值&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;interceptors&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Space-separated list of interceptors&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;interceptors.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意：可以使用Exec Source 模仿Flume 0.9x ( flume-og )中的 Tail Source，只要使用 Unix 命令&lt;code&gt;tail -F /full/path/to/your/file&lt;/code&gt;，在此情况下，参数 &lt;code&gt;-F&lt;/code&gt;比 &lt;code&gt;-f&lt;/code&gt;要更好，因为它会根据文件轮询。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;实例，&lt;code&gt;Agent a1&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a1.sources = r1
a1.channels = c1
a1.sources.r1.type = exec
a1.sources.r1.command = tail -F /var/log/secure
a1.sources.r1.channels = c1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;shell&lt;/code&gt;配置来执行&lt;code&gt;command&lt;/code&gt;，通过一个命令行脚本( 如 Bash 或 PowerShell )，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;agent_foo.sources.tailsource-1.type = exec
agent_foo.sources.tailsource-1.shell = /bin/bash -c
agent_foo.sources.tailsource-1.command = for i in /path/*.txt; do cat $i; done
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Spooling Directory Source&lt;/h3&gt;

&lt;p&gt;SpoolDir Source 支持从磁盘“spooling”文件夹读取数据文件，此源会监控指定的文件夹的新增文件，一旦有新文件出现，SpoolDir Source 会将其解析为 Event发送，这个 Event 解析逻辑时插件化的。在一个文件被全部读入到 Channel 之后， 该文件会被重命名标记完成( 或选择性的删除 )。&lt;/p&gt;

&lt;p&gt;不同于 Exec Source，这个源是可靠的，即使 Flume 进程重启或是被杀掉都不会丢失数据。作为可靠性的交换，只有不变的且命名唯一的文件才能被放入源监控的目录，Flume 会检测这些问题条件，如果违反了，Flume 会报错：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果一个文件在移动到 SpoolDir Source 监控目录下之后被更改过，Flume 会在日志文件中输出错误信息，并停止 Flume 进程；&lt;/li&gt;
&lt;li&gt;如果一个文件名在一段时间后被重复使用，Flume 会在日志文件中输出错误信息，并停止 Flume 进程。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;为了避免上述问题，比较好的方法是：在日志文件被移动到监控目录时，给日志文件用唯一标示符来命名( 例如：时间戳，timestamp )；&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;spooldir&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;spoolDir&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;源监控的目录路径&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;fileSuffix&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;.COMPLETED&lt;/td&gt;&lt;td&gt;文件被读入完成后添加的标示符后缀&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;deletePolicy&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;never&lt;/td&gt;&lt;td&gt;是否删除完成读入的文件，可选项：&lt;code&gt;never&lt;/code&gt; 或 &lt;code&gt;immediate&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;fileHeader&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;false&lt;/td&gt;&lt;td&gt;是否添加一个保存文件绝对路径的 Header&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;fileHeaderKey&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;file&lt;/td&gt;&lt;td&gt;当给 event header 添加绝对路径名的时候使用&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;basenameHeader&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;false&lt;/td&gt;&lt;td&gt;是否添加一个保存文件 &lt;code&gt;basename&lt;/code&gt; 的Header&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;basenameHeaderKey&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;basename&lt;/td&gt;&lt;td&gt;当给 event header 添加 &lt;code&gt;basename&lt;/code&gt; 的时候使用&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;ignorePattern&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;^$&lt;/td&gt;&lt;td&gt;忽略正则表达式指定的文件&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;trackerDir&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;.flumespool&lt;/td&gt;&lt;td&gt;保存跟进程文件相关元数据的目录，如果此路径不是一个绝对路径，就会解释为一个相对于 &lt;code&gt;spoolDir&lt;/code&gt; 的路径。&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;consumeOrder&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;oldest&lt;/td&gt;&lt;td&gt;监控目录下的文件被读取的顺序，可选项为：&lt;code&gt;oldest&lt;/code&gt;、&lt;code&gt;youngest&lt;/code&gt;、&lt;code&gt;random&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;maxBackoff&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;4000 ( ms )&lt;/td&gt;&lt;td&gt;当 Channel 满了之后，连续尝试往 Channel 传送数据的最大时间间隔。SpoolDir Source 开始会启动一个很低的 &lt;code&gt;maxBackoff&lt;/code&gt;，一旦 Channel 抛出一个 &lt;code&gt;ChannelException&lt;/code&gt; 的时候，就会增加此 &lt;code&gt;maxBackoff&lt;/code&gt; 值，直到达到指定的最大值。&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;batchSize&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;100&lt;/td&gt;&lt;td&gt;数据被传送到 Channel 的粒度。&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;inputCharset&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;UTF-8&lt;/td&gt;&lt;td&gt;将输入当做文本文档解析时候使用的字符集，即监控文件的字符集&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;decodeErrorPolicy&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;code&gt;FAIL&lt;/code&gt;&lt;/td&gt;&lt;td&gt;当发现一个无法解析字符集的输入文件时，需要做的处理：&lt;code&gt;FAIL&lt;/code&gt;，抛出一个异常并标记解析失败；&lt;code&gt;REPLACE&lt;/code&gt;，使用 “replacement character” 字符重复解析错误解析字符，例如 Unicode U+FFFD；&lt;code&gt;IGNORE&lt;/code&gt;，删除无法解析的字符串序列。&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;deserializer&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;code&gt;LINE&lt;/code&gt;&lt;/td&gt;&lt;td&gt;指定将文件解析为 Event 的解析器，默认解析每行为一个 Event，指定的限定性类名必须实现接口 &lt;code&gt;EventDeserializer.Builder&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;deserializer.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;Varies per event deserializer.&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;bufferMaxLines&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;该选项已经被忽略&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;bufferMaxLineLength&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;5000&lt;/td&gt;&lt;td&gt;(Deprecated) 提交缓存中一行的最大长度，使用 &lt;code&gt;deserializer.maxLineLength&lt;/code&gt; 代替。&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;selector.type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;replicating&lt;/td&gt;&lt;td&gt;replicating 或 multiplexing&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;selector.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;依赖selector.type的值&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;interceptors&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Space-separated list of interceptors&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;interceptors.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;实例，&lt;code&gt;Agent agent-1&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;agent-1.channels = ch-1
agent-1.sources = src-1

agent-1.sources.src-1.type = spooldir
agent-1.sources.src-1.channels = ch-1
agent-1.sources.src-1.spoolDir = /var/log/apache/flumeSpool
agent-1.sources.src-1.fileHeader = true
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;NetCat Source&lt;/h3&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;netcat&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;bind&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;监听主机名或ip地址&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;port&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;监听端口号&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;max-line-length&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;512&lt;/td&gt;&lt;td&gt;每个 event 内容的最大行数 ( 单位：字节 )&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;ack-every-event&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;true&lt;/td&gt;&lt;td&gt;每接收到一个 event 则回发一个 OK&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;selector.type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;replicating&lt;/td&gt;&lt;td&gt;replicating 或 multiplexing&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;selector.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;依赖selector.type的值&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;interceptors&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Space-separated list of interceptors&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;interceptors.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;实例，&lt;code&gt;Agnet a1&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a1.sources = r1
a1.channels = c1
a1.sources.r1.type = netcat
a1.sources.r1.bind = 0.0.0.0
a1.sources.r1.bind = 6666
a1.sources.r1.channels = c1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;二、Event Deserializers&lt;/h2&gt;

&lt;p&gt;以下是 Flume 附带的 Event 解析器：Line、Avro、BlobDeserializer。&lt;/p&gt;

&lt;h3&gt;Line&lt;/h3&gt;

&lt;p&gt;此 deserializer 对应文本输入的每一行生成一个 event。&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;deserializer.maxLineLength&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;2048&lt;/td&gt;&lt;td&gt;单个 event 能包含字符的最大数，如果一行超过了这个长度，将会被截断，该行中截断后剩余的字符会出现在后续的 event 中&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;deserializer.outputCharset&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;UTF-8&lt;/td&gt;&lt;td&gt;发送到 Channel 的每个 event 的编码字符集&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


&lt;h3&gt;AVRO&lt;/h3&gt;

&lt;p&gt;详情见&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;http://flume.apache.org/FlumeUserGuide.html#avro&quot; title=&quot;http://flume.apache.org/FlumeUserGuide.html#avro&quot;&gt;AVRO Deserializer&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;deserializer.schemaType&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;HASH&lt;/td&gt;&lt;td&gt;How the schema is represented. By default, or when the value HASH is specified, the Avro schema is hashed and the hash is stored in every event in the event header “flume.avro.schema.hash”. If LITERAL is specified, the JSON-encoded schema itself is stored in every event in the event header “flume.avro.schema.literal”. Using LITERAL mode is relatively inefficient compared to HASH mode.&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


&lt;h3&gt;BlobDeserializer&lt;/h3&gt;

&lt;p&gt;详情见&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;http://flume.apache.org/FlumeUserGuide.html#blobdeserializer&quot; title=&quot;http://flume.apache.org/FlumeUserGuide.html#blobdeserializer&quot;&gt;Blob Deserializer&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;deserializer&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;这个类的全限定性类名： &lt;code&gt;org.apache.flume.sink.solr.morphline.BlobDeserializer$Builder&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;deserializer.maxBlobLength&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;100000000&lt;/td&gt;&lt;td&gt;一个给定请求读取和缓存的最大字节数&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;未完待续。。。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Apache Flume-NG 介绍[1] 之 配置安装</title>
   <link href="http://www.blogways.net/blog/2015/04/28/Apache-Flume-NG-Introduction-1.html"/>
   <updated>2015-04-28T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/04/28/Apache-Flume-NG-Introduction-1</id>
   <content type="html">&lt;h2&gt;一、介绍&lt;/h2&gt;

&lt;h3&gt;1.1 概要&lt;/h3&gt;

&lt;p&gt;Flume 是 Cloudera 提供的日志收集系统，具有分布式、高可靠、高可用性等特点，对海量日志采集、聚合和传输，Flume 支持在日志系统中定制各类数据发送方，同时，Flume提供对数据进行简单处理，并写到各种数据接受方的能力。&lt;/p&gt;

&lt;p&gt;Flume 包括 0.9.x 和 1.x 两个版本，分别为 Flume-OG ( Flume Original Generation ) 和 Flume-NG ( Flume Next Generation )，Flume-OG 是一个分布式日志收集系统，有 Mater 概念，依赖于 zookeeper，其架构图如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/flume-og-construction.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Agent 用于采集数据，agent 是 flume 中产生数据流的地方，同时，agent 会将产生的数据流传输到 collector。对应的，collector 用于对数据进行聚合，往往会产生一个更大的流。&lt;/p&gt;

&lt;p&gt;而 Flume-NG，它摒弃了 Master和zookeeper，collector也没有了，web配置台也没有了，只剩下 source，sink和channel，此时一个agent的概念&lt;strong&gt;包括source，channel和sink&lt;/strong&gt;，完全由一个分布式系统变成了传输工具。不同机器之间的数据传输不再是OG那样由agent到collector，而是由一个agent端的sink流向另一个agent的source，其架构图如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/flume-ng-construction.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;agent的source端，直接抓取数据或接收从前一个 agent 传送过来的数据，并将其转发到&lt;strong&gt;一个或多个&lt;/strong&gt; channel 进行缓存；&lt;/p&gt;

&lt;p&gt;agent的 sink 端，从 channel 获取一个Event ( Flume-NG 的最小传输单元 )，然后传送到序列化端、下一个或多个agent 的source端。&lt;/p&gt;

&lt;p&gt;Event 就像上图中箭头所示方向流动， chennel 的功能就像一个队列，暂时保存所有的 Event，为了保证传输一定成功，在 Event 送到目的地之前，会先缓存数据，待数据真正到达目的地后，删除自己缓存的数据。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;官方网站：&lt;a href=&quot;http://flume.apache.org/&quot;&gt;http://flume.apache.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;用户文档：&lt;a href=&quot;http://flume.apache.org/FlumeUserGuide.html&quot;&gt;http://flume.apache.org/FlumeUserGuide.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;开发文档：&lt;a href=&quot;http://flume.apache.org/FlumeDeveloperGuide.html&quot;&gt;http://flume.apache.org/FlumeDeveloperGuide.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;1.2 系统要求&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Flume 使用 java 编写，其需要运行在 Java1.6 或更高版本之上；( 推荐 Java1.7 )&lt;/li&gt;
&lt;li&gt;保证有足够的内存空间让 Flume 的 source、 channel和 sink 使用；&lt;/li&gt;
&lt;li&gt;Flume 的 channel 和 sinks 组件会有文件缓存到物理硬盘中，需要足够的硬盘空间；&lt;/li&gt;
&lt;li&gt;Flume 会读取文件或目录，需要 agent 相关的文件目录的 &lt;strong&gt;&lt;em&gt;读写&lt;/em&gt;&lt;/strong&gt; 权限。&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;二、基本组件&lt;/h2&gt;

&lt;h3&gt;2.1 Agent 之 Source&lt;/h3&gt;

&lt;p&gt;source 可以接收外部源发送过来的数据，不同的 source，可以接受不同的数据格式，如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;目录池数据源(Spooling Directory Source)，可以监控指定文件夹中的新文件变化，如果目录中有文件产生，就会立刻读取其内容；&lt;/li&gt;
&lt;li&gt;命令行数据源(Exec Source)，可以运行指定的shell命令(如：&lt;code&gt;tail -f [ file ]&lt;/code&gt; )等，将产生的标准输出(或标准错误输出，需要配置)封装到 Event 中，向指定的 channel 发送；&lt;/li&gt;
&lt;li&gt;自定义源(Custom Source)，用户自定义的源，会重点介绍。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;2.2 Agent 之 Channel&lt;/h3&gt;

&lt;p&gt;channel 是一个存储地，接收 source 的输出，直到有 sink 消费掉 channel 中的数据。channel 中的数据直到进入到下一个channel中或者进入终端才会被删除。当 sink 写入失败后，可以自动重启，不会造成数据丢失，因此很可靠，常用的有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Memory Channel，将从 source 得到的 Event 都缓存到内存当中，存取速度快、高效，但是一旦 agent 崩了，缓存的数据无法恢复，可靠性不是太好；&lt;/li&gt;
&lt;li&gt;File Channel，跟Memory Channel相对的，此处将得到的 Event 都缓存到本地磁盘的文件当中，存取访问速度没有内存高效，但是可靠性强，一旦 agent 进程死掉重启后，所有缓存的 Event 可以全部恢复；&lt;/li&gt;
&lt;li&gt;Spillable Memory Channel， 前面两者的结合使用，首先发过来的 Event 都缓存到内存当中，一旦内存空间不够用了，就缓存到本地文件中，主要应用于内存空间不足，而硬盘空间充足的情况。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;2.3 Agent 之 Sink&lt;/h3&gt;

&lt;p&gt;sink 会消费 channel 中的数据，然后送给外部源或者其他 source。如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HDFS Sink/HBase Sink，根据配置将 Event 所包含的信息保存到本地 HDFS/HBase 中；&lt;/li&gt;
&lt;li&gt;Logger Sink，顾名思义，将接收到的信息日志输出，主要用于测试和调试；&lt;/li&gt;
&lt;li&gt;Avro Sink，说句实话，百度得知 Avro 是一个 Apache 的数据序列化的系统，具体是什么不需要关注，只需要知道 Avro Sink 是将接收到的数据转换为 Avro， 然后发送到下一个 Agent 的 Avro Source，多用于Agent 与 Agent之间的数据连接；&lt;/li&gt;
&lt;li&gt;用户自定义(Custom Sink)，重点介绍。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;三、安装与运行&lt;/h2&gt;

&lt;p&gt;到官方网站下载，&lt;a href=&quot;http://flume.apache.org/download.html&quot;&gt;http://flume.apache.org/download.html&lt;/a&gt;，下载完成解压完成即可使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/tools
wget -c http://mirrors.hust.edu.cn/apache/flume/1.5.2/apache-flume-1.5.2-bin.tar.gz
# 等待下载完成
tar -xvf apache-flume-1.5.2-bin.tar.gz
ln -s apache-flume-1.5.2-bin flume-ng ( 将 ~/tools/flume-ng加入到环境变量FLUME_HOME中 )   ====&amp;gt;  个人习惯，可不做
cd flume-ng
bin/flume-ng help  # 查看flume-ng命令
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或通过编译源码的方式安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/tools
wget - http://mirrors.hust.edu.cn/apache/flume/1.5.2/apache-flume-1.5.2-src.tar.gz
tar -xf apache-flume-1.5.2-src.tar.gz
cd apache-flume-1.5.2-src
# 跳过测试
mvn clean install -DskipTests
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3.0 配置文件说明&lt;/h3&gt;

&lt;p&gt;Flume 的 Agent的各个部件都是通过配置文件来实现的，Agent、Sources、Channels和Sinks的定义，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a1.sources = r1 r2
a1.sinks = k1 k2
a1.channels = c1 c2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;a1&lt;/code&gt;是定义的 Agent 的名字，也是启动命令时&lt;code&gt;--name &amp;lt;agent&amp;gt;&lt;/code&gt;中的&lt;code&gt;&amp;lt;agent&amp;gt;&lt;/code&gt;为 &lt;code&gt;a1&lt;/code&gt;；上代码Sources、Channels和 Sinks分别定义了两个分别为r1, r2, c1, c2, k1, k2；&lt;/p&gt;

&lt;p&gt;定义每个Sources的类型，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a1.sources.r1.type = avro
a1.sources.r1.bind = localhost
a1.sources.r1.port = 33333

a1.sources.r2.type = netcat
a1.sources.r2.bind = localhost
a1.sources.r2.port = 44444
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;Source r1&lt;/code&gt;定义为 Avro Source，监听 &lt;code&gt;http://localhost:33333&lt;/code&gt;，&lt;code&gt;Source r2&lt;/code&gt;定义为 NetCat Source；定义Channels 和 Sinks的方式跟 Sources类似；&lt;/p&gt;

&lt;p&gt;为Sources 和 Sinks 绑定 Channels，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 为sink绑定时，为channels
a1.sources.r1.channels = c1
a1.sources.r2.channels = c2
# 为sink绑定时，为channel
a1.sinks.k1.channel = c1
a1.sinks.k2.channel = c2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：其中 Sources绑定 Channels时，为 &lt;code&gt;&amp;lt;agent&amp;gt;.sources.&amp;lt;source&amp;gt;&lt;/code&gt;&lt;strong&gt;&lt;em&gt;&lt;code&gt;.channels&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt;；而 Sinks则为 &lt;code&gt;&amp;lt;agent&amp;gt;.sinks.&amp;lt;sink&amp;gt;&lt;/code&gt;&lt;strong&gt;&lt;em&gt;&lt;code&gt;.channel&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;h3&gt;3.1 启动 Agent&lt;/h3&gt;

&lt;p&gt;在 &lt;code&gt;flume-ng/conf&lt;/code&gt; 目录下新建一个 &lt;code&gt;mytest.conf&lt;/code&gt;做一个测试，内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 定义了一个agent( a1 ), 一个source( r1 ), 一个channel( c1 ), 一个sink( k1 )
a1.sources = r1
a1.sinks = k1
a1.channels = c1
# 定义source( r1 )为Netcat Source，监控localhost:44444
a1.sources.r1.type = netcat
a1.sources.r1.bind = localhost
a1.sources.r1.port = 44444

# 定义sink( k1 )为Logger Sink，将接收的数据显示到命令行
a1.sinks.k1.type = logger

# 用内存作为 channel 的缓存
a1.channels.c1.type = memory
a1.channels.c1.capacity = 1000
a1.channels.c1.transactionCapacity = 100

# 将source 和 sink 绑定到 channel
a1.sources.r1.channels = c1
a1.sinks.k1.channel = c1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 &lt;code&gt;~/tools/flume-ng&lt;/code&gt; 目录下执行如下命令启动 Agent ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bin/flume-ng agent -n a1 -c conf -f conf/mytest.conf -Dflume.root.logger=INFO,console
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bin/flume-ng agent --name a1 --conf conf --conf-file conf/mytest.conf -Dflume.root.logger=INFO,console
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-n&lt;/code&gt; 指定 Agent 名称&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-c&lt;/code&gt; 指定配置文件目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-f&lt;/code&gt; 指定配置文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Dflume.root.logger=INFO,console&lt;/code&gt; 设置日志等级&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;注：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-Dflume.root.logger=INFO,console&lt;/code&gt; 表示在控制台输出日志，用作测试或调试，真是生产缓存不用；&lt;/li&gt;
&lt;li&gt;使用logger，&lt;code&gt;flume-ng/conf&lt;/code&gt; 目录下必须有 &lt;code&gt;log4j.properties&lt;/code&gt; 项，否则会报错；&lt;/li&gt;
&lt;li&gt;在实际运行中，有时候就算 conf 目录下有 &lt;code&gt;log4j.properties&lt;/code&gt; 运行还是报错，如果你用的时第二条启动命令的话，换第一条启动命令试试；&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;在 Agent 成功启动后，新打开一个命令行，输入 &lt;code&gt;telnet localhost 44444&lt;/code&gt;,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ telnet localhost 44444
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
Hello World!
OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;控制台输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2015-04-28 11:50:23,091 (lifecycleSupervisor-1-0) [INFO - org.apache.flume.source.NetcatSource.start(NetcatSource.java:150)] Source starting
2015-04-28 11:50:23,150 (lifecycleSupervisor-1-0) [INFO - org.apache.flume.source.NetcatSource.start(NetcatSource.java:164)] Created serverSocket:sun.nio.ch.ServerSocketChannelImpl[/127.0.0.1:44444]
2015-04-28 11:51:57,185 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 48 65 6C 6C 6F 20 57 6F 72 6C 64 21 0D          Hello World!. }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果显示如上所示，则 Flume-NG 安装成功。&lt;/p&gt;

&lt;h3&gt;3.2 第三方插件&lt;/h3&gt;

&lt;h4&gt;plugins.d 目录&lt;/h4&gt;

&lt;p&gt;plugins.d 目录位于 &lt;code&gt;$FLUME_HOME/plugins.d&lt;/code&gt;，在flume-ng 启动的时候，flume-ng 启动脚本会遍历 plugins.d 目录中的插件，当通过 java 启动的时候将它们嵌入到合适的路径，其目录结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;plugins.d
|-  lib         插件的jar包
|-  libext      插件依赖的jar包
|-  native      必须的本地库，如：*.so文件

如：
plugins.d/
plugins.d/custom-source-1/
plugins.d/custom-source-1/lib/my-source.jar
plugins.d/custom-source-1/libext/spring-core-2.5.6.jar
plugins.d/custom-source-2/
plugins.d/custom-source-2/lib/custom.jar
plugins.d/custom-source-2/native/gettext.so
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;四、数据获取&lt;/h2&gt;

&lt;p&gt;Flume 支持大量从外部源获取数据的机制。&lt;/p&gt;

&lt;h3&gt;4.1 RPC&lt;/h3&gt;

&lt;p&gt;一个Flume中部署的 Avro 客户端，能够通过 avro RPC 机制，将一个指定的文件发送给 Flume 的 Avro Source：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ bin/flume-ng avro-client -H localhost -p 41414 -F /usr/logs/log.10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面所示命令将会把 &lt;code&gt;/usr/logs/log.10&lt;/code&gt; 文件的内容发送到 Flume Source 监听的端口上。&lt;/p&gt;

&lt;h3&gt;4.2 Executing commands&lt;/h3&gt;

&lt;p&gt;还有就是前面提及过的 Exec Source，通过执行一个指定的命令，将输出结果中的一行( 文本后跟回车&lt;code&gt;\r&lt;/code&gt;或换行符&lt;code&gt;\n&lt;/code&gt;，或两者同时出现 )，作为数据发送出去。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意：Flume 不支持 tail 作为一个Source，但可以通过在 exec source 中使用 tail 命令将文件转换为数据流。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;4.3 Network streams&lt;/h3&gt;

&lt;p&gt;Flume 支持下面的机制从常用的日志数据流类型中读取数据，例如：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Avro&lt;/li&gt;
&lt;li&gt;Thrift&lt;/li&gt;
&lt;li&gt;Syslog&lt;/li&gt;
&lt;li&gt;Netcat&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;下面可以启动一个 avro-client 客户端生产数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bin/flume-ng avro-client -c conf -H localhost -p 41414 -F /etc/passwd -Dflume.root.logger=DEBUG,console
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;五、配置多 Agent 数据流动&lt;/h2&gt;

&lt;p&gt;通过 Agent 的Avro Source 和Avro Sink 可以实现多个 Agent 之间的数据传输，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/multi-flow-by-avro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;agent foo 的配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# agent foo
foo.sources = r1
foo.channels = c1
foo.sinks = k1

foo.sources.r1.type = netcat
foo.sources.r1.bind = localhost
foo.sources.r1.port = 44444

foo.channels.c1.type = memory
foo.channels.c1.capacity = 1000
foo.channels.c1.transactionCapacity = 100

foo.sinks.k1.type = avro
foo.sinks.k1.hostname = localhost
foo.sinks.k1.port = 44445

foo.sources.r1.channels = c1
foo.sinks.k1.channel = c1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;agent bar 的配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# agent bar
bar.sources = r1
bar.channels = c1
bar.sinks = k1

bar.sources.r1.type = avro
bar.sources.r1.bind = localhost
bar.sources.r1.port = 44445

bar.channels.c1.type = memory
bar.channels.c1.capacity = 1000
bar.channels.c1.transactionCapacity = 100

bar.sinks.k1.type = logger

bar.sources.r1.channels = c1
bar.sinks.k1.channel = c1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：Avro Source 中指定ip地址的是&lt;code&gt;&amp;lt;agent&amp;gt;.sources.&amp;lt;source&amp;gt;.bind = ip&lt;/code&gt;，而 Avro Sink 则为&lt;code&gt;&amp;lt;agent&amp;gt;.sinks.&amp;lt;sink&amp;gt;.hostname = ip&lt;/code&gt;!&lt;/p&gt;

&lt;h3&gt;5.2 合并 Agent&lt;/h3&gt;

&lt;p&gt;在日志收集当中，一个非常常见的情况是：大量的客户端将产生的日志数据发送到少量的收集 Agent 上，这些 Agent 再将接收到的日志存储到链接的存储系统上。如：&lt;/p&gt;

&lt;p&gt;将数百台web servers 产生的日志发送到12个 Agent 上，然后写入到 HDFS 集群中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/consolidation.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图所示可以通过在 Flume 中配置3个使用 Avro Sink 的Agent，将3个节点都连接到一个 Avro Source的Agent( 同样的也可以使用 Thrift Sources/Sinks/Client来实现 )。图示 Agent4 收集接收到的 events，缓存到一个单一的 channel中，最后通过一个 sink将其中的数据发送到目的地( 如图所示的 HDFS )&lt;/p&gt;

&lt;h3&gt;5.3 多路 Agent&lt;/h3&gt;

&lt;p&gt;Flume 支持多路传输 event到一个或多个目的地。能够通过定义一个多选器( 能够通过路由，复制或选择的将一个Event发送到一个或多个 channels上 )来实现，其 Agent 结构如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/multiplexing.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这种模式，有两种方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一种是用来复制（Replication），Replication方式可以将最前端的数据源复制多份，分别传递到多个channel中，每个channel接收到的数据都是相同的，配置格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  # List the sources, sinks and channels for the agent
  replicatAgent.sources = r1
  replicatAgent.sinks = k1 k2 k3
  replicatAgent.channels = c1 c2 c3

  replicatAgent.sources.r1.type = netcat
  replicatAgent.sources.r1.bind = localhost
  replicatAgent.sources.r1.port = 44444
  replicatAgent.sources.r1.selector.type = replicating

  replicatAgent.sinks.k1.type = HDFS
  #...

  replicatAgent.sinks.k2.type = JMS
  #...

  replicatAgent.sinks.k3.type = avro
  #...

  # set channel for sinks
  replicatAgent.sinks.k1.channel = c1
  replicatAgent.sinks.k2.channel = c2
  replicatAgent.sinks.k3.channel = c3

  # set list of channels for source (separated by space)
  replicatAgent.sources.r1.channels = c1 c2 c3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面指定了 selector 的 type 的值为 replication，使用的Replication方式，&lt;code&gt;Source r1&lt;/code&gt;会将数据分别存储到 &lt;code&gt;Channel c1 c2 c3&lt;/code&gt;，这三个 channel 里面存储的数据是相同的，然后数据被传递到 &lt;code&gt;Sink k1 k2 k3&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;另一种是用来分流（Multiplexing），selector可以根据header的值来确定数据传递到哪一个channel，配置格式，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  multiplexAgent.sources = r1
  multiplexAgent.sinks = k1 k2 k3
  multiplexAgent.channels = c1 c2 c3

  # Mapping for multiplexing selector
  multiplexAgent.sources.r1.selector.type = multiplexing
  multiplexAgent.sources.r1.selector.header = state
  multiplexAgent.sources.r1.selector.mapping.CZ = c1
  multiplexAgent.sources.r1.selector.mapping.US = c1 c3
  multiplexAgent.sources.r1.selector.mapping.TW = c3
  #...

  multiplexAgent.sources.r1.selector.default = c2

  #... 其余配置不再给出
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;5.4 load_balance&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/flume-load-balance-agents.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Load balancing Sink Processor能够实现load balance功能，上图Agent1是一个路由节点，负责将Channel暂存的Event均衡到对应的多个Sink组件上，而每个Sink组件分别连接到一个独立的Agent上，示例配置，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a1.sinkgroups = g1
a1.sinkgroups.g1.sinks = k1 k2 k3
a1.sinkgroups.g1.processor.type = load_balance
a1.sinkgroups.g1.processor.backoff = true
a1.sinkgroups.g1.processor.selector = round_robin
a1.sinkgroups.g1.processor.selector.maxTimeOut=10000
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;5.5 failover&lt;/h3&gt;

&lt;p&gt;Failover Sink Processor能够实现failover功能，具体流程类似load balance，但是内部处理机制与load balance完全不同：Failover Sink Processor维护一个优先级Sink组件列表，只要有一个Sink组件可用，Event就被传递到下一个组件。如果一个Sink能够成功处理Event，则会加入到一个Pool中，否则会被移出Pool并计算失败次数，设置一个惩罚因子，示例配置如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a1.sinkgroups = g1
a1.sinkgroups.g1.sinks = k1 k2 k3
a1.sinkgroups.g1.processor.type = failover
a1.sinkgroups.g1.processor.priority.k1 = 5
a1.sinkgroups.g1.processor.priority.k2 = 7
a1.sinkgroups.g1.processor.priority.k3 = 6
a1.sinkgroups.g1.processor.maxpenalty = 20000
&lt;/code&gt;&lt;/pre&gt;

&lt;br&gt;


&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;未完待续。。。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>使用Jenkins搭建博客和Java源码管理的集成环境</title>
   <link href="http://www.blogways.net/blog/2014/10/08/Jenkins-Blogways-Maven.html"/>
   <updated>2014-10-08T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/10/08/Jenkins-Blogways-Maven</id>
   <content type="html">&lt;h2&gt;一、 概述&lt;/h2&gt;

&lt;p&gt;在搭建博客系统的集成环境时，需要用到的有Jenkins、git和jekyll运行环境，本博客有相关的安装教程：&lt;/p&gt;

&lt;p&gt;1、&lt;strong&gt;&lt;em&gt;Jenkins安装&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://www.blogways.net/blog/2013/04/17/jenkins-git-maven-junit.html
http://www.blogways.net/blog/2013/04/23/jenkins-git-maven-junit-2.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、&lt;strong&gt;&lt;em&gt;git服务器部署及使用&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://wanzhou.github.io/blog/2013/04/13/git.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3、&lt;strong&gt;&lt;em&gt;Windows和MAC OS X下安装jekyll&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://www.blogways.net/categories/jekyll/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是关于博客系统的运行环境搭建，由于我是在服务器上搭建集成环境，本身并没有ruby环境，需要自己去安装，因而说一下ruby和gem的安装。&lt;/p&gt;

&lt;h2&gt;二、 ruby、gem安装&lt;/h2&gt;

&lt;p&gt;因为jekyll是的ruby语言编写的，需要ruby运行环境！&lt;/p&gt;

&lt;p&gt;1、&lt;strong&gt;&lt;em&gt;安装ruby&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先，去ruby官网下载离线安装包，我下载的是&lt;code&gt;ruby-2.1.3.tar.gz&lt;/code&gt;，然后运行如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ruby-2.1.3.tar.gz目录 (如：cd /Users/xxx/Downloads)
tar -xzvf ruby-2.1.3.tar.gz
cd ruby-2.1.3
./configure --prefix=安装ruby的目录 (如：/Users/xxx/App/ruby)
make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装好以后，修改操作系统的PATH路径，一般是修改&lt;code&gt;~/.bashrc&lt;/code&gt;或者&lt;code&gt;~/.bash_profile&lt;/code&gt;文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RUBY_HOME=/Users/xxx/App/ruby  (安装ruby的目录)
export RUBY_HOME
PTAH=$RUBY_HOME/bin:$PATH
export PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、&lt;strong&gt;&lt;em&gt;安装ruby&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;同样，首先下载rubygem安装文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://rubygems.org/pages/download/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中有很多种安装文件，按照自己的需求去下载，我下载的是&lt;code&gt;rubygems-2.4.1.tgz&lt;/code&gt;，然后运行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd rubygems-2.4.1.tgz目录
tar -xzvf rubygems-2.4.1.tgz
cd rubygems-2.4.1
ruby setup.rb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到此，ruby和gem安装完成了，后面需要安装jekyll时，只要运行命令&lt;code&gt;gem install jekyll&lt;/code&gt;即可。&lt;/p&gt;

&lt;h2&gt;三、 博客集成系统核心实现&lt;/h2&gt;

&lt;p&gt;1、jenkins任务创建，详情可以参考前面给出的网站。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;新建一个jenkins任务，按如下设置，并确定！&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;/images/post/blogtest.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;设置源码管理，第一个框中填仓库路径(远程仓库和本地仓库都可以)，如：&lt;code&gt;/home/git/blogtestgit&lt;/code&gt;；第二个框填构建的分支，一般为&lt;code&gt;master&lt;/code&gt;，可以直接填master也可以像下图所示填写：&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;/images/post/jkgit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;填写触发条件，此处为每天的12时和20时触发，&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;/images/post/blog-trigger.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;编写构建步骤，&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;/images/post/blog-build.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2、最主要的就是通过&lt;code&gt;Execute shell&lt;/code&gt;来实现博客系统的创建和发布：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bash /home/spdev/tools/jenkins.shell.scripts/deployjekyll.sh $WORKSPACE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/blogtest.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在该&lt;code&gt;.sh&lt;/code&gt;文件中的命令如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jekyll_pid=$(ps aux | grep 'jekyll' | grep -v 'grep' | awk '{print $2}')

[ -z &quot;$jekyll_pid&quot; ] 

if [ &quot;$(echo $?)&quot; == &quot;1&quot; ] ; then
    echo &quot;-------------------------------------&quot;
    kill -9 $jekyll_pid
    echo &quot;-- Log: -- Kill Previous Jekyll Serve successfully! --&quot;
    echo &quot;-------------------------------------&quot;
fi

BUILD_ID=dontKillMe /usr/bin/jekyll serve --detach &amp;amp;

if [ &quot;$(echo $?)&quot; != &quot;0&quot; ] ; then
    echo &quot;-------------------------------------&quot;
    echo &quot;-- Log: -- An Exception Has Happened In The Source ! --&quot;
    echo &quot;-------------------------------------&quot;
    exit 1
else
    echo &quot;-------------------------------------&quot;
    echo &quot;-- Log: -- Update The Blogways ! --&quot;
    echo &quot;-------------------------------------&quot;
    exit 0
fi
exit 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1、首先，判断包含&lt;code&gt;jekyll&lt;/code&gt;的进程( 即博客的发布经常 )是否存在，若存在则结束此进程；&lt;/p&gt;

&lt;p&gt;2、然后，运行&lt;code&gt;jekyll serve --detach&lt;/code&gt;，生成新的博客文件，并发布到&lt;code&gt;4000&lt;/code&gt;端口，如果是在服务器上运行，那么就能在相应的端口访问博客，如&lt;code&gt;http://192.168.11.34:4000/&lt;/code&gt;或&lt;code&gt;http://localhost:4000/&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;3、最后，监听上条语句，即&lt;code&gt;jekyll serve --detach&lt;/code&gt;执行成功与否，若执行成功，则说明此处生成并发布新博客成功，以&lt;code&gt;exit 0&lt;/code&gt;正常退出，告诉jenkins此次构建成功；否则说明生成或发布失败，以&lt;code&gt;exit 1&lt;/code&gt;异常退出，告诉jenkins此次构建失败。&lt;/p&gt;

&lt;h2&gt;四、 Java源码编译测试集成系统&lt;/h2&gt;

&lt;p&gt;java源码的编译、测试及发布等，都是通过maven来实现的，因此需要maven环境，关于maven的使用可以参考：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://www.blogways.net/blog/2013/04/23/maven.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;jenkins提供了maven插件，一般都是默认安装的，java源码开发的集成系统的核心实现跟博客稍有区别，它及可以通过&lt;code&gt;Execute shell&lt;/code&gt;来实现，也可以通过jenkins的maven插件来实现。&lt;/p&gt;

&lt;p&gt;1、&lt;strong&gt;&lt;em&gt;Execute shell&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果没有特殊的要求，一条语句就能完成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mvn install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如下图所示，图示显示的设置等同于&lt;code&gt;mvn package&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/maven-package.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;运行该命令后，会自动的完成编译、测试、打包、安装(安装到本地mavne库)等操作，如有任何一个阶段运行失败，就会结束运行，并告诉jenkins运行失败，jenkins会处理信息，按照设置的邮箱发送给最近代码提交者，代码有BUG。&lt;/p&gt;

&lt;p&gt;2、&lt;strong&gt;&lt;em&gt;maven插件&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;只需要在&lt;code&gt;配置 -&amp;gt; Build -&amp;gt; Goals and options&lt;/code&gt;项中，添加&lt;code&gt;install&lt;/code&gt;即可完成跟&lt;code&gt;Execute shell&lt;/code&gt;相同的功能。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bash /home/spdev/tools/jenkins.shell.scripts/mavenjava.sh $WORKSPACE
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>Java项目代码编写规范</title>
   <link href="http://www.blogways.net/blog/2014/09/17/checkStyle.html"/>
   <updated>2014-09-17T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/09/17/checkStyle</id>
   <content type="html">&lt;h2&gt;一、Checkclipse插件安装&lt;/h2&gt;

&lt;p&gt;Checkclipse是一个Eclipse插件，它集成了Checkstyle的样式检查器的编码准则到Eclipse中。所有的Java风格的违规行为将被立即报告错误标记。可以为每个项目单独配置编码准则。&lt;/p&gt;

&lt;p&gt;1、下载checkclipse jar 包文件&lt;a href=&quot;http://sourceforge.jp/projects/sfnet_checkclipse/&quot; title=&quot;checkclipse.jar&quot;&gt;http://sourceforge.jp/projects/sfnet_checkclipse/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、安装Checkclipse&lt;/p&gt;

&lt;p&gt;这里我通过Help-&gt;Software Updates-&gt;Find and Insta方式安装了好几次没有成功，最终选择下载插件jar包方式安装，我下载的是上面链接打开后列表中的de.mvmsoft.checkclipse_3.0.0.b201310301757.jar，下载后将jar包放到Eclipse安装目录plugins目录下，重新启动Eclipse在Windows—&gt;preferences下找到checkclipse，如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/checkclipse.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;二、 配置eclipse-java-google-style.xml&lt;/h2&gt;

&lt;p&gt;这里eclipse-java-google-style.xml对Google原始Eclipse Formatter文件进行了部分修改，所以大家不要下载Google原始文件，就用本文提供的eclipse-java-google-style.xml。&lt;/p&gt;

&lt;p&gt;1、eclipse-java-google-style.xml内容：&lt;a href=&quot;/xml/eclipse-java-google-style.xml&quot; title=&quot;eclipse-java-google-style.xml&quot;&gt;eclipse-java-google-style.xml&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、配置eclipse-java-google-style.xml到Eclipse中&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/eclipse-java-google-style.xml.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;三、 配置Java默认生成模板&lt;/h2&gt;

&lt;p&gt;1、在Windows-&gt;preferences-&gt;Java-&gt;Code Style-&gt;Code Templates下新增文件默认生成模板：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/JavaFileTemplate.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2、新建Java类时选择Generater comments&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/testTemplate.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;四、 checkStyle文件编写及配置&lt;/h2&gt;

&lt;h3&gt;1、checkStyle文件编写&lt;/h3&gt;

&lt;p&gt;这里提供已经编写好的文件，内容&lt;a href=&quot;/xml/checkstyle.xml&quot; title=&quot;checkstyle.xml&quot;&gt;checkstyle.xml&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;2、checkStyle文件配置&lt;/h3&gt;

&lt;p&gt;a、Checkclipse配置&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/checkclispeSet.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;勾选Set Project Dir as Checkjstyle Basedir，CheckStyle Configuration File选择上面编写的checkStyle.xml文件&lt;/p&gt;

&lt;p&gt;b、选择你要进行checkstyle的项目文件，选择Project-&gt;properties&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/CheckProject.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;勾选Enable CheckStyle、Set Project ClassLoader。&lt;/p&gt;

&lt;p&gt;c、ok，可以进行Java代码编写了，此时如果没有按照checkStyle.xml里配置的规范要求编写代码，Eclipse中将给出错误提示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/CheckStyleTest.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;四、 checkStyle Maven 插件使用&lt;/h2&gt;

&lt;p&gt;checkStyle的maven插件名为maven-checkstyle-plugin，用于执行CheckStyle task，以下列出具体使用方法：&lt;/p&gt;

&lt;h3&gt;1、maven pom 文件配置&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;build&amp;gt;
  &amp;lt;plugins&amp;gt;
      &amp;lt;plugin&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;maven-checkstyle-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.10&amp;lt;/version&amp;gt;
        &amp;lt;configuration&amp;gt;
            &amp;lt;configLocation&amp;gt;D:\codingStandards\checkstyle.xml&amp;lt;/configLocation&amp;gt;
        &amp;lt;/configuration&amp;gt;
        &amp;lt;executions&amp;gt;
            &amp;lt;execution&amp;gt;
                &amp;lt;id&amp;gt;checkstyle&amp;lt;/id&amp;gt;
                &amp;lt;phase&amp;gt;validate&amp;lt;/phase&amp;gt;
                &amp;lt;goals&amp;gt;
                    &amp;lt;goal&amp;gt;check&amp;lt;/goal&amp;gt;
                &amp;lt;/goals&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;failOnViolation&amp;gt;true&amp;lt;/failOnViolation&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/execution&amp;gt;
        &amp;lt;/executions&amp;gt;
      &amp;lt;/plugin&amp;gt;
   &amp;lt;/plugins&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   &lt;/build&gt;&lt;/p&gt;

&lt;p&gt;其中D:\codingStandards\checkstyle.xml即为上面我们编写的checkstyle规范文件&lt;/p&gt;

&lt;h3&gt;2、运行checkstyle检查&lt;/h3&gt;

&lt;p&gt;命令行下执行mvn checkstyle:checkstyle 或直接通过Eclipse插件中 Maven test等执行方法，我用的Maven test&lt;/p&gt;

&lt;h3&gt;3、检查checkstyle结果&lt;/h3&gt;

&lt;p&gt;运行maven命令后可以在console里查看checkstyle运行结果。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 22.926s
[INFO] Finished at: Thu Sep 18 09:28:04 CST 2014
[INFO] Final Memory: 5M/9M
[INFO] ------------------------------------------------------------------------
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-checkstyle-plugin:2.10:check 

(checkstyle) on project maven-script-test: You have 1 Checkstyle violation. -&amp;gt; [Help 1]
[ERROR] 
[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.
[ERROR] Re-run Maven using the -X switch to enable full debug logging.
[ERROR] 
[ERROR] For more information about the errors and possible solutions, please read the following articles:
[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;checkstye的详细结果信息被存放在target/checkstyle-result.xml中。下面是具体信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;checkstyle version=&quot;5.6&quot;&amp;gt;
&amp;lt;file name=&quot;D:\workspace\maven-script-test\src\main\java\javassisttest\Test1.java&quot;&amp;gt;
&amp;lt;error line=&quot;22&quot; severity=&quot;error&quot; message=&quot;Line is longer than 120 characters (found 124).&quot;  source=&quot;

com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck&quot;/&amp;gt;
&amp;lt;/file&amp;gt;
&amp;lt;file name=&quot;D:\workspace\maven-script-test\src\main\java\mveltest\GetNameTest.java&quot;&amp;gt;
&amp;lt;/file&amp;gt;
&amp;lt;file name=&quot;D:\workspace\maven-script-test\src\main\java\mveltest\MvelTest.java&quot;&amp;gt;
&amp;lt;error line=&quot;9&quot; severity=&quot;warning&quot; message=&quot;Wrong order for &amp;amp;apos;org.mvel2.MVEL&amp;amp;apos; import.&quot;  source=

&quot;com.puppycrawl.tools.checkstyle.checks.imports.ImportOrderCheck&quot;/&amp;gt;
&amp;lt;/file&amp;gt;
&amp;lt;/checkstyle&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从中我们可以看出 Test1.java 22行有一个行字符数超过120的错误，MvelTest.java 9行有个提示。&lt;/p&gt;

&lt;h3&gt;4、对指定文件不检查&lt;/h3&gt;

&lt;p&gt;对上面例子中行超过了120字符。如果我们不想修复这个错误怎么办那？可以将其suppress掉。
方法是建立一个checkstyle-suppressions.xml文件。其中加入下述内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;

&amp;lt;!DOCTYPE suppressions PUBLIC
        &quot;-//Puppy Crawl//DTD Suppressions 1.0//EN&quot;
        &quot;http://www.puppycrawl.com/dtds/suppressions_1_0.dtd&quot;&amp;gt;

&amp;lt;suppressions&amp;gt;
    &amp;lt;suppress checks=&quot;LineLengthCheck&quot;
              files=&quot;Test1.java&quot;
              /&amp;gt;
&amp;lt;/suppressions&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在pom文件&lt;configuration&gt;节点内checkstyle.xml配置下面加入checkstyle-suppressions.xml配置，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;configuration&amp;gt;
    &amp;lt;configLocation&amp;gt;D:\codingStandards\checkstyle.xml&amp;lt;/configLocation&amp;gt;
    &amp;lt;suppressionsLocation&amp;gt;D:\codingStandards\checkstyle-suppressions.xml&amp;lt;/suppressionsLocation&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在再运行看看：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[INFO] --- maven-surefire-plugin:2.10:test (default-test) @ maven-script-test ---
[INFO] Surefire report directory: D:\workspace\maven-script-test\target\surefire-reports

-------------------------------------------------------
 T E S T S
-------------------------------------------------------

Results :

Tests run: 0, Failures: 0, Errors: 0, Skipped: 0

[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 3.956s
[INFO] Finished at: Thu Sep 18 10:08:12 CST 2014
[INFO] Final Memory: 6M/11M
[INFO] ------------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK！运行没有异常了，刚刚的行限制被跳过了。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>java 动态脚本之groovy、mvel and javascript</title>
   <link href="http://www.blogways.net/blog/2014/09/15/groovy-mvel-javascript.html"/>
   <updated>2014-09-15T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/09/15/groovy-mvel-javascript</id>
   <content type="html">&lt;h2&gt;一、groovy&lt;/h2&gt;

&lt;h3&gt;. groovy介绍&lt;/h3&gt;

&lt;p&gt;Groovy 是 用于Java虚拟机的一种敏捷的动态语言，它是一种成熟的面向对象编程语言，既可以用于面向对象编程，又可以用作纯粹的脚本语言。使用该种语言不必编写过多的代码，同时又具有闭包和动态语言中的其他特性。&lt;/p&gt;

&lt;p&gt;Groovy是JVM的一个替代语言（替代是指可以用 Groovy 在Java平台上进行 Java 编程），使用方式基本与使用 Java代码的方式相同，该语言特别适合与Spring的动态语言支持一起使用，设计时充分考虑了Java集成，这使 Groovy 与 Java 代码的互操作很容易。（注意：不是指Groovy替代java，而是指Groovy和java很好的结合编程。&lt;/p&gt;

&lt;h3&gt;. groovy语法&lt;/h3&gt;

&lt;p&gt;groovy语法和java语法类似，具体请参阅&lt;a href=&quot;http://beta.groovy-lang.org/docs/groovy-2.3.1/html/documentation/&quot; title=&quot;官方文档&quot;&gt;http://beta.groovy-lang.org/docs/groovy-2.3.1/html/documentation/&lt;/a&gt;，这里不做介绍。&lt;/p&gt;

&lt;h3&gt;. java中使用groovy&lt;/h3&gt;

&lt;p&gt;Java中调用Groovy情况：&lt;/p&gt;

&lt;p&gt;1、Eval&lt;/p&gt;

&lt;p&gt;Eval很容易的通过me方法执行一段逻辑，但是Eval不支持多行逻辑，并且没有对执行的script脚本缓存，效率非常低。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;System.out.println(&quot;Eval begin:&quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).
                format(new Date()));
for (int i = 0; i &amp;lt; 1000; i++) {
    Eval.xy(i, i + 1, &quot;x*y&quot;);
}
System.out.println(&quot;Eval end:&quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).
                format(new Date()));

输出：
    Eval begin:2014-09-17 14:36:43:218
    Eval end:  2014-09-17 14:36:52:203
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、GroovyShell:&lt;/p&gt;

&lt;p&gt;GroovyShell支持简单脚本及Groovy文件的解析执行， GroovyShell支持script脚本的缓存，执行效率相对Eval高多了（下面例子100000次循环比Eval1000次循环还快），但要注意GroovyShell中shell.parse解析脚本程序不能放在大循环中或被频繁的调用，否则会大大降低性能，并且还有PermGen space异常风险。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;System.out.println(&quot;GroovyShell begin:&quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));

Binding binding = new Binding();
GroovyShell shell = new GroovyShell(binding);    
Script  script = shell.parse(&quot;def mul(x, y) { return x * y }\n mul(x1, y1)&quot;);  
for (int i = 0; i &amp;lt; 100000; i++) {               
    binding.setProperty(&quot;x1&quot;, i);
    binding.setProperty(&quot;y1&quot;, i + 1);
    script.run();
}
System.out.println(&quot;GroovyShell end:&quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));

输出：
    GroovyShell begin:2014-09-17 15:50:04:945
    GroovyShell end:2014-09-17 15:50:06:389
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3、GroovyClassLoader:适用于复杂逻辑的整个groovy文件，这里引入了Groovy2.0新增的静态编译，效率有进一步提升。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;System.out.println(&quot;GroovyClassLoader begin &quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));

GroovyClassLoader loader = new GroovyClassLoader();
Class groovyClass = loader.parseClass(new File(&quot;src/extendTest/Test.groovy&quot;));

GroovyObject object = (GroovyObject) groovyClass.newInstance();
for (int i = 0; i &amp;lt; 100000; i++) {  
    object.invokeMethod(&quot;num&quot;, new int[]{i, i + 1});
}

System.out.println(&quot;GroovyClassLoader end&quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));

输出：
    GroovyClassLoader begin 2014-09-17 16:23:06:156
    GroovyClassLoader end   2014-09-17 16:23:06:411
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4、GroovyScriptEngine：GroovyScriptEngine类似GroovyShell，但存在互关联的多个脚本时，使用GroovyScriptEngine会更好些，但是GroovyScriptEngine效率也不理想。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;System.out.println(&quot;SimpleScript begin:&quot;+ new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));
for (int i = 0; i &amp;lt; 100000; i++) {
    binding1.setVariable(&quot;x&quot;, i);
    binding1.setVariable(&quot;y&quot;, i + 1);
    engine.run(&quot;src/extendTest/SimpleScript.groovy&quot;, binding1);
}
System.out.println(&quot;SimpleScript end:&quot;+ new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));

输出：
    SimpleScript begin:2014-09-17 18:48:48:506
    SimpleScript end:2014-09-17 18:49:13:796
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5、Bean Scripting Framework：Bean Scripting Framework是一组Java Classes提供了在Java应用程序内对脚本语言的支持，通过脚本语言可以访问java的对象和方法，Groovy的BSF引擎是继承org.codehaus.groovy.bsf.GroovyEngine，其效率也达不到GroovyClassLoader效率，这里不做实例分析。&lt;/p&gt;

&lt;p&gt;6、JSR 223是Java 6提供的一种从Java内部执行脚本编写语言的方便、标准的方式，并提供从脚本内部访问Java 资源和类的功能。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;System.out.println(&quot;JSR 223 begin:&quot;+ new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));

ScriptEngineManager factory = new ScriptEngineManager();
ScriptEngine engine1 = factory.getEngineByName(&quot;groovy&quot;);
String testScript = &quot;def num(int[] a) {return  a[0] * a[1]}&quot;;  
engine1.eval(testScript);  
Invocable inv = (Invocable) engine1; 
for (int i = 0; i &amp;lt; 100000; i++) {
    inv.invokeFunction(&quot;num&quot;,  new int[]{i, i + 1});  
}

System.out.println(&quot;JSR 223 end:&quot;+ new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));

输出：

    JSR 223 begin:2014-09-17 18:55:10:665
    JSR 223 end:2014-09-17 18:55:10:716
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上一个简单的乘法运算测试发现JSR 223的效率比GroovyClassLoader要高。怀疑是不是GroovyClassLoader加载Groovy文件及编译文件耗时比较长，将开始打印日志移至for循环上面一行，同时将JSR 223测试代码打印日志也移至for循环上面一行，测试后发现JSR 223效率任然高于GroovyClassLoader，于是将JSR 223测试程序改读取Groovy文件，并使用Groovy静态编译，效率降低，稍高于GroovyClassLoader方式（GroovyClassLoader不读取文件方式高于GroovyClassLoader读取文件，稍低于JSR 223不读取文件方式）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ScriptEngineManager factory = new ScriptEngineManager();
ScriptEngine engine1 = factory.getEngineByName(&quot;groovy&quot;);
//String testScript = &quot;def num(int[] a) {return  a[0] * a[1]}&quot;;  
engine1.eval(new FileReader(&quot;D:/workspace/extendTest/src/extendTest/Test.groovy&quot;));
//engine1.eval(testScript);  
Invocable inv = (Invocable) engine1; 
System.out.println(&quot;JSR 223 begin:&quot;+ new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));
for (int i = 0; i &amp;lt; 100000; i++) {
    inv.invokeFunction(&quot;num&quot;,  new int[]{i, i + 1});  
}

System.out.println(&quot;JSR 223 end:&quot;+ new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));

输出：
    JSR 223 begin:2014-09-17 18:49:13:847
    JSR 223 end:2014-09-17 18:49:13:969
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：虽然JSR 223调用方式性能大大提升，但是其性能与java相比还相差很多，以上简单的乘法运算，用java实现，100000次循环仅仅需5毫秒，所以对于实时性要求很高的功能，Groovy并不合适。&lt;/p&gt;

&lt;h2&gt;二、MVEL&lt;/h2&gt;

&lt;h3&gt;. MVEL介绍&lt;/h3&gt;

&lt;p&gt;MVEL为 MVFLEX Expression Language（MVFLEX表达式语言）的缩写，它是一种动态/静态的可嵌入的表达式语言和为Java平台提供Runtime（运行时）的语言。最初是作为一个应用程序框架实用程序的语言开始，该项目现已发展完全独立。MVEL通常用于执行用户（程序员）通过配置XML文件或注释等定义的基本逻辑。它也可以用来解析简单的JavaBean表达式。Runtime（运行时）允许MVEL表达式通过解释执行或者预编译生成字节码后执行。&lt;/p&gt;

&lt;h3&gt;. MVEL语法&lt;/h3&gt;

&lt;p&gt;MVEL语法具体请参阅 &lt;a href=&quot;http://mvel.codehaus.org/Language+Guide+for+2.0&quot; title=&quot;MVEL&quot;&gt;http://mvel.codehaus.org/Language+Guide+for+2.0&lt;/a&gt;，这里不做介绍。&lt;/p&gt;

&lt;h3&gt;. java中使用MVEL&lt;/h3&gt;

&lt;p&gt;Java中调用MVEL情况：&lt;/p&gt;

&lt;p&gt;1、解释执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;System.out.println(&quot;interpreted begin:&quot;+ new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));

Map&amp;lt;String, Object&amp;gt; params = new HashMap&amp;lt;String, Object&amp;gt;();  

for (int i = 0; i &amp;lt; 100000; i++) {
    params.put(&quot;x&quot;, i);  
    params.put(&quot;y&quot;, i + 1);  
    MVEL.eval(&quot;x*y&quot;, params);  
}
System.out.println(&quot;interpreted end:&quot;+ new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));

输出：

    interpreted  begin:2014-09-18 10:54:01:162
    interpreted  end:2014-09-18 10:54:01:879
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、编译后执行（加快执行）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;System.out.println(&quot;compiled begin:&quot;+ new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));

ExpressionCompiler compiler = new ExpressionCompiler(&quot;x * y&quot;);  
CompiledExpression exp = compiler.compile();  
Map&amp;lt;String, Object&amp;gt; params1 = new HashMap&amp;lt;String, Object&amp;gt;();  

for (int i = 0; i &amp;lt; 100000; i++) {
    params.put(&quot;x&quot;, i);  
    params.put(&quot;y&quot;, i + 1);  
    MVEL.executeExpression(exp, params);  

}
System.out.println(&quot;compiled end:&quot;+ new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));

输出：

    compiled begin:2014-09-18 10:57:50:471
    compiled end:2014-09-18 10:57:50:632
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上执行结果看出，编译后执行效率明显高于解释执行。&lt;/p&gt;

&lt;h2&gt;三、Groovy、MVEL、javascript 调用性能分析&lt;/h2&gt;

&lt;p&gt;1、java中调用javascript测试：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ScriptEngineManager manager = new ScriptEngineManager();
ScriptEngine engine = manager.getEngineByName(&quot;javascript&quot;); 

String str = &quot;function num (x,y) { return x*y }&quot;;   
try {
    engine.eval(str);
} catch (ScriptException e) {
    e.printStackTrace();
}   
Invocable invoke = (Invocable) engine;
System.out.println(&quot;javascript begin:&quot;+ new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));

try {
    for (int i = 0; i &amp;lt; 100000; i++) {
        invoke.invokeFunction(&quot;num&quot;, i, i + 1);
    }
} catch (ScriptException e) {
    e.printStackTrace();
} catch (NoSuchMethodException e) {
    e.printStackTrace();
}
System.out.println(&quot;javascript end:&quot;+ new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date())); 

输出：

    javascript begin:2014-09-18 11:28:11:661
    javascript end:2014-09-18 11:28:16:348
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、性能分析&lt;/p&gt;

&lt;p&gt;从以上对Java中调用Groovy、MVEL、javascript实现的一个简单的乘法运算100000次循环的结果来看：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Groovy JSR 223调用方式：51毫秒
MVEL编译后执行：161毫秒
javascript调用：4秒多
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MVEL官网给出性能报告显示MVEL性能高于Groovy，不知道其什么数据测试场景，看官网报告测试的Groovy版本是1.5.7，低于本文测试的Groovy2.0版，从Groovy1.6开始才开始引入Cache功能，并且到了2.0才加入静态编译，所以MVEL官网的测试报告我觉得已经不能够正确说明Groovy的实际性能，至少从本文例子中看出Groovy2.0性能是明显优于MVEL2.2的。&lt;/p&gt;

&lt;h2&gt;四、总结&lt;/h2&gt;

&lt;p&gt;动态语言给我们实际编程中带来很多方便，比如常用的规则引擎，然而性能与功能不能同时得到满足，从本文测试中看出无论是Groovy还是MVEL都是实现动态逻辑配置的不错选择，但是遇到高实时性需求时，可能两者就不是特别适合，因为两者的性能与Java本身相比还是有数倍的差距。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Jquery Source Analysis Ajax(2)</title>
   <link href="http://www.blogways.net/blog/2014/08/27/jQuery-source-analysis-ajax%282%29.html"/>
   <updated>2014-08-27T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/08/27/jQuery-source-analysis-ajax(2)</id>
   <content type="html">&lt;h2&gt;四、Ajax示例&lt;/h2&gt;

&lt;p&gt;前面已经对ajax的源码结构和API有了一些介绍，下面就介绍一些ajax方法的应用；&lt;/p&gt;

&lt;p&gt;前面已经介绍过了，Ajax中最最核心的方法就是&lt;code&gt;$.ajax( url, options )&lt;/code&gt;，其它的方法都是在这个方法的基础上修改options参数实现的，下面来看一下ajax支持的options参数：&lt;/p&gt;

&lt;table width='100%'&gt;

    &lt;tr&gt;&lt;th width='15%'&gt;参数名&lt;/th&gt;&lt;th width='10%'&gt;类型&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;
    
    &lt;tr&gt;&lt;td&gt;url&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;发送请求的地址(默认值: 当前页地址)。&lt;/td&gt;&lt;/tr&gt;

    &lt;tr&gt;&lt;td&gt;type&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;请求方式 (&quot;POST&quot; 或 &quot;GET&quot;)， 默认为 &quot;GET&quot;。注意：其它 HTTP 请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持&lt;/td&gt;&lt;/tr&gt;
    
    &lt;tr&gt;&lt;td&gt;global&lt;/td&gt;&lt;td&gt;Boolean&lt;/td&gt;&lt;td&gt;是否触发全局 AJAX 事件(默认: true)。设置为 false 将不会触发全局 AJAX 事件，如 ajaxStart 或 ajaxStop 。可用于控制不同的Ajax事件&lt;/td&gt;&lt;/tr&gt;
    
    &lt;tr&gt;&lt;td&gt;processData&lt;/td&gt;&lt;td&gt;Boolean&lt;/td&gt;&lt;td&gt;(默认: true) 默认情况下，发送的数据将被转换为对象(技术上讲并非字符串) 以配合默认内容类型 &quot;application/x-www-form-urlencoded&quot;。如果要发送 DOM 树信息或其它不希望转换的信息，请设置为 false。&lt;/td&gt;&lt;/tr&gt;
    
    &lt;tr&gt;&lt;td&gt;async&lt;/td&gt;&lt;td&gt;Boolean&lt;/td&gt;&lt;td&gt;默认值: true。默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。
注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。&lt;/td&gt;&lt;/tr&gt;
    
    &lt;tr&gt;&lt;td&gt;contentType&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;发送信息至服务器时内容编码类型(默认值: &quot;application/x-www-form-urlencoded&quot;)&lt;/td&gt;&lt;/tr&gt;
    
    &lt;tr&gt;&lt;td&gt;timeout&lt;/td&gt;&lt;td&gt;Number&lt;/td&gt;&lt;td&gt;设置请求超时时间（毫秒），此设置将覆盖全局设置&lt;/td&gt;&lt;/tr&gt;
    
    &lt;tr&gt;&lt;td&gt;data&lt;/td&gt;&lt;td&gt;Object&lt;/br&gt;String&lt;/td&gt;&lt;td&gt;发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL 后。查看 processData 选项说明以禁止此自动转换。必须为 Key/Value 格式。如果为数组，jQuery 将自动为不同值对应同一个名称。如 {foo:[&quot;bar1&quot;, &quot;bar2&quot;]} 转换为 '&amp;foo=bar1&amp;foo=bar2'。&lt;/td&gt;&lt;/tr&gt;
    
    &lt;tr&gt;&lt;td&gt;dataType&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;预期服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包 MIME 信息返回 responseXML 或 responseText，并作为回调函数参数传递，可用值:&lt;/br&gt;&quot;xml&quot;: 返回 XML 文档，可用 jQuery 处理；&lt;/br&gt;&quot;html&quot;: 返回纯文本 HTML 信息；包含 script 元素；&lt;/br&gt;&quot;script&quot;: 返回纯文本 JavaScript 代码。不会自动缓存结果。；&lt;/br&gt;&quot;json&quot;: 返回 JSON 数据 ；&lt;/br&gt;&quot;jsonp&quot;: JSONP 格式，使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。&lt;/td&gt;&lt;/tr&gt;
    
    &lt;tr&gt;&lt;td&gt;username&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;用于响应 HTTP 访问认证请求的用户名&lt;/td&gt;&lt;/tr&gt;
    
    &lt;tr&gt;&lt;td&gt;password&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;用于响应 HTTP 访问认证请求的密码&lt;/td&gt;&lt;/tr&gt;
    
    &lt;tr&gt;&lt;td&gt;cache&lt;/td&gt;&lt;td&gt;Boolean&lt;/td&gt;&lt;td&gt;dataType 为 script 和 jsonp 时默认为 false；设置为 false 将不缓存此页面&lt;/td&gt;&lt;/tr&gt;
    
    &lt;tr&gt;&lt;td&gt;traditional&lt;/td&gt;&lt;td&gt;Boolean&lt;/td&gt;&lt;td&gt;如果你想要用传统的方式来序列化数据，那么就设置为 true&lt;/td&gt;&lt;/tr&gt;
    
    &lt;tr&gt;&lt;td&gt;beforeSend&lt;/td&gt;&lt;td&gt;Function&lt;/td&gt;&lt;td&gt;发送请求前可修改 XMLHttpRequest 对象的函数，如添加自定义 HTTP 头；&lt;/br&gt;beforeSend(XMLHttpRequest) &lt;/td&gt;&lt;/tr&gt;
    
    &lt;tr&gt;&lt;td&gt;complete&lt;/td&gt;&lt;td&gt;Function&lt;/td&gt;&lt;td&gt;请求完成后回调函数 (请求成功或失败时均调用)。参数： XMLHttpRequest 对象，成功信息字符串；&lt;/br&gt;complete(XMLHttpRequest, textStatus)&lt;/td&gt;&lt;/tr&gt;
    
    &lt;tr&gt;&lt;td&gt;error&lt;/td&gt;&lt;td&gt;Function&lt;/td&gt;&lt;td&gt;请求失败时将调用此方法。这个方法有三个参数：XMLHttpRequest 对象，错误信息，（可能）捕获的错误对象；&lt;/br&gt;
error(XMLHttpRequest, textStatus, errorThrown)&lt;/td&gt;&lt;/tr&gt;

    &lt;tr&gt;&lt;td&gt;success&lt;/td&gt;&lt;td&gt;Function&lt;/td&gt;&lt;td&gt;请求成功后回调函数。这个方法有两个参数：服务器返回数据，返回状态&lt;/br&gt;
success(data, textStatus) &lt;/td&gt;&lt;/tr&gt;

    &lt;tr&gt;&lt;td&gt;xhr&lt;/td&gt;&lt;td&gt;Function&lt;/td&gt;&lt;td&gt;需要返回一个 XMLHttpRequest 对象，默认在 IE 下是 ActiveXObject 而其他情况下是 XMLHttpRequest 。用于重写或者提供一个增强的 XMLHttpRequest 对象&lt;/td&gt;&lt;/tr&gt;

&lt;/table&gt;


&lt;p&gt;&lt;strong&gt;&lt;em&gt;.load( url, data, callback )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;html:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;button&amp;gt;Load HTML one!&amp;lt;/button&amp;gt;
&amp;lt;button&amp;gt;Load HTML two!&amp;lt;/button&amp;gt;
&amp;lt;button&amp;gt;Load HTML three!&amp;lt;/button&amp;gt;
&amp;lt;div id='ajax_content'&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;js:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('button').click(function(){
    var val = $(this).text();
    $('#ajax_content').load(
        '/echo/html/',{
            html: &quot;&amp;lt;p&amp;gt;&quot; + val + &quot;&amp;lt;/p&amp;gt;&quot;
        },function(text){
            console.log(text)
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码功能很简单，向&lt;code&gt;/echo/html/&lt;/code&gt;发送一个ajax请求；请求数据为&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;元素包装的按钮的文本内容；回调函数callback仅仅接收一个参数text(即请求返回的文本内容)，将其显示到控制台console上，该回调函数会在加载完响应之后执行。&lt;/p&gt;

&lt;p&gt;当单击某个按钮过后，&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素里面的内容会是下面的某一个：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;Load HTML one!&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;Load HTML two!&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;Load HTML three!&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面介绍过，&lt;code&gt;.load()&lt;/code&gt;方法的功能是，将请求url响应直接插入到匹配元素中。可以直接将上面代码复制到&lt;a href=&quot;http://jsfiddle.net&quot; title=&quot;JSFiddle.net&quot;&gt;JSFiddle.net&lt;/a&gt;上进行测试！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;$.getJSON( url, data, callback )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在介绍&lt;code&gt;$.getJSON()&lt;/code&gt;之前，首先说一下JSON(JavaScript Object Notation，JavaScript对象表示法)，&lt;/p&gt;

&lt;p&gt;JavaScript对象是由一些“key-value”对组成的，可以使用“{}”来定义，而数组则可以使用“[]”来定义，JSON就是将这两种语法组合起来，通过字面量的方式来表示数据，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &quot;key1&quot;: &quot;value1&quot;,
    &quot;key2': [
        &quot;array_elem1&quot;,
        &quot;array_elem2&quot;,
        &quot;array_elem3&quot;
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如是的JSON有很强的表达能力，能使用很少的空间大小来表示很多的数据，JSON规定了，所有的对象键及其键值都必须包含在双引号(&quot;&quot;)中，而且函数不是有效的JSON值。&lt;/p&gt;

&lt;p&gt;现在有如下一个a.json文件，其内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
    {
        &quot;name&quot;    : &quot;Tom&quot;,
        &quot;birthday&quot;: &quot;1991-01-23&quot;,
        &quot;hobbies&quot;: [&quot;篮球&quot;,&quot;羽毛球&quot;,&quot;看电影&quot;]
    },
    {
        &quot;name&quot;    : &quot;Jhon&quot;,
        &quot;birthday&quot;: &quot;1987-09-06&quot;,
        &quot;hobbies&quot;: [&quot;网球&quot;,&quot;看书&quot;,&quot;听音乐&quot;]
    },
    {
        &quot;name&quot;    : &quot;James&quot;,
        &quot;birthday&quot;: &quot;1989-10-23&quot;,
        &quot;hobbies&quot;: [&quot;篮球&quot;,&quot;旅游&quot;,&quot;看书&quot;,&quot;玩游戏&quot;]
    }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在页面加载时，将这些信息显示到页面中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.getJSON('a.json', function(data){
    var html = '';
    $.each(data, function( index, item ){
        html += '&amp;lt;div class=&quot;item&quot;&amp;gt;';
        html += '&amp;lt;h2&amp;gt;' + item.name + '&amp;lt;/h2&amp;gt;';
        html += '&amp;lt;div class=&quot;birthday&quot;&amp;gt;' + item.birthday + '&amp;lt;/div&amp;gt;';
        html += '&amp;lt;ul&amp;gt;';
        for(var i in item.hobbies){
            html += '&amp;lt;li&amp;gt;' + item.hobbies[i] + '&amp;lt;/li&amp;gt;';
        }
        html += '&amp;lt;/ul&amp;gt;';
        html += '&amp;lt;/div&amp;gt;';
    });
    $('#content').html(html);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&quot;content&quot;&amp;gt;
    &amp;lt;div class=&quot;item&quot;&amp;gt;
    &amp;lt;h2&amp;gt;Tom&amp;lt;/h2&amp;gt;
    &amp;lt;div class=&quot;birthday&quot;&amp;gt;1991-01-23&amp;lt;/div&amp;gt;
    &amp;lt;ul&amp;gt;
        &amp;lt;li&amp;gt;篮球&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;羽毛球&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;看电影&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;item&quot;&amp;gt;
    &amp;lt;h2&amp;gt;Jhon&amp;lt;/h2&amp;gt;
    &amp;lt;div class=&quot;birthday&quot;&amp;gt;1987-09-06&amp;lt;/div&amp;gt;
    &amp;lt;ul&amp;gt;
        &amp;lt;li&amp;gt;网球&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;看书&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;听音乐&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;item&quot;&amp;gt;
    &amp;lt;h2&amp;gt;James&amp;lt;/h2&amp;gt;
    &amp;lt;div class=&quot;birthday&quot;&amp;gt;1989-10-23&amp;lt;/div&amp;gt;
    &amp;lt;ul&amp;gt;
        &amp;lt;li&amp;gt;篮球&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;旅游&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;看书&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;玩游戏&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;$.getScript( url, callback )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;a.js文件，其内容如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var data = [
    {
        &quot;name&quot;    : &quot;Tom&quot;,
        &quot;birthday&quot;: &quot;1991-01-23&quot;,
        &quot;hobbies&quot;: [&quot;篮球&quot;,&quot;羽毛球&quot;,&quot;看电影&quot;]
    },
    {
        &quot;name&quot;    : &quot;Jhon&quot;,
        &quot;birthday&quot;: &quot;1987-09-06&quot;,
        &quot;hobbies&quot;: [&quot;网球&quot;,&quot;看书&quot;,&quot;听音乐&quot;]
    },
    {
        &quot;name&quot;    : &quot;James&quot;,
        &quot;birthday&quot;: &quot;1989-10-23&quot;,
        &quot;hobbies&quot;: [&quot;篮球&quot;,&quot;旅游&quot;,&quot;看书&quot;,&quot;玩游戏&quot;]
    }
];
var html = '';
$.each(data, function( index, item ){
    html += '&amp;lt;div class=&quot;item&quot;&amp;gt;';
    html += '&amp;lt;h2&amp;gt;' + item.name + '&amp;lt;/h2&amp;gt;';
    html += '&amp;lt;div class=&quot;birthday&quot;&amp;gt;' + item.birthday + '&amp;lt;/div&amp;gt;';
    html += '&amp;lt;ul&amp;gt;';
    for(var i in item.hobbies){
        html += '&amp;lt;li&amp;gt;' + item.hobbies[i] + '&amp;lt;/li&amp;gt;';
    }
    html += '&amp;lt;/ul&amp;gt;';
    html += '&amp;lt;/div&amp;gt;';
});
$('#content').html(html);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;页面的script代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.getScript('/a.js',function(){
    console.log('ajax get script done!');
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面上面的ajax请求script成功之后，会直接执行响应的a.js文件，结果跟&lt;code&gt;$.getJSON&lt;/code&gt;的结果显示一样。&lt;/p&gt;

&lt;p&gt;前面也介绍过&lt;code&gt;$.getJSON&lt;/code&gt;，&lt;code&gt;$.geScript&lt;/code&gt;两个方法，调用最底层的ajax方法，然后为其指定了optioins，就成了这两个方法。&lt;/p&gt;

&lt;p&gt;上面两个方法使用&lt;code&gt;$.get&lt;/code&gt;和&lt;code&gt;$.ajax&lt;/code&gt;来实现的话，其请求操作如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// $.get
$.get( 'a.json', function(data){...}, 'json' );
$.get( 'b.js', underfined, function(){
    console.log('ajax get script done!');
}, 'script' );

// $.ajax
$.ajax({
    url: 'a.json',
    type: 'get',
    dataType: 'json',
    data: null,
    success: function(data){...}
});

$.ajax({
    url: 'b.js',
    type: 'get',
    dataType: 'script',
    data: null,
    success: function(){
        console.log('ajax get script done!');
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;$.get()、$.post()&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前面介绍&lt;code&gt;$.get()&lt;/code&gt;和&lt;code&gt;$.post()&lt;/code&gt;的源码中，可以看出它们都是通过&lt;code&gt;$.ajax()&lt;/code&gt;方法来实现的，唯一不同的是type(请求方式)不同，其它的都是一样的。&lt;/p&gt;

&lt;p&gt;实际上get和post请求最大的区别是get请求把查询字符串放到url中，作为url的一部分；而post请求则不是，但是在jQuery的实现中，这种方式是没有体现出来的，都是直接通过传递一个data参数，在jQuery的底层实现中会将其转换成各自不同的实现，而我们是不需要去管它是怎么实现的。&lt;/p&gt;

&lt;p&gt;jQuery中get和post的原型前面也介绍过，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.get( url, data, callback )

$.post( url, data, callback )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出其调用方式是一样的，只不过具体使用哪一种请求方式：(1)遵照服务器端代码的约定；(2)传输数据量--get方法对传输的数据量有更严格的限制。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;序列化表单&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;向服务器发送数据常常会涉及到用户填写的表单，查询量较小的时候，可以手动的设置查询字符串，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.get( 'c.html', {'name': $('input[name='name']').val()}, function(data){
    console.log(data);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是当涉及到的表单数量较多的时候，手动的去序列化就不现实了，在这种情况下就可以使用jQuery提供的辅助方法&lt;code&gt;.serialize()&lt;/code&gt;，该方法作用于一个jQuery对象，将匹配的DOM元素转换层能够随Ajax请求传递的查询字符串，例如前面的可以一般化为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('form').submit(function(event){
    event.preventDefault();
    var formValues = $(this).serialize();
    $.get( 'c.html', formValues, function(){
        $('#content').html(data);
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面我们举例说明这个序列化的结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// html
&amp;lt;form action='#'&amp;gt;
    姓名：&amp;lt;input type='text' name='name'&amp;gt;&amp;lt;/br&amp;gt;
    年龄：&amp;lt;input type='text' name='age'&amp;gt;&amp;lt;/br&amp;gt;
    密码：&amp;lt;input type='password' name='password'&amp;gt;&amp;lt;/br&amp;gt;
    &amp;lt;input type='submit'/&amp;gt;
&amp;lt;/form&amp;gt;

// js
$('form').submit(function(evnet){
    event.preventDefault();
    var va = $(this).serialize();
    $('#content').html(data);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当用户填写&lt;code&gt;tom，20，tom123456&lt;/code&gt;，然后单击提交，就会看到控制台输出了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;name=tom&amp;amp;age=20&amp;amp;password=tom123456
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;.ajaxStart / .ajaxStop&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前面我么说的一直都是在处理事件的响应，其实很多的时候，在调用ajax之前或调用过程中也需要处理一些事件，比如说：为了增强用户体验，在发送请求之间在页面显示一个&lt;code&gt;Loading&lt;/code&gt;，在请求成功之后再将&lt;code&gt;Loading&lt;/code&gt;去掉，再显示请求结果。&lt;/p&gt;

&lt;p&gt;jQuery为我们提供了实现这样功能的函数，其中&lt;code&gt;.ajaxStart()&lt;/code&gt;是在ajax尚未进行其它ajax时调用该函数，而&lt;code&gt;.ajaxStop()&lt;/code&gt;是在最后一次请求结束之后再调用。jQuery提供的这些功能函数是全局性的，无论代码注册的位置在哪，只要满足了执行的条件，它都会运行。&lt;/p&gt;

&lt;p&gt;例如实现上面说的&lt;code&gt;Loading&lt;/code&gt;，先在html需要的位置插入一个显示加载中的显示元素，如&lt;code&gt;&amp;lt;div id='loading'&amp;gt;Loading&amp;lt;/div&amp;gt;&lt;/code&gt;，并将其设置为默认不显示，即添加一个样式style，&lt;code&gt;display: none;&lt;/code&gt;，则html如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id='loading' style='display: none;'&amp;gt;
    Loading!
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在js代码中需要的地方添加&lt;code&gt;.ajaxStart&lt;/code&gt;即可，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ajaxStart(function(){
    $('#loading').show();
}).ajaxStop(function(){
    $('#loading').hide();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面一篇介绍列出了所有jQuery提供的监听这些事件的方法，可以用来完成各种需要的操作，感兴趣的可以去尝试一下。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;ajax中的Deferred对象&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于&lt;code&gt;$.get/post&lt;/code&gt;，&lt;code&gt;.load&lt;/code&gt;等快捷的Ajax方法来说，并没有提供错误回调函数，只是提供了一个请求成功的回调函数，因此在错误发生的时候的处理函数需要通过其它方式来完成，比如说前面介绍过的Deferred延迟对象，它可以通过&lt;code&gt;.done()&lt;/code&gt;，&lt;code&gt;.fail()&lt;/code&gt;或&lt;code&gt;.always()&lt;/code&gt;来为ajax请求添加相应的事件回调函数即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.get( 'c.html', formValues, function(){
    $('#content').html(data);
}).fail(function(jqXHR){
    $('#content')
        .html('An error occurred:' + jqXHR.status)
        .append(jqXHR.responseText);
}).always(function(){
    console.log('ajax stop!');
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多的相关内容可以参考前面关于Deferred对象的讲解。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;修改默认选项&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;$.ajaxSetup()&lt;/code&gt;方法可以修改调用Ajax方法是，每个选项的默认值，接受与&lt;code&gt;$.ajax()&lt;/code&gt;相同的对象参数选项，如本文开头的表格所示，之后的所有Ajax请求都将使用传递给该函数的选项，除非用户显示的指定同名参数(将会覆盖默认设置)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 修改默认选项
$.ajaxSetup({
    url: 'd.html',
    type: 'post',
    dataType: 'html'
});

// 再次调用ajax
$.ajax({
    type: 'get',
    success: function(data){
        $('#content').html(data);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面修改默认选项时，为ajax方法指定了默认的url(&lt;code&gt;d.html&lt;/code&gt;)和dataType，后面调用时不需要在明确指定，如果再设置了与前面同名的选项，会覆盖前面的，就像这里的type，默认是post方式，而此处显示的指定了get方式，那么在本次的ajax请求会使用get方式去请求，如果下次没有显示指定请求方式，仍然会使用post方式去请求。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;部分加载页面&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前面介绍过的&lt;code&gt;.load()&lt;/code&gt;方法，会将指定的文档&lt;strong&gt;全部&lt;/strong&gt;添加到匹配元素中，而实际上可能只需要添加一部分。比如在加载一个html文档时，需要的只是这个html文档当中的&lt;code&gt;class＝'part'&lt;/code&gt;的元素，不需要去遍历查找，直接传递url时附带一个jQuery选择符表达式即可，jQuery会帮我们完成必要的操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('#content').load('c.html .part');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际的操作语句就只有一句，非常的简洁，感兴趣的可以去试试看，你会发现与jQuery选择符表达式无关的信息都被剔除掉了，只将需要的信息加载到了匹配元素中。&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未完待续。。。&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Jquery Source Analysis Ajax(1)</title>
   <link href="http://www.blogways.net/blog/2014/08/26/jQuery-source-analysis-ajax%281%29.html"/>
   <updated>2014-08-26T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/08/26/jQuery-source-analysis-ajax(1)</id>
   <content type="html">&lt;h2&gt;一、前言&lt;/h2&gt;

&lt;p&gt;AJAX，异步JavaScript和XML，涉及到如下技术：&lt;/p&gt;

&lt;p&gt;(1)异步JavaScript，由于JavaScript中引入的回调函数的概念，所有后台的JavaScript代码中，后面的任务&lt;strong&gt;不需要&lt;/strong&gt;在等待前面的任务执行完，每个任务执行完毕后不是去执行另一个任务，而是执行其绑定的一个或多个回调函数，因而程序的执行顺序与任务的排列顺序是不一致的、异步的。&lt;/p&gt;

&lt;p&gt;一般耗时较长的任务都是使用异步操作，以避免浏览器长时间执行某一无意义的任务(如死循环等)失去响应。&lt;/p&gt;

&lt;p&gt;(2)XMLHTTPRequest，在不中断浏览器其他任务的情况下，向服务器发送请求&lt;/p&gt;

&lt;p&gt;(3)向服务器请求的数据类型，及预期服务器返回的数据类型。&lt;/p&gt;

&lt;h2&gt;二、源码结构&lt;/h2&gt;

&lt;p&gt;首先，看一下jQuery源码中，Ajax这块的方法及函数的扩展实现，总体结构如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery.parseJSON = function( data ) {};
jQuery.parseXML = function( data ) {};
jQuery.parseHTML = function( data, context, keepScripts ) {};

function addToPrefiltersOrTransports( structure ) {};
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {};
function ajaxHandleResponses( s, jqXHR, responses ) {};
function ajaxConvert( s, response, jqXHR, isSuccess ) {};

jQuery.extend({
    ajaxSettings: {...},
    ajaxSetup: function( target, settings ) {},
    ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
    ajaxTransport: addToPrefiltersOrTransports( transports ),
    // 主要的方法
    ajax: function( url, options ) {},

    getJSON: function( url, data, callback ) {
        return jQuery.get( url, data, callback, &quot;json&quot; );
    },

    getScript: function( url, callback ) {
        return jQuery.get( url, undefined, callback, &quot;script&quot; );
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的这些源码中，首先直接通过&lt;code&gt;jQuery.funcName&lt;/code&gt;扩展jQuery全局函数，将jQuery提供的3个字符串转换为相应JSON、XML或HTML的API；&lt;/p&gt;

&lt;p&gt;接着定义了一些ajax内部使用的函数，用于后面实现功能时调用；然后通过&lt;code&gt;jQuery.extend&lt;/code&gt;将一些功能函数扩展到jQuery全局对象中去，这些函数的功能后面会有介绍，此处不详细说明。其中最主要的一个方法就是&lt;code&gt;ajax( url, options )&lt;/code&gt;，ajax模块中的所有其他的ajax功能函数都是在此函数的基础上来实现的，就拿getJSON和getScript来说，它们的源代码很简单，就一行代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// getJSON
return jQuery.get( url, data, callback, &quot;json&quot; );
// getScript
return jQuery.get( url, undefined, callback, &quot;script&quot; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，它们都是调用了&lt;code&gt;jQuery.get()&lt;/code&gt;方法，它们本质上就是一个get请求，只不过认为的为其指定了&lt;strong&gt;&lt;em&gt;预期回的数据类型&lt;/em&gt;&lt;/strong&gt;( &quot;json&quot;和&quot;script&quot; )，那么这个get方法又是怎么实现的呢，下面请看get/post方法的实现源码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery.each( [ &quot;get&quot;, &quot;post&quot; ], function( i, method ) {
    jQuery[ method ] = function( url, data, callback, type ) {
        // shift arguments if data argument was omitted
        if ( jQuery.isFunction( data ) ) {
            type = type || callback;
            callback = data;
            data = undefined;
        }
        return jQuery.ajax({
            url: url,
            type: method,
            dataType: type,
            data: data,
            success: callback
        });
    };
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里使用&lt;code&gt;jQuery.each()&lt;/code&gt;遍历一个数组&lt;code&gt;[ &quot;get&quot;, &quot;post&quot;]&lt;/code&gt;，通过&lt;code&gt;jQuery[ method ] = function...&lt;/code&gt;，将get/post方法扩展到了jQuery的全局对象中，然后来看一这两个方法的原型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery[ method ] = function( url, data, callback, type ) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后是其实现的代码，从中可以看出这两个方法实现的实质也是调用了&lt;code&gt;ajax( url, options )&lt;/code&gt;方法，只不过是将其中的一些事先确定的参数传递给ajax方法而已。&lt;/p&gt;

&lt;p&gt;接下来我们来看一下jQuery提供的一些默认的ajax设置，都保存在&lt;code&gt;jQuery.ajaxSettings&lt;/code&gt;对象中，其对象结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ajaxSettings: {
    url: ajaxLocation,
    type: &quot;GET&quot;,
    isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
    global: true,
    processData: true,
    async: true,
    contentType: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;,
    accepts: {
        &quot;*&quot;: allTypes,
        text: &quot;text/plain&quot;,
        html: &quot;text/html&quot;,
        xml: &quot;application/xml, text/xml&quot;,
        json: &quot;application/json, text/javascript&quot;
    },
    contents: {
        xml: /xml/,
        html: /html/,
        json: /json/
    },
    responseFields: {
        xml: &quot;responseXML&quot;,
        text: &quot;responseText&quot;,
        json: &quot;responseJSON&quot;
    },
    // 数据转换
    converters: {
        &quot;* text&quot;: String,
        &quot;text html&quot;: true,
        &quot;text json&quot;: jQuery.parseJSON,
        &quot;text xml&quot;: jQuery.parseXML
    },
    flatOptions: {
        url: true,
        context: true
    }
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列出了ajax默认的一些设置，如果用户使用的ajax请求参数，都基本确定无需要很大的更改，则可以根据自己的需求更改这些默认的ajax设置，就不需要每次在使用ajax请求时都要指定这些参数，而用于修改ajax默认请求参数的方法源码如下，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ajaxSetup: function( target, settings ) {
    return settings ?
        // 根据默认设置，构建一个行的settings对象，
        // 然后将修改的参数扩展到默认设置里面
        ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
        // 扩展ajaxSettings
        ajaxExtend( jQuery.ajaxSettings, target );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中的&lt;code&gt;ajaxExtend()&lt;/code&gt;是一个ajax请求参数options的特殊扩展方法，只是将用户自定义的设置扩展到了jQuery的默认设置中去，当然同名的会发生覆盖，其基本功能跟&lt;code&gt;jQuery.extend&lt;/code&gt;方法类似，感兴趣的可以到前面的讲解中去看一下相关介绍，可以看一个解析YAML的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.ajaxSetup({
    accepts: {
        yaml: 'application/x-yaml, text/yaml'
    },
    contents: {
        yaml: /yaml/
    },
    converters: {
        'text yaml': function(text){
            alert(text);
            return '';
        }
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就完成了一个ajax参数默认值的修改，一旦修改之后，后面的所有ajax都将会受到该次修改的影响：后面只要请求的数据类型是一个yaml文件，那么就会按照上面定义的这些参数来运行及转换，调用方式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.ajax({
    url: 'helloworld.yaml'
    dataType: 'yaml'
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中的converters的&lt;code&gt;'text yaml'&lt;/code&gt;是告诉jQuery，这个转换函数以text格式接受数据，然后以yaml格式重新解析，后面指定的就是起解析函数，此处的转换只是将内容通过警示框输出。&lt;/p&gt;

&lt;p&gt;然后来看一下jQuery中ajax提供的一些监听方法，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 通过jQuery.each方法遍历数组中需要添加监听的名称，
// 使用jQuery.fn[ type ]将这些监听方法扩展到jQuery的实例对象中去，
// 在其具体实现中，通过调用当前匹配元素(jQuery实例对象)的on方法，
// 将指定的事件处理程序绑定到特定的ajax事件上
jQuery.each( [ &quot;ajaxStart&quot;, &quot;ajaxStop&quot;, &quot;ajaxComplete&quot;, 
                            &quot;ajaxError&quot;, &quot;ajaxSuccess&quot;, &quot;ajaxSend&quot; ], function( i, type ) {
    jQuery.fn[ type ] = function( fn ) {
        return this.on( type, fn );
    };
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从中可以看出，ajax一共提供了6个ajax事件监听，分别为：ajaxStart、ajaxStop、ajaxComplete、ajaxError、ajaxSuccess和ajaxSend，这些监听方法的功能介绍后面再做说明。&lt;/p&gt;

&lt;p&gt;后面通过&lt;code&gt;jQuery.fn.extend&lt;/code&gt;将&lt;code&gt;.seriallize()&lt;/code&gt;和&lt;code&gt;.seriallizeArray()&lt;/code&gt;方法扩展到jQuery的实例对象中去，其代码实现不在做讲解，感兴趣的可以自己看看。&lt;/p&gt;

&lt;p&gt;前面讲解到了ajaxSetup方法扩展一个yaml文件的ajax请求，下面来看一下jQuery源码中关于script的ajax请求的扩展，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 增加script数据类型
jQuery.ajaxSetup({
    accepts: {
        script: &quot;text/javascript, application/javascript, 
                        application/ecmascript, application/x-ecmascript&quot;
    },
    contents: {
        script: /(?:java|ecma)script/
    },
    converters: {
        &quot;text script&quot;: function( text ) {
            jQuery.globalEval( text );
            return text;
        }
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是不是跟我们举得例子基本是一样的吧，这里accepts中的属性会添加发送到服务器的头部信息，声明我们的脚本可以理解的特定的MIME类型，此处为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;text/javascript, application/javascript, application/ecmascript, application/x-ecmascript&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当请求的为这些MIME类型时，将其理解为script；&lt;/p&gt;

&lt;p&gt;而contents属性处理数据交换的另一方，它提供一个与响应的MIME类型进行匹配的正则表达式，以尝试自动检测这个元数据当中的数据类型，此处表示会匹配script、javascript或ecmascript；&lt;/p&gt;

&lt;p&gt;最后的converters中包含解析返回数据的函数，此处是调用&lt;code&gt;jQuery.globalEval()&lt;/code&gt;方法在全局上下文中执行给定的JavaScript字符串，并返回此JavaScript字符串。&lt;/p&gt;

&lt;p&gt;接下来的源码结构，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 定义script的预过滤器
jQuery.ajaxPrefilter( &quot;script&quot;, function( s ) {...});

// 扩展script的传输机制
jQuery.ajaxTransport( &quot;script&quot;, function(s) {...});
// 默认的json设置
jQuery.ajaxSetup({
    jsonp: &quot;callback&quot;,
    jsonpCallback: function() {
        var callback = oldCallbacks.pop() || ( jQuery.expando + &quot;_&quot; + ( nonce++ ) );
        this[ callback ] = true;
        return callback;
    }
});

jQuery.ajaxPrefilter( &quot;json jsonp&quot;, function( s, originalSettings, jqXHR ) {...});

// 通过ajax请求，将指定url响应的元素加入到匹配元素中
jQuery.fn.load = function( url, params, callback ) {};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的&lt;code&gt;jQuery.ajaxPrefilter()&lt;/code&gt;函数可以添加&lt;strong&gt;预过滤器&lt;/strong&gt;(即一些回调函数)，在发送ajax请求之前对请求进行过滤。预过滤器会在&lt;code&gt;$.ajax()&lt;/code&gt;修改或者使用它的任何选项之前调用，因此通过预过滤器可以修改这些选项或者基于新的、自定义的选项发送ajax请求。&lt;/p&gt;

&lt;p&gt;在定义了特定功能的预过滤器之后，就不需要我们在ajax请求中，明确的去定义数据类型。&lt;/p&gt;

&lt;h2&gt;三、Ajax方法&lt;/h2&gt;

&lt;p&gt;在看完ajax模块的源码结构之后，下面是对ajax中提供的一些方法做了一下总结：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;发送请求&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;table width='100%'&gt;
&lt;tr&gt;&lt;th width='40%'&gt;Ajax方法&lt;/th&gt;&lt;th&gt;说   明&lt;/th&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;$.ajax( url, options )&lt;/td&gt;&lt;td&gt;使用传入的options生成一次ajax请求&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;.load( url, params, callback )&lt;/td&gt;&lt;td&gt;根据url生成一次ajax请求，将响应放到匹配的元素中&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;$.get( url, data, callback, type )&lt;/td&gt;&lt;td&gt;使用get方法向指定url发送一次ajax请求&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;$.post( url, data, callback, type )&lt;/td&gt;&lt;td&gt;使用post方法向指定url发送一次ajax请求&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;$.getJSON( url, data, callback )&lt;/td&gt;&lt;td&gt;向url发送一次ajax请求，&lt;b&gt;解析&lt;/b&gt;预期返回的JSON数据&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;$.getScript( url, callback )&lt;/td&gt;&lt;td&gt;向url发送一次ajax请求，&lt;b&gt;执行&lt;/b&gt;预期返回的JavaScript代码&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;&lt;strong&gt;&lt;em&gt;监听请求&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;table width='100%'&gt;
&lt;tr&gt;&lt;th width='40%'&gt;Ajax方法&lt;/th&gt;&lt;th&gt;说   明&lt;/th&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;.ajaxStart( fn )&lt;/td&gt;&lt;td&gt;绑定当任意Ajax事务开始，但没有其它Ajax事务活动时执行的处理程序&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;.ajaxStop( fn )&lt;/td&gt;&lt;td&gt;绑定当任意Ajax事务结束，但没有其它Ajax事务仍然在活动时执行的处理程序&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;.ajaxComplete( fn )&lt;/td&gt;&lt;td&gt;绑定当任意Ajax事务执行过程中，完成时执行的处理程序(无论执行失败还是成功都执行)&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;.ajaxError( fn )&lt;/td&gt;&lt;td&gt;绑定当任意Ajax事务执行过程中，发生错误时执行的处理程序&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;.ajaxSuccess( fn )&lt;/td&gt;&lt;td&gt;绑定当任意Ajax事务执行过程中，成功完成时执行的处理程序&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;.ajaxSend( fn )&lt;/td&gt;&lt;td&gt;绑定当任意Ajax事务执行过程中，开始执行时执行的处理程序&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;&lt;strong&gt;&lt;em&gt;配置信息&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;table width='100%'&gt;
&lt;tr&gt;&lt;th width='40%'&gt;Ajax方法&lt;/th&gt;&lt;th&gt;说   明&lt;/th&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;$.ajaxSettings&lt;/td&gt;&lt;td&gt;jQuery提供的ajax默认设置选项&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;$.ajaxSetup&lt;/td&gt;&lt;td&gt;为后续的ajax事务设置默认选项&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;$.ajaxPrefilter( prefilters )&lt;/td&gt;&lt;td&gt;在$.ajax()处理每个请求之前，会对每个Ajax请求选项做预过滤&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;$.ajaxTransport( transports )&lt;/td&gt;&lt;td&gt;为Ajax定义一个新的传输机制&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;&lt;strong&gt;&lt;em&gt;辅助方法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;table width='100%'&gt;
&lt;tr&gt;&lt;th width='40%'&gt;Ajax方法&lt;/th&gt;&lt;th&gt;说   明&lt;/th&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;.seriallize()&lt;/td&gt;&lt;td&gt;将表单控件的值序列化为一个查询字符串&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;.seriallizeArray()&lt;/td&gt;&lt;td&gt;将表单空间的值序列化为一个JSON字符串&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;$.param( obj )&lt;/td&gt;&lt;td&gt;将obj对象转换为一个查询字符串&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;$.globalEval( code )&lt;/td&gt;&lt;td&gt;在全部上下文中执行给定是JavaScript字符串&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;$.parseJSON( json )&lt;/td&gt;&lt;td&gt;将给定的json字符串转换为JavaScript对象&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;$.parseXML( xml )&lt;/td&gt;&lt;td&gt;将给定的xml字符串转换为XML文档&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;$.parseHTML( html )&lt;/td&gt;&lt;td&gt;将给定的html字符串转换为DOM元素&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未完待续。。。&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Jquery Source Analysis Attribute</title>
   <link href="http://www.blogways.net/blog/2014/08/25/jQuery-source-analysis-attribute.html"/>
   <updated>2014-08-25T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/08/25/jQuery-source-analysis-attribute</id>
   <content type="html">&lt;h2&gt;一、前言&lt;/h2&gt;

&lt;p&gt;属性操作主要分为attr特性和prop属性操作，而一般使用的方法就三个：&lt;code&gt;.attr()&lt;/code&gt;、&lt;code&gt;.prop&lt;/code&gt;和&lt;code&gt;.val()&lt;/code&gt;。其中&lt;code&gt;.attr()&lt;/code&gt;用于操作attr特性，而&lt;code&gt;.prop()&lt;/code&gt;主要用于操作prop属性，最后&lt;code&gt;.val()&lt;/code&gt;则是用于操作元素的value属性值。&lt;/p&gt;

&lt;p&gt;提到attr特性和prop属性，很多人都会很疑惑，它们之间有什么不同呢？&lt;/p&gt;

&lt;p&gt;(1)&lt;strong&gt;&lt;em&gt;attr特性&lt;/em&gt;&lt;/strong&gt;，直接写在标签上的属性，可以通过浏览器原生的API：setAttribute、getAttribute进行设置、读取，如下所示的id，type，checked都是attr特性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input id='incb' type='checkbox' checked='checked'/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;attr特性，主要是通过&lt;code&gt;name＝'value'&lt;/code&gt;的形式，通过NameNodeMap保存在元素节点当中，其自身作为&lt;code&gt;Node.ATTRIBUTE_NODE(2)&lt;/code&gt;节点，上述的&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;元素对应的jQuery对象结构，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/attr.png&quot; alt=&quot;attr 特性值 NameNodeMap&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从图中可以看到attr特性在元素节点中是以NameNodeMap类型保持的。&lt;/p&gt;

&lt;p&gt;(2)&lt;strong&gt;&lt;em&gt;prop属性&lt;/em&gt;&lt;/strong&gt;，prop属性和attr特性最明显的差异修饰保持方式和访问设置方式，attr要通过一些元素的API来访问设置，但是prop属性则是直接通过&lt;code&gt;.&lt;/code&gt;号来进行访问和设置属性；prop属性是作为元素节点的实例对象属性来存储的。&lt;/p&gt;

&lt;p&gt;就像上面attr特性值中的图片所示，其中的&lt;code&gt;checked: true&lt;/code&gt;，&lt;code&gt;accept:&quot;&quot;&lt;/code&gt;，&lt;code&gt;autofocus: false&lt;/code&gt;等都是prop属性值，因为作为元素节点的属性，可以直接访问：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var $incb = $('#incb');
$incb.accept = 'Test prop value!';
console.log($incb.accept);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果会显示&lt;code&gt;Test prop value!&lt;/code&gt;，可见上面通过对&lt;code&gt;.accept = '...'&lt;/code&gt;直接赋值用于设置了prop属性，而通过&lt;code&gt;.accept&lt;/code&gt;直接返回了设置的prop属性。&lt;/p&gt;

&lt;p&gt;而&lt;code&gt;.val()&lt;/code&gt;则是操作的是元素的value属性。&lt;/p&gt;

&lt;h2&gt;二、源码分析&lt;/h2&gt;

&lt;p&gt;首先，看一下通过&lt;code&gt;jQuery.fn.extend&lt;/code&gt;扩展到jQuery实例对象中的&lt;code&gt;.attr()&lt;/code&gt;和&lt;code&gt;.prop()&lt;/code&gt;方法，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;attr: function( name, value ) {
    return access( this, jQuery.attr, name, value, arguments.length &amp;gt; 1 );
}

prop: function( name, value ) {
    return access( this, jQuery.prop, name, value, arguments.length &amp;gt; 1 );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由上面的源码可以看出，jQuery实例对象中的两个方法都是调用了access，在参数传递方面除了在第二个参数不同之外，其余都是一样的，那么让我们来看一下access函数是何方神圣，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
    var i = 0,
        length = elems.length,
        bulk = key == null;

    // 传递的过来的key值是个对象，递归调用处理多值
    if ( jQuery.type( key ) === &quot;object&quot; ) {
        chainable = true;
        for ( i in key ) {
            jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
        }

    // 传递的value值有意义，处理单值
    } else if ( value !== undefined ) {
        chainable = true;

        if ( !jQuery.isFunction( value ) ) {
            raw = true;
        }

        if ( bulk ) {
            // Bulk operations run against the entire set
            // key值不为空，即传递过来的key值有意义
            if ( raw ) {
                // 如果传递过来的value不是一个函数，
                // 则直接使用key和value值，调用传递过来的函数fn
                fn.call( elems, value );
                fn = null;

            } else {
                bulk = fn;
                fn = function( elem, key, value ) {
                    return bulk.call( jQuery( elem ), value );
                };
            }
        }

        if ( fn ) {     // 运行fn
            for ( ; i &amp;lt; length; i++ ) {
                fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
            }
        }
    }
    // chainable 为 arguments.length &amp;gt; 1 的结果
    return chainable ?   // 返回操作以后的数据
        elems :
        bulk ?
            fn.call( elems ) :
            length ? fn( elems[0], key ) : emptyGet;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从中可以看出，access方法没有太多代码，仅仅只是讲传递过来的参数做一定的修改，修改完成之后执行指定的函数(第二个参数所指定的函数)，而主要的参数修改，就是将多值参数分解为单值操作，然后分别执行相应的函数。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.attr()&lt;/code&gt;和&lt;code&gt;.prop()&lt;/code&gt;方法在为access传递的第二个参数，分别传值为&lt;code&gt;jQuery.attr&lt;/code&gt;和&lt;code&gt;jQuery.prop&lt;/code&gt;，由此可见，attr特性与prop属性的get/set方法具体实现应该在这两个传值函数当中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;attr: function( elem, name, value )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;attr: function( elem, name, value ) {
    var hooks, ret,
        nType = elem.nodeType;

    // 忽略文本、注释和属性节点的attr特性操作(get/set)
    if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
        return;
    }

    // 当不支持浏览器原生的getAttribute时，
    // 调用prop属性设置方法来实现
    if ( typeof elem.getAttribute === strundefined ) {
        return jQuery.prop( elem, name, value );
    }

    // 所有的attr特性名都是小写
    if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
        name = name.toLowerCase();  // 将特性名转换为小写样式
        hooks = jQuery.attrHooks[ name ] || // 如果hook已被定义，则直接抓取
            ( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
    }

    if ( value !== undefined ) {  // 特性值已定义

        if ( value === null ) {  // 特性值为空，这删除对应属性
            jQuery.removeAttr( elem, name );

        } else if ( hooks &amp;amp;&amp;amp; &quot;set&quot; in hooks &amp;amp;&amp;amp; 
                        (ret = hooks.set( elem, value, name )) !== undefined ) {
            return ret;

        } else {
            elem.setAttribute( name, value + &quot;&quot; );
            return value;
        }
    // 如果有对应的hooks，且其中包含get方法，则调用hooks的get方法
    } else if ( hooks &amp;amp;&amp;amp; &quot;get&quot; in hooks &amp;amp;&amp;amp; (ret = hooks.get( elem, name )) !== null ) {
        return ret;

    } else {
        ret = jQuery.find.attr( elem, name );
        // 不存在对应特性返回undefined
        return ret == null ?
            undefined :
            ret;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由源码可知，通过对参数的一些判断和修正，实现来对&lt;code&gt;.attr()&lt;/code&gt;方法的重载，首先，value值是否定义，来判别是get/set，value的类型(可以是function)，或者传入一个key-value值对象，都能实现类似&lt;code&gt;C/C++&lt;/code&gt;中的函数重载：&lt;/p&gt;

&lt;p&gt;(1)&lt;code&gt;.attr( key )&lt;/code&gt;，get方法，取得指定key值(特性名)对应的特性值；&lt;/p&gt;

&lt;p&gt;(2)&lt;code&gt;.attr( key, value )&lt;/code&gt;，set方法，设置指定key值所示特性对应的特征值；&lt;/p&gt;

&lt;p&gt;(3)&lt;code&gt;.attr( key, fn )&lt;/code&gt;，set方法，设置对应key特性的特性值，为调用fn之后的返回结果(每个匹配元素单独调用)；&lt;/p&gt;

&lt;p&gt;(4)&lt;code&gt;.attr( obj )&lt;/code&gt;，set方法，根据传入的key-value对象设置特性&lt;/p&gt;

&lt;p&gt;(5)&lt;code&gt;.attr( key, null )&lt;/code&gt;/&lt;code&gt;.removeAttr(key)&lt;/code&gt;，删除指定key值对应的特性&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;prop: function( elem, name, value )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;prop: function( elem, name, value ) {
    var ret, hooks, notxml,
        nType = elem.nodeType;

    // 忽略文本、注释和属性节点的attr特性操作(get/set)
    if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
        return;
    }

    notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

    if ( notxml ) {
        // 修正属性名和的绑定的hooks
        name = jQuery.propFix[ name ] || name;
        hooks = jQuery.propHooks[ name ];
    }
    // 与attr一样，通过判断是否传递value，来鉴别get/set，
    // 属性的设置与获取都是通过hooks来实现
    if ( value !== undefined ) {    // value值已定义，相当于set
        return hooks &amp;amp;&amp;amp; &quot;set&quot; in hooks 
                    &amp;amp;&amp;amp; (ret = hooks.set( elem, value, name )) !== undefined ?
            ret :
            ( elem[ name ] = value );

    } else {    // value未定义，相当于get
        return hooks &amp;amp;&amp;amp; &quot;get&quot; in hooks &amp;amp;&amp;amp; (ret = hooks.get( elem, name )) !== null ?
            ret :
            elem[ name ];
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从源代码可以看出，&lt;code&gt;.attr()&lt;/code&gt;和&lt;code&gt;.prop()&lt;/code&gt;中并没有给出最底层调用原生API的实现，多数都是通过调用对应的hooks来实现对特性与属性的设置，由于笔者对于这个hooks也有些迷惑，还在学习中，此处不在说明。&lt;/p&gt;

&lt;p&gt;虽然具体底层实现没有给出，但是源码中可以看出，通过判断value参数值是否定义，用于判断实现get/set方法。&lt;/p&gt;

&lt;p&gt;(1)&lt;code&gt;.prop( key )&lt;/code&gt;，get方法，取得指定key值(属性名名)对应的属性值；&lt;/p&gt;

&lt;p&gt;(2)&lt;code&gt;.prop( key, value )&lt;/code&gt;，set方法，设置指定key值所示属性对应的属性值；&lt;/p&gt;

&lt;p&gt;(3)&lt;code&gt;.prop( key, fn )&lt;/code&gt;，set方法，设置对应key属性的属性值，为调用fn之后的返回结果(每个匹配元素单独调用)；&lt;/p&gt;

&lt;p&gt;(4)&lt;code&gt;.prop( obj )&lt;/code&gt;，set方法，根据传入的key-value对象设置属性&lt;/p&gt;

&lt;p&gt;(5)&lt;code&gt;.removeProp(key)&lt;/code&gt;，删除指定key值对应的属性&lt;/p&gt;

&lt;h3&gt;附加&lt;/h3&gt;

&lt;p&gt;要说attr特性和prop属性的实际应用，其中attr特性中使用的最多的要算class特性来，而在一些表单元素中使用最多的属性则是value属性来，面对这些常用的特性与属性，jQuery专门为之提供来操作的API，方便开发。&lt;/p&gt;

&lt;h4&gt;addClass、removeClass、toggleClass、hasClass&lt;/h4&gt;

&lt;p&gt;其中的元素的class特性无意是使用率最高的，因为在CSS层叠样式表中，用匹配符来设计样式时，基本都是使用的class，因而class成为来最常要使用的特性。&lt;/p&gt;

&lt;p&gt;由于class包含很多通过空白分隔的若干个特性值，对于某些class特性值的修改非常的不容易，以前需要去编写循环操作，jQuery考虑到这些，专门提供来这几个方法来加快开发。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;addClass( class )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为每个匹配的元素添加传入的类class&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;removeClass( class )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从每个匹配的元素中，删除传入的类class&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;toggleClass( class )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为每个匹配的元素执行后面的操作：如果传入的类class在匹配元素中已经存在，则删除此class；如果匹配的元素中不存在传入的类class，则在匹配的元素中添加类class&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;hasClass( class )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果所有的匹配元素中，至少有一个元素包含类class则返回true，否则返回false&lt;/p&gt;

&lt;h4&gt;val()、val( value )&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;.val()&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;返回所有匹配元素中，第一个匹配元素的value属性值&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;.val( val )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;设置所有匹配元素的value属性值为传入的val值&lt;/p&gt;

&lt;h2&gt;三、示例&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;attr特性操作&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;html:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input id ='ic' class='hover highlight other' type='button' value='提交' /&amp;gt;
&amp;lt;input id ='ic1' class='myclass' type='button' value='重置' /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var $inbtn = $('#ic');

$inbtn.attr('class');   // 去的'class'特性值，'hover highlight other'

$inbtn.attr('type', 'input');   // 将'type'设置为'input'，即按钮变成来输入框

$inbtn.attr('class', null);     // 删除'class'属性，及所有'class'特性值

// 将上面两部操作合并到一个对象，一次性实现
$inbtn.attr({'type': 'input','class': null});

$inbtn.removeAttr('class');  // 完成与$inbtn.attr('class', null)一样的操作
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;prop属性操作&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先看一下一些prop属性，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/prop.png&quot; alt=&quot;部分prop 属性&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先要说一下的是，很多特性都有一个与之想对应的属性，就拿上面&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;元素的value特性来说，像html中那样编写，它明明是一个特性，但是在图中可以看出，在元素的属性中，也有一个与之对应的属性value。&lt;/p&gt;

&lt;p&gt;它们之间的修改是关联的，修改来属性，特性值也会跟着改变，同样修改来特性值，属性值也会跟着改变。&lt;/p&gt;

&lt;p&gt;测试：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$inbtn.prop('value');  // 返回属性value的值，此处为'提交'

$inbtn.prop('value', '修改');  // 将'value'属性修改为'修改'

$inbtn.prop('value', null );  // 删除'value'属性及其属性值

// 将上面两步操作合并到了一个对象中，一次性实现，结果是删除来'value'属性，
// 因为最后一个操作是删除'value'属性及其属性值，所以前面对'value'值的修改不会体现出来
$inbtn.prop({'value': '修改', 'value': null });

$inbtn.removeProp('value');     // 实现与$inbtn.prop('value', null )一样的操作
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;jQuery操作class&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$inbtn.addClass('hello world other');  // 为&amp;lt;input&amp;gt;元素添加三个类hello, world, other
// 如果添加来已存在的类，会默认忽略，
// 修改后的类为hover, highlight, other, hello, world

$inbtn.removeClass('hover other');   // 删除&amp;lt;input&amp;gt;元素的两个类hover, other
// 修改后的类为highlight

$inbtn.toggleClass('hightlight bold'); 
// 修改后的类hover, other, bold

$inbtn.hasClass('myclass');     // 返回false，$inbtn只包含第一个&amp;lt;input&amp;gt;元素，没有myclass类

$('input').hasClass('myclass');     // 返回true，$('input')包含两个&amp;lt;input&amp;gt;元素，
// 第二个包含myclass类
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;.val()、.val( val )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$inbtn.val();   // 返回属性value的值，此处为'提交'

$inbtn.val('修改');  // 实现跟$inbtn.prop('value', '修改')一样的操作
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未完待续。。。&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Jquery Source Analysis Selector Expr</title>
   <link href="http://www.blogways.net/blog/2014/08/22/jQuery-source-analysis-selector-expr.html"/>
   <updated>2014-08-22T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/08/22/jQuery-source-analysis-selector-expr</id>
   <content type="html">&lt;h2&gt;测试用html：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;
    &amp;lt;span class='article'&amp;gt;
        &amp;lt;h2&amp;gt;测试标题一&amp;lt;/h2&amp;gt;
        &amp;lt;p id='p1'&amp;gt;段落一，测试段落，仅供测试之用！！！&amp;lt;a href='#'&amp;gt;linkage&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
        &amp;lt;a href='#'&amp;gt;read more!&amp;lt;/a&amp;gt;
    &amp;lt;/span&amp;gt;
    &amp;lt;div class='article'&amp;gt;
        &amp;lt;h2&amp;gt;测试标题二&amp;lt;/h2&amp;gt;
        &amp;lt;p id='p2'&amp;gt;段落二，测试段落，仅供测试之用！！！&amp;lt;a href='#'&amp;gt;linkage&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
        &amp;lt;a href='#'&amp;gt;read more!&amp;lt;/a&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;span class='article'&amp;gt;
        &amp;lt;h2&amp;gt;测试标题三&amp;lt;/h2&amp;gt;
        &amp;lt;p id='p3'&amp;gt;段落三，测试段落，仅供测试之用！！！&amp;lt;a href='#'&amp;gt;linkage&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
        &amp;lt;a href='#'&amp;gt;read more!&amp;lt;/a&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;span class='article'&amp;gt;
        &amp;lt;h2&amp;gt;测试标题四&amp;lt;/h2&amp;gt;
        &amp;lt;p id='p4'&amp;gt;段落四，测试段落，仅供测试之用！！！&amp;lt;a href='#'&amp;gt;linkage&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
        &amp;lt;a href='#'&amp;gt;read more!&amp;lt;/a&amp;gt;
    &amp;lt;/div&amp;gt;
    ... // 后面省略的全部为&amp;lt;div class='article'&amp;gt;...&amp;lt;/div&amp;gt;元素
    &amp;lt;input type='button' class='article'&amp;gt;提交&amp;lt;/input&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;一、简单的CSS选择符&lt;/h2&gt;

&lt;table width='100%'&gt;
&lt;tr&gt;&lt;th width='40%'&gt;选择符&lt;/th&gt;&lt;th&gt;匹配&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;*&lt;/td&gt;&lt;td&gt;匹配所有元素&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;#id&lt;/td&gt;&lt;td&gt;匹配带有给定id的元素&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;element&lt;/td&gt;&lt;td&gt;给定元素类型的所有元素&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;.class&lt;/td&gt;&lt;td&gt;匹配给定类的所有元素&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;a, b&lt;/td&gt;&lt;td&gt;与a或b匹配的元素&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;a b&lt;/td&gt;&lt;td&gt;a的所有后代元素中，与b匹配的元素&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;a &gt; b&lt;/td&gt;&lt;td&gt;作为a子元素的所以b元素&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;a + b&lt;/td&gt;&lt;td&gt;a之后的第一个与b匹配的兄弟元素&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;a - b&lt;/td&gt;&lt;td&gt;a之后的所有兄弟元素中与b匹配的元素&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


&lt;p&gt;测试代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('*')  // 匹配上面html文档中的所有元素

$('#p1')    // 匹配html文档中id='p1'的元素，即为段落一的&amp;lt;p&amp;gt;元素

$('p')    // 匹配html文档中所有的&amp;lt;p&amp;gt;元素，即所有的段落

$('.article')   // 匹配所有class='article'的元素

$('h2,a')   // 匹配所有的&amp;lt;h2&amp;gt;或&amp;lt;a&amp;gt;元素

$('div a')  // 匹配&amp;lt;div&amp;gt;元素所有后代中的，所有的&amp;lt;a&amp;gt;元素，此处为html中所有的&amp;lt;a&amp;gt;元素

$('div &amp;gt; a')  // 匹配&amp;lt;div&amp;gt;元素的子元素中的&amp;lt;a&amp;gt;元素，此处为所有&amp;lt;a href='#'&amp;gt;read more!&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h2&gt;二、同辈元素间定位&lt;/h2&gt;

&lt;table width='100%'&gt;
&lt;tr&gt;&lt;th width='40%'&gt;选择符&lt;/th&gt;&lt;th&gt;匹配&lt;/th&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;:nth-child(index)&lt;/td&gt;
    &lt;td&gt;匹配父元素的第index个子元素(从1开始计数)&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:nth-child(even)&lt;/td&gt;
    &lt;td&gt;匹配父元素的下标(索引)为&lt;b&gt;&lt;i&gt;偶数的&lt;/b&gt;&lt;/i&gt;子元素(从1开始计数)&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:nth-child(odd)&lt;/td&gt;
    &lt;td&gt;匹配父元素的下标(索引)为&lt;b&gt;&lt;i&gt;奇数的&lt;/b&gt;&lt;/i&gt;子元素(从1开始计数)&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:nth-child(formula)&lt;/td&gt;
    &lt;td&gt;匹配父元素的第n个子元素(从1开始计数)，formula(公式)格式为an+b，a和b为整数&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:nth-last-child()&lt;/td&gt;
    &lt;td&gt;与:nth-child()相同(从最后一个元素，由1开始向前计数)&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:first-child&lt;/td&gt;
    &lt;td&gt;匹配父元素的第一个子元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:last-child&lt;/td&gt;
    &lt;td&gt;匹配父元素的最后一个子元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:only-child&lt;/td&gt;
    &lt;td&gt;匹配父元素唯一一个子元素，若有多个元素，匹配为空&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:nth-of-type()&lt;/td&gt;
    &lt;td&gt;与:nth-child()的功能相同，只是此方法只计相同元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:nth-last-of-type()&lt;/td&gt;
    &lt;td&gt;与:nth-of-type()的功能相同，但是计数从最后一个元素开始&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:first-of-type&lt;/td&gt;
    &lt;td&gt;同名的元素中的第一个元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:last-of-type&lt;/td&gt;
    &lt;td&gt;同名元素中的最后一个元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:only-of-type&lt;/td&gt;
    &lt;td&gt;没有同名的同辈元素的元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;/table&gt;


&lt;p&gt;测试代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('.article:nth-child(1)')   // 匹配第一个class='article'元素，
// 无论&amp;lt;div&amp;gt;,&amp;lt;span&amp;gt;,&amp;lt;input&amp;gt;都行，(以后简称.article元素)

$('.article:nth-child(even)')     // 匹配偶数位置(2,4,6,8...)的.article元素

$('.article:nth-child(odd)')   // 匹配奇数位置(1,3,5,7...)的.article元素

$('.article:nth-child(2n+1)')   // 匹配奇数位置(1,3,5,7...)的.article元素
// 即当n为0,1,2,3...时，表达式2n+1的值即为匹配元素

$('.article:nth-last-child(2)')  // 匹配倒数第2个.article元素

$('.article:first-child')  // 匹配第一个.article元素

$('.article:last-child')  // 匹配最后一个.article元素

$('.article:only-child')  // 因为匹配元素中不止一个.article元素，匹配为空

$('.article:nth-of-type(2)')  // 匹配同类元素中的第二个元素，
// 首先会找到含有class＝'article'所有元素，然后根据元素名称分类，
// 最后匹配不同分类中的第二个元素(如果存在的话)
// 此处匹配段落二和段落四所在的元素

$('.article:nth-last-of-type(1)')   // 分别匹配同类元素中倒数第一个元素
// 此处匹配段落二和段落四，还有最后一个&amp;lt;input&amp;gt;元素

$('.article:first-of-type')  // 分别匹配同类元素中的第一个元素
// 此处匹配段落一、段落二所在元素，和最后一个&amp;lt;input&amp;gt;元素

$('.article:last-of-type')  // 分别匹配同来元素中的最后一个元素
// 雨nth-last-of-type(1)匹配结果相同

$('.article:only-of-type')  // 匹配当前jQuery对象元素中，没有同名同辈元素的元素
// 如当前jQuery对象元素中，仅仅包含一个&amp;lt;input class='article'&amp;gt;...&amp;lt;/input&amp;gt;元素，
// 那么此元素即为匹配元素
// 此处匹配最后一个&amp;lt;input&amp;gt;元素
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h2&gt;三、匹配元素间定位&lt;/h2&gt;

&lt;table width='100%'&gt;
&lt;tr&gt;&lt;th width='40%'&gt;选择符&lt;/th&gt;&lt;th&gt;匹配&lt;/th&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;:first&lt;/td&gt;
    &lt;td&gt;结果集中的第一个元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:last&lt;/td&gt;
    &lt;td&gt;结果集中的最后一个元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:not(selector)&lt;/td&gt;
    &lt;td&gt;结果集中与selector不匹配的所有元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:even&lt;/td&gt;
    &lt;td&gt;结果集中的偶数元素(从0开始计数)&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:odd&lt;/td&gt;
    &lt;td&gt;结果集中的奇数元素(从0开始计数)&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:eq(index)&lt;/td&gt;
    &lt;td&gt;结果集中下标(索引)为index的元素(从0开始计数)&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:gt(index)&lt;/td&gt;
    &lt;td&gt;结果集中位于给定下标(索引)之后的所有元素(从0开始计数)&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:lt(index)&lt;/td&gt;
    &lt;td&gt;结果集中位于给定下标(索引)之前的所有元素(从0开始计数)&lt;/td&gt;&lt;/tr&gt;
    
&lt;/table&gt;


&lt;p&gt;测试代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:first  :last  与 :first-child  :last-child结果一样
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于匹配元素间定位计数都是从0开始，而同辈元素间匹配是从1开始，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:even 与 :nth-child(odd) 结果一样；
:odd 与 nth-child(even) 结果一样
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相同的或者类似的此处不再介绍，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('.article:not(div,span)')  // 匹配jQuery包含class＝'article'的不为&amp;lt;dib&amp;gt;和&amp;lt;span&amp;gt;的元素
// 此处匹配最后一个&amp;lt;input&amp;gt;元素

$('.article:eq(0)')  //  匹配第一个.article元素，:eq(index)功能与nth-child(index)一样，
// 只不过:eq(index)从下标从0开始计数

$('.article:gt(3)')  // 匹配从第4个.article元素之后的所有元素(不包括第四个)

$('.article:lt(3)')   // 匹配从第4个.article元素之前的所有元素(不包括第四个)，
// 此处匹配前三个.article元素
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h2&gt;四、属性匹配&lt;/h2&gt;

&lt;table width='100%'&gt;
&lt;tr&gt;&lt;th width='40%'&gt;选择符&lt;/th&gt;&lt;th&gt;匹配&lt;/th&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;[attr]&lt;/td&gt;
    &lt;td&gt;匹配带有属性attr的元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;[attr='val']&lt;/td&gt;
    &lt;td&gt;匹配attr属性的值为val的元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;[attr!='val']&lt;/td&gt;
    &lt;td&gt;匹配attr属性值不为val的元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;[attr^='val']&lt;/td&gt;
    &lt;td&gt;匹配attr属性值以val开头的元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;[attr$='val']&lt;/td&gt;
    &lt;td&gt;匹配attr属性值以val结尾的元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;[attr*='val']&lt;/td&gt;
    &lt;td&gt;匹配attr属性值包含字符串val的元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;[attr~='val']&lt;/td&gt;
    &lt;td&gt;匹配attr属性值是多个空格分开的字符串，其中一个为val的元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;[attr|='val']&lt;/td&gt;
    &lt;td&gt;匹配attr属性值为val，或者以val开头后面跟一个连接符(-)的元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;/table&gt;


&lt;p&gt;测试代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('article &amp;gt; [href]')  // 匹配包含class＝'article'元素的子元素中，带有href属性的元素
// 此处为所有的a元素，如果在&amp;lt;p&amp;gt;元素中也包含a元素，将不会匹配在内

$('article [href]')  // 匹配包含class＝'article'元素所有后代元素中，带有href属性的元素
// 与上面一个一样，匹配所有a元素，包含在&amp;lt;p&amp;gt;元素中的&amp;lt;a href=''&amp;gt;元素

$('.article [href='#']')   // 匹配包含class＝'article'元素所有后代元素中，带有href属性的元素
// 且属性值为'#'的元素

[href!='www.baidu.com']  // 匹配属性href不为‘www.baidu.com’的元素

[href^='www']  // 匹配所有包含属性href，且href属性值以‘www’开头的元素

[href$='com']  // 匹配所有包含属性href，且href属性值以‘com’结尾的元素

[href*='baidu']  // 匹配所有包含属性href，且href属性值中包含‘baidu’的元素

[class~='hover']  // 匹配class='hover article blsf sflsj'的元素

[class|='my']   // 匹配class='my'或class='my-xxx'的元素
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h2&gt;五、表单匹配&lt;/h2&gt;

&lt;table width='100%'&gt;
&lt;tr&gt;&lt;th width='40%'&gt;选择符&lt;/th&gt;&lt;th&gt;匹配&lt;/th&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;:input&lt;/td&gt;
    &lt;td&gt;匹配所有&amp;lt;input&amp;gt;、&amp;lt;select&amp;gt;、&amp;lt;textarea&amp;gt;、&amp;lt;button&amp;gt;的元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:text&lt;/td&gt;
    &lt;td&gt;匹配type='text'的&amp;lt;input&amp;gt;元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:password&lt;/td&gt;
    &lt;td&gt;匹配type='password'的&amp;lt;input&amp;gt;元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:file&lt;/td&gt;
    &lt;td&gt;匹配type='file'的&amp;lt;input&amp;gt;元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:radio&lt;/td&gt;
    &lt;td&gt;匹配type='radio'的&amp;lt;input&amp;gt;元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:checkbox&lt;/td&gt;
    &lt;td&gt;匹配type='checkbox'的&amp;lt;input&amp;gt;元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:submit&lt;/td&gt;
    &lt;td&gt;匹配type='submit'的&amp;lt;input&amp;gt;元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:image&lt;/td&gt;
    &lt;td&gt;匹配type='image'的&amp;lt;input&amp;gt;元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:reset&lt;/td&gt;
    &lt;td&gt;匹配type='reset'的&amp;lt;input&amp;gt;元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:button&lt;/td&gt;
    &lt;td&gt;匹配type='button'的&amp;lt;input&amp;gt;元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:enabled&lt;/td&gt;
    &lt;td&gt;匹配启用的表单元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:disabled&lt;/td&gt;
    &lt;td&gt;匹配禁用的表单元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:checked&lt;/td&gt;
    &lt;td&gt;匹配选中的复选框和单选按钮元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:selected&lt;/td&gt;
    &lt;td&gt;匹配选中的&amp;lt;option&amp;gt;元素&lt;/td&gt;&lt;/tr&gt;

&lt;/table&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h2&gt;六、自定义选择符&lt;/h2&gt;

&lt;table width='100%'&gt;
&lt;tr&gt;&lt;th width='40%'&gt;选择符&lt;/th&gt;&lt;th&gt;匹配&lt;/th&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;:root&lt;/td&gt;
    &lt;td&gt;文档的根节点&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:header&lt;/td&gt;
    &lt;td&gt;标题元素(如&amp;lt;h1&amp;gt;、&amp;lt;h2&amp;gt;等)&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:animated&lt;/td&gt;
    &lt;td&gt;匹配当前jQuery对象元素中，其动画正在播放的元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:contains(text)&lt;/td&gt;
    &lt;td&gt;匹配当前jQuery对象元素中，包含给定文本text的元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:empty&lt;/td&gt;
    &lt;td&gt;匹配当前jQuery对象元素中，不包含子节点的元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:has(selector)&lt;/td&gt;
    &lt;td&gt;匹配当前jQuery对象元素中，后代元素中有和selector匹配的元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:parent&lt;/td&gt;
    &lt;td&gt;匹配当前jQuery对象元素中，包含子节点的元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:hidden&lt;/td&gt;
    &lt;td&gt;匹配当前jQuery对象元素中，隐藏的元素，包括通过css隐藏的元素和&amp;lt;input type='hidden' /&amp;gt;&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:visible&lt;/td&gt;
    &lt;td&gt;匹配当前jQuery对象元素中，显示的元素(即与:hidden相反的元素)&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:focus&lt;/td&gt;
    &lt;td&gt;匹配当前jQuery对象元素中，获得焦点的元素&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:lang(language)&lt;/td&gt;
    &lt;td&gt;匹配当前jQuery对象元素中，具有指定语言代码的元素(即指定了lang属性，或在&amp;lt;meta&amp;gt;标签中申明的)&lt;/td&gt;&lt;/tr&gt;
    
&lt;tr&gt;&lt;td&gt;:target&lt;/td&gt;
    &lt;td&gt;匹配URI标识符指向的目标元素&lt;/td&gt;&lt;/tr&gt;

&lt;/table&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未完待续。。。&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Jquery Source Analysis Css</title>
   <link href="http://www.blogways.net/blog/2014/08/22/jQuery-source-analysis-css.html"/>
   <updated>2014-08-22T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/08/22/jQuery-source-analysis-css</id>
   <content type="html">&lt;h2&gt;一、CSS样式&lt;/h2&gt;

&lt;p&gt;首先，看一下jQuery中提供的修改CSS样式的方法：(1)&lt;code&gt;.css( key )&lt;/code&gt;；(2)&lt;code&gt;.css( key, value )&lt;/code&gt;；(3)&lt;code&gt;.css( obj )&lt;/code&gt;，都是用来修改html的样式的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;css( key )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;取得css属性key的值，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.css('background-color');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;取得匹配元素的&lt;code&gt;background-color&lt;/code&gt;元素的值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.css(['background-color', 'font-size']);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;取得匹配元素的&lt;code&gt;background-color&lt;/code&gt;和&lt;code&gt;font-size&lt;/code&gt;属性的值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;css( key, value )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;设置css属性key的只为传入的value，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.css( 'background-color', '#0000ff' );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将匹配元素的&lt;code&gt;background-color&lt;/code&gt;背景颜色设置为&lt;code&gt;#0000ff&lt;/code&gt;蓝色。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;css( obj )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;根据传入的key-value参数设置css属性值，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.css({
    background-color: '#0000ff',
    font-size: 15px,
    float: left;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;闯入参数为一个&lt;strong&gt;属性 - 值&lt;/strong&gt;一一对应的css属性对象，jQuery会为其一一对应的设置对应的css值。&lt;/p&gt;

&lt;p&gt;利用两个按钮，调整某段落文字的大小：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// html
&amp;lt;p class='p1'&amp;gt;段落一，测试文字！！修改CSS样式！&amp;lt;/p&amp;gt;
&amp;lt;p class='p2'&amp;gt;段落二，测试文字！！修改CSS样式！&amp;lt;/p&amp;gt;
&amp;lt;button id='bigger'&amp;gt;变大&amp;lt;/button&amp;gt;
&amp;lt;button id='smaller'&amp;gt;变小&amp;lt;/button&amp;gt;

// script
var $p = $('p');
$('button').on('click', functiono(){
    var num = parseFloat($p.css('font-size'));
    var tmp = this.id == 'bigger' ? num * 1.1 : num / 1.1; 
    $p.css('font-size',num);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码很简单，不难，此处不再说明。&lt;/p&gt;

&lt;h2&gt;二、效果方法&lt;/h2&gt;

&lt;h3&gt;1、预定义效果&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;显示和隐藏元素&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;基本的&lt;code&gt;.hide()&lt;/code&gt;和&lt;code&gt;.show()&lt;/code&gt;不带任何参数，跟使用&lt;code&gt;.css('display', 'none')&lt;/code&gt;或&lt;code&gt;.css('display', 'block等其它')&lt;/code&gt;类似，用于显示和隐藏匹配元素，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// html
&amp;lt;p class='p1'&amp;gt;段落一，测试文字！！修改CSS样式！&amp;lt;/p&amp;gt;
&amp;lt;p class='p2' style='display: none;'&amp;gt;段落二，测试文字！！修改CSS样式！&amp;lt;/p&amp;gt;
&amp;lt;p class='p3'&amp;gt;段落三，测试文字！！修改CSS样式！&amp;lt;/p&amp;gt;

// script
$('.p1').hide();    // 隐藏段落一
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的script代码，运行后会隐藏段落一，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('.p1').show();    // 显示段落二
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在段落二的html代码中，通过style属性为其指定了一个内联的CSS属性&lt;code&gt;display&lt;/code&gt;，并将其设置为none，那么默认情况下，段落二将不会显示出来（默认是隐藏状态），在调用了上面的代码之后，段落二将会显示到界面上。&lt;/p&gt;

&lt;p&gt;当为&lt;code&gt;.show()&lt;/code&gt;和&lt;code&gt;.hide()&lt;/code&gt;传递参数时，就会产生像动画一样的，持续性效果。对于jQuery提供的任何效果方法，都可以为其指定两种预设的速度参数：slow和fast。&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;.show('slow')&lt;/code&gt;会在600毫秒(0.6秒)内完成显示隐藏元素的效果，而传递参数为&lt;code&gt;'fast'&lt;/code&gt;时的时间为200毫秒(0.2秒)，而如果不显示的指定速度的参数，jQuery会默认在400毫秒(0.4秒)内完成执行的效果。&lt;/p&gt;

&lt;p&gt;而如果想要指定自己需要的运行速度参数，直接传递一个数值参数即可：&lt;code&gt;.hide(999)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;当然jQuery在隐藏显示元素中，不仅仅只为我们提供了这两个方法，还有一个&lt;code&gt;toggle()&lt;/code&gt;方法，这个方法会显示或隐藏匹配的元素：当隐藏的元素调用此方法后会显示出来，而显示的元素调用此方法后会被隐藏。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('&amp;lt;button&amp;gt;toggle&amp;lt;/button&amp;gt;')
    .appendTo('body')
    .click(function(){
        $('p').toggle('fast');
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码在&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;元素后面添加一个按钮，绑定一个单击事件，点击显示或隐藏所有段落。&lt;/p&gt;

&lt;p&gt;而上面介绍的3个方法在接受一个数值作为显示、隐藏元素速度的同时，还可以传递第二个参数，作为一个回调函数，即当完成了显示、隐藏的任务后，调用该回调函数，原型入下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.show('fast', function(){...});
.hide('slow', function(){...});
.toggle(1000, function(){...});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;淡入、淡出&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;jQuery除了提供简单的隐藏显示的方法之外，还提供了另一些不同持续效果的隐藏显示方法，这里要将的是淡入和淡出。&lt;/p&gt;

&lt;p&gt;跟前面的隐藏显示元素一样，提供了三个方法，都能接收数值作为速度参数，同样也可以接收一个函数作为回调函数，原型如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.fadeIn([speed], [callback])
.fadeOut([speed], [callback])
.fadeToggle([speed], [callback])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其使用方法跟前面一样，不再详细给出。&lt;/p&gt;

&lt;p&gt;其中还涉及到一个&lt;code&gt;.fadeTo(speed, opacity, [callback])&lt;/code&gt;，这个方法可以调整匹配元素的不透明度，感兴趣的可以尝试一下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('&amp;lt;button&amp;gt;fadeTo&amp;lt;/button&amp;gt;')
    .appendTo('body')
    .click(function(){
        $('p').fadeTo(1000, 0.2);
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码，通过想html中添加一个带事件click处理程序的按钮，在其单击事件中，通过&lt;code&gt;.fadeTo&lt;/code&gt;改变所有段落的不透明度(在1秒内，将不透明度由1 -&gt; 0.2)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;滑入、滑出&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;滑入和滑出是jQuery提供的另一种显示、隐藏元素的方法，接收的参数跟前面两种方法完全一样，只是其持续效果不同，原型如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.slideDown([speed], [callback])
.slideUp([speed], [callback])
.slideToggle([speed], [callback])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用方法不在给出！&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未完待续。。。&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Jquery Source Analysis Dom</title>
   <link href="http://www.blogways.net/blog/2014/08/21/jQuery-source-analysis-dom.html"/>
   <updated>2014-08-21T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/08/21/jQuery-source-analysis-dom</id>
   <content type="html">&lt;h2&gt;一、插入新元素&lt;/h2&gt;

&lt;p&gt;首先，操作DOM要分为两类，(1)操作属性；(2)操作元素；而此处暂时只分析操作DOM树中的元素。&lt;/p&gt;

&lt;p&gt;在学习jQuery以来，我们使用最多的要数&lt;code&gt;$()&lt;/code&gt;了，通过传递document判断文档是否加载完成，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(....);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过传递一个CSS选择符来选择DOM树中的元素，生成一个包含所选元素的jQuery对象，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('.div')   // 选择DOM树中所有类名为“div”的元素，即class='div'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在再向大家介绍&lt;code&gt;$()&lt;/code&gt;的另一个用法，就是创建新的DOM元素，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('&amp;lt;div class=&quot;create by jquery&quot;&amp;gt;create by jquery&amp;lt;/div&amp;gt;');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就像上面代码所示，只要为&lt;code&gt;$()&lt;/code&gt;传递一个html的字符串，jQuery将会创建一个对应的DOM元素，当然这仅仅是创建了一个DOM元素，没有添加到DOM中，因而无法显示出来！&lt;/p&gt;

&lt;p&gt;而jQuery中将创建元素插入到DOM树的方法有八个，它们分别是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.append   / .prepend   / .after       / .before
.appendTo / .prependTo / .insertAfter / .insertBefore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它们的功能都是插入元素，但是其插入方式有比较大的差异。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;.append( content )和.appendTo( selector )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;append，在所以匹配元素的&lt;strong&gt;内部&lt;/strong&gt;的&lt;strong&gt;末尾&lt;/strong&gt;插入content，匹配元素就是调用此方法的jQuery对象中所包含的DOM元素，&lt;/p&gt;

&lt;p&gt;appendTo，将匹配的元素插入到selector选择器匹配的元素的&lt;strong&gt;内部&lt;/strong&gt;的&lt;strong&gt;末尾&lt;/strong&gt;中，当前这里匹配的元素跟上面的是一样的，可能唯一有些区别的是，这里的匹配元素可以使用上面所说的方法创建的jQuery对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('body').append('&amp;lt;div class=&quot;create by jquery&quot;&amp;gt;create by jquery&amp;lt;/div&amp;gt;');

$('&amp;lt;div class=&quot;create by jquery&quot;&amp;gt;create by jquery&amp;lt;/div&amp;gt;').appendTo('body');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面所示两行代码，虽然书写方式不同，但是其含义与实现的功能都是一样的，就是将html代码，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;create by jquery&quot;&amp;gt;create by jquery&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加到&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;元素的末尾，而实际上也真是这样，可以将代码复制到&lt;a href=&quot;http://jsfiddle.net/&quot; title=&quot;JSFiddle.net&quot;&gt;JSFiddle.net&lt;/a&gt;进行测试，看是否将元素插入到了DOM树中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;.prepend( content )和.prependTo( selector )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这两个函数与前面的append与appendTo类似，只不过这两个函数是将元素插入匹配元素&lt;strong&gt;内部&lt;/strong&gt;的&lt;strong&gt;开始&lt;/strong&gt;，而不是末尾，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('body').prepend('&amp;lt;div class=&quot;create by jquery&quot;&amp;gt;create by jquery&amp;lt;/div&amp;gt;');

$('&amp;lt;div class=&quot;create by jquery&quot;&amp;gt;create by jquery&amp;lt;/div&amp;gt;').prependTo('body');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果就不再过多的描述了，感兴趣的可以去&lt;a href=&quot;http://jsfiddle.net/&quot; title=&quot;JSFiddle.net&quot;&gt;JSFiddle.net&lt;/a&gt;进行测试！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;.after( content )和.insertAfter( selector )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;after，在每个匹配元素&lt;em&gt;外部&lt;/em&gt;的后面插入content，&lt;/p&gt;

&lt;p&gt;insertAfter，将匹配的元素插入到selector选择符匹配的元素的&lt;strong&gt;外部&lt;/strong&gt;的后面，&lt;/p&gt;

&lt;p&gt;这里要说一下的是，这里的&lt;strong&gt;外部&lt;/strong&gt;和前面的&lt;strong&gt;内部&lt;/strong&gt;，将的是元素的外部或内部，其内在含义就是：&lt;/p&gt;

&lt;p&gt;(1)、在内部插入元素，表示将插入的元素作为自己的内容插入，即对某个&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素调用内部插入元素方法，那么结果就是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;（原来的内容）+（添加的内容）&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原来的内容加上新添加的内容作为行的&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素的内容。&lt;/p&gt;

&lt;p&gt;(2)、在外部插入元素，表示将新插入的元素灬内容作为自动的兄弟结点，例如对class为div的元素进行&lt;strong&gt;外部&lt;/strong&gt;插入一个class为after的&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素，结果就如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class='div'&amp;gt; content  &amp;lt;/div&amp;gt;
&amp;lt;div class='after'&amp;gt; content 1 &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;.before( content )和.insertBefore( selector )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这两个方法与after和insertAfter类似，都是将内容插入到匹配元素&lt;strong&gt;外部&lt;/strong&gt;，而不同的是这两个方法是将内容插入匹配元素的&lt;strong&gt;外部&lt;/strong&gt;的&lt;strong&gt;前面&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('.div').before('&amp;lt;div class=&quot;before&quot;&amp;gt; content &amp;lt;/div&amp;gt;');

$('&amp;lt;div class=&quot;before&quot;&amp;gt; content &amp;lt;/div&amp;gt;').insertBefore('.div');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两行代码的含义是一样的，将&lt;code&gt;&amp;lt;div class='before'&amp;gt; content &amp;lt;/div&amp;gt;&lt;/code&gt;作为所以包含class为div的元素兄长结点插入，即将该html插入到匹配结点之前，结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class='before'&amp;gt; content &amp;lt;/div&amp;gt;
&amp;lt;div class='div'&amp;gt; content &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;二、移动元素&lt;/h2&gt;

&lt;p&gt;用于测试的html文档：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;div class='div'&amp;gt;
            &amp;lt;span class='span'&amp;gt;&amp;amp;lt;span&amp;amp;gt;&amp;lt;a class='a' href='#'&amp;gt;&amp;amp;lt;a&amp;amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt;
            &amp;lt;p class='p'&amp;gt;&amp;amp;lt;p&amp;amp;gt;&amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面通过&lt;code&gt;$()&lt;/code&gt;创建DOM元素，然后通过8个方法将其添加到DOM树中，其中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.appendTo / .prependTo / .insertAfter / .insertBefore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这四个方法调用对象为jQuery实例对象，即这四个方法运行的上下文环境是一个jQuery对象实例，而接收的参数为一个CSS选择符，因而它们能完成一项感觉跟它们完全没关系的功能。&lt;/p&gt;

&lt;p&gt;它们可以作为插入节点元素的方法，但是这四个方法同样可以移动DOM中元素节点的位置；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('.a').appendTo('body');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行上面的jQuery代码过后，可以看到如下的html：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;div class='div'&amp;gt;
            &amp;lt;span class='span'&amp;gt;&amp;amp;lt;span&amp;amp;gt;&amp;lt;/span&amp;gt;
            &amp;lt;p class='p'&amp;gt;&amp;amp;lt;p&amp;amp;gt;&amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;a class='a' href='#'&amp;gt;&amp;amp;lt;a&amp;amp;gt;&amp;lt;/a&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，&lt;code&gt;.appendTo&lt;/code&gt;和&lt;code&gt;.prependTo&lt;/code&gt;继承了它们是在匹配元素&lt;strong&gt;内部&lt;/strong&gt;操作的，那么由此可见&lt;code&gt;insertAfter&lt;/code&gt;和&lt;code&gt;insertBefore&lt;/code&gt;将会是在匹配元素&lt;strong&gt;外部&lt;/strong&gt;操作的，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('.a').insertAfter('body');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;div class='div'&amp;gt;
            &amp;lt;span class='span'&amp;gt;&amp;amp;lt;span&amp;amp;gt;&amp;lt;/span&amp;gt;
            &amp;lt;p class='p'&amp;gt;&amp;amp;lt;p&amp;amp;gt;&amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/body&amp;gt;
    &amp;lt;a class='a' href='#'&amp;gt;&amp;amp;lt;a&amp;amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;/html&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了这四个方法，就可以根据需求在DOM树中，将需要的节点移动到另一个位置。&lt;/p&gt;

&lt;h2&gt;三、包装元素&lt;/h2&gt;

&lt;p&gt;有时候，需要给很多个段落（即，&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;元素的内容）编号时，有人可能会想用循环为每个元素编号，或者高大上一点通过each遍历来实现，在学习jQuery之前我可能跟你一样，在学了jQuery之后，再也不需要那么麻烦了，jQuery想到了这一块，为我们提供了相应的方法，首先来看下一下效果吧，html如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;段落一，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;段落二，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;段落三，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;段落四，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;段落五，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;jQuery中提供了相应的包装元素的方法：&lt;code&gt;.wrap( content )&lt;/code&gt;、&lt;code&gt;.wrapAll( content )&lt;/code&gt;以及&lt;code&gt;.wrapInner( content )&lt;/code&gt;方法；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;wrap( content )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;将匹配的每个元素包装在content中，&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;wrapAll( content )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;将匹配的每个元素作为一个党员包装在content中，&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;wrapInner( content )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;将匹配的每个元素&lt;strong&gt;内部的内容&lt;/strong&gt;包装在content中。&lt;/p&gt;

&lt;p&gt;有了这3个方法，相信实现起来不难了吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('p').wrapAll('&amp;lt;ol&amp;gt;&amp;lt;/ol&amp;gt;')
      .wrap('&amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;')
      .wrapInner('&amp;lt;i&amp;gt;&amp;lt;/i&amp;gt;');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先用一对闭合的&lt;code&gt;&amp;lt;ol&amp;gt;&amp;lt;/ol&amp;gt;&lt;/code&gt;（&lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt;元素用于有序编号，&lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;元素用于无序编号），通过&lt;code&gt;.wrapAll()&lt;/code&gt;方法，将所有的段落均包含在内，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ol&amp;gt;
    &amp;lt;p&amp;gt;段落一，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;段落二，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;段落三，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;段落四，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;段落五，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;
&amp;lt;/ol&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为调用&lt;code&gt;.wrapAll()&lt;/code&gt;方法返回的，是一个包装&lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt;元素之后的对所有段落元素的引用的jQuery对象，可以继续对其调用jQuery实例方法，&lt;code&gt;.wrap()&lt;/code&gt;将匹配的每一个元素包装在参数所给的内容中，则结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ol&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;p&amp;gt;段落一，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;p&amp;gt;段落二，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;p&amp;gt;段落三，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;p&amp;gt;段落四，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;p&amp;gt;段落五，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ol&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就完成了对所有段落的有序编号，只有两行代码，比自己写循环要简单非常非常的多，使用起来也非常的方便。&lt;/p&gt;

&lt;p&gt;在看到了两个包装方法的应用后，再来看下最后一个&lt;code&gt;.wrapInner()&lt;/code&gt;，将匹配元素每个元素&lt;strong&gt;内部的内容&lt;/strong&gt;包装在所给参数值，其含义很明显了，就是将段落的内容保存到常熟中，其运行结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// &amp;lt;i&amp;gt;：倾斜
&amp;lt;ol&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;p&amp;gt;&amp;lt;i&amp;gt;段落一，这仅仅是一些测试文字！&amp;lt;/i&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;p&amp;gt;&amp;lt;i&amp;gt;段落二，这仅仅是一些测试文字！&amp;lt;/i&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;p&amp;gt;&amp;lt;i&amp;gt;段落三，这仅仅是一些测试文字！&amp;lt;/i&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;p&amp;gt;&amp;lt;i&amp;gt;段落四，这仅仅是一些测试文字！&amp;lt;/i&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;p&amp;gt;&amp;lt;i&amp;gt;段落五，这仅仅是一些测试文字！&amp;lt;/i&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ol&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;四、替换&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;段落一，这仅仅是一些测试文字！&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;段落二，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;段落三，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在jQuery的DOM操作方法中，jQuery为我们提供了两个替换方面的方法：&lt;code&gt;.replaceWith( content )&lt;/code&gt;和&lt;code&gt;.replaceAll( selector )&lt;/code&gt;。还有两个设置匹配元素值的方法，也可以类似的看成是替换：&lt;code&gt;html()&lt;/code&gt;和&lt;code&gt;text()&lt;/code&gt;方法，&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;replaceWith( content )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;将匹配的元素替换为content，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('p').replaceWith('by replaceWith ! ');

// 结果
by replaceWith ! 
by replaceWith ! 
by replaceWith ! 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;replaceAll( selector )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;将selector选择符匹配的元素替换为匹配的元素，&lt;/p&gt;

&lt;p&gt;这里要说一下的就是，这里有两个匹配的元素，前面一个是selector（即参数）所选中的匹配元素，后面的一个是调用此方法的jQuery对象中包含的元素，即运行此方法上下文所包含的元素。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('&amp;lt;p&amp;gt;无段落序号，这仅仅是一些替代文字！&amp;lt;/p&amp;gt;').replaceAll('p');

// 结果
&amp;lt;p&amp;gt;无段落序号，这仅仅是一些替代文字！&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;无段落序号，这仅仅是一些替代文字！&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;无段落序号，这仅仅是一些替代文字！&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;html( [content] )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;函数参数content可省略，省略后调用此方法，会返回所有匹配元素中&lt;strong&gt;第一个元素&lt;/strong&gt;的HTML内容；若不省略content，会将每个匹配的元素的HTML内容读设置为content。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('p').html();  // &amp;lt;p&amp;gt;段落一，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;

$('p').first().html('&amp;lt;h2&amp;gt;设置HTML&amp;lt;/h2&amp;gt;');

// 结果
&amp;lt;p&amp;gt;&amp;lt;h2&amp;gt;设置HTML&amp;lt;/h2&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;段落二，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;段落三，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;text( [content] )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;跟&lt;code&gt;html()&lt;/code&gt;一样，省略content，则会返回&lt;strong&gt;所有匹配元素&lt;/strong&gt;的文本内容，返回一个字符串；若不省略content，则设置每个匹配元素的文本内容为传入值content。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('p').text();
// 段落一，这仅仅是一些测试文字！段落二，这仅仅是一些测试文字！段落三，这仅仅是一些测试文字！

$('p').text('&amp;lt;b&amp;gt;无段落序号，这仅仅是一些替代文字！&amp;lt;/b&amp;gt;');

// 结果
&amp;lt;p&amp;gt;&amp;amp;lt;b&amp;amp;gt;无段落序号，这仅仅是一些替代文字！&amp;amp;lt;/b&amp;amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;&amp;amp;lt;b&amp;amp;gt;无段落序号，这仅仅是一些替代文字！&amp;amp;lt;/b&amp;amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;&amp;amp;lt;b&amp;amp;gt;无段落序号，这仅仅是一些替代文字！&amp;amp;lt;/b&amp;amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;五、复制元素&lt;/h2&gt;

&lt;p&gt;复制元素jQuery中只提供了一个方法&lt;code&gt;clone( [ boolean ] )&lt;/code&gt;方法，&lt;/p&gt;

&lt;p&gt;默认情况下，&lt;code&gt;.clone()&lt;/code&gt;方法不会复制匹配的元素或其后代元素中绑定的事件，不过，当为此函数传递一个true的boolean值时，就可以连同事件一起赋值，即&lt;code&gt;.clone( true )&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// html
&amp;lt;button id='btn1'&amp;gt;测试复制&amp;lt;/button&amp;gt;

// js
$('#btn1').click(function(){
    alert('测试复制事件！');
});

$('#btn1').clone(true).appendTo('body');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试结果是，点击复制的按钮也会弹出警示框显示&lt;code&gt;测试复制事件！&lt;/code&gt;，而没有设置参数的时候，点击复制后的按钮不会有任何相应。&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未完待续。。。&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Jquery Source Analysis Event(2)</title>
   <link href="http://www.blogways.net/blog/2014/08/20/jQuery-source-analysis-event%282%29.html"/>
   <updated>2014-08-20T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/08/20/jQuery-source-analysis-event(2)</id>
   <content type="html">&lt;h2&gt;二、源码分析&lt;/h2&gt;

&lt;h3&gt;1、源码结构&lt;/h3&gt;

&lt;p&gt;event的源码实现结构如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function returnTrue() {};

function returnFalse() {};

// 返回当前获得焦点的元素
function safeActiveElement() {};

jQuery.event = {

    global: {},

    // 绑定事件处理
    add: function( elem, types, handler, data, selector ) {},

    // 移除事件处理
    remove: function( elem, types, handler, selector, mappedTypes ) {},

    // 触发事件
    trigger: function( event, data, elem, onlyHandlers ) {},

    // 分派（执行）事件处理程序
    dispatch: function( event ) {},

    // 组装事件处理队列
    handlers: function( event, handlers ) {},

    // 封装jQuery.Event原始对象，修正event事件属性
    fix: function( event ) {},

    // 事件属性
    props: &quot;altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey &quot;
                        +&quot;relatedTarget shiftKey target timeStamp view which&quot;.split(&quot; &quot;),

    fixHooks: {},

    keyHooks: {},

    mouseHooks: {},

    // 事件特例，如load、click、focus、blur、beforeunload等
    special: {},

    // 模拟事件触发
    simulate: function( type, elem, event, bubble ) {}

};

// jQuery事件对象，模拟实现部分W3C标准的DOM 3级别事件模型，统一了事件的属性
jQuery.Event = function( src, props ) {};

// jQuery事件对象原型
jQuery.Event.prototype = {
    // 是否已经阻止元素默认行为
    isDefaultPrevented: returnFalse,
    // 是否已经停止了事件传播
    isPropagationStopped: returnFalse,
    // 是否已经立即停止了事件传播
    isImmediatePropagationStopped: returnFalse,

    // 阻止元素的浏览器默认行为
    preventDefault: function() {},
    // 停止事件传播
    stopPropagation: function() {},
    // 立即停止事件传播
    stopImmediatePropagation: function() {}
};

// 如果不支持submit事件冒泡（IE），则submit事件委托
if ( !support.submitBubbles ) {};
// IE change事件委托，及checkbox/radio事件修正
if ( !support.changeBubbles ) {};
// 如果不支持focusin事件冒泡，则转为focus实现（focusin -&amp;gt; focus, focusout -&amp;gt; blur）
if ( !support.focusinBubbles ) {};

jQuery.fn.extend({
    // 完成一些参数调整，调用内部add方法完成事件绑定
    on: function( types, selector, data, fn, /*INTERNAL*/ one ) {},
    // 元素只能运行一次事件处理器函数
    one: function( types, selector, data, fn ) {},
    // 解除绑定：删除一个之前附加的事件句柄
    off: function( types, selector, fn ) {},
    // 执行事件处理函数和默认行为
    trigger: function( type, data ) {},

    // 执行事件处理函数，不执行默认行为，只触发匹配的第一个元素，不返回jQuery对象
    triggerHandler: function( type, data ) {}
});

jQuery.each( (&quot;blur focus focusin focusout load resize scroll unload click dblclick &quot; +
    &quot;mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave &quot; +
    &quot;change select submit keydown keypress keyup error contextmenu&quot;)
    .split(&quot; &quot;), function( i, name ) {

    // 处理事件绑定
    jQuery.fn[ name ] = function( data, fn ) {
        return arguments.length &amp;gt; 0 ?
            this.on( name, null, data, fn ) :
            this.trigger( name );
    };
});

jQuery.fn.extend({
    // 便捷方法，在匹配的元素上绑定两个事件处理函数，
    // 鼠标移入时执行handlerIn，移出时执行handlerOut
    hover: function( fnOver, fnOut ) {},
    // 绑定
    bind: function( types, data, fn ) {},
    // 解绑定：删除一个之前附加的事件处理程序handler
    unbind: function( types, fn ) {},
    // 事件委托，调用on方法实现
    delegate: function( selector, types, data, fn ) {},
    // 删除事件委托，调用off实现
    undelegate: function( selector, types, fn ) {}
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;jQuery对事件的绑定和委托及接触是通过on和off方法来实现，而on和off方法则是通过调用jQuery.event的内部方法add来remove实现，而add和remove这是调用浏览器的原生事件addEventListener/removeEventListener或attachEvent/detachEvent来实现处理指定和删除事件处理程序，其实现的方向如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bind,delegate/unbind,undelegate -&amp;gt; on/off -&amp;gt; add/remove -&amp;gt; addEventListener,attachEvent/removeEventListener,detachEvent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般情况下，jQuery中实现添加事件处理程序都是通过on或者事件特例（click，load，focus等）来实现的，相应的移除事件处理程序则是通过使用off方法来实现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;.bind( types,data, fn )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.bind()&lt;/code&gt;方法用于直接附加一个事件处理程序到元素上。&lt;/p&gt;

&lt;p&gt;处理程序附加到jQuery对象中当前选中的元素，所以，在&lt;code&gt;.bind()&lt;/code&gt;绑定事件的时候，这些元素必须已经存在，很明显就是直接调用的,没利用委托机制。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;.delegate( selector, types, data, fn )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;delegate事件委托其实质就是调用了on方法，将此方法的参数传递给on方法，让其代调用更具体的内部函数来实现事件委托，其源码如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;delegate: function( selector, types, data, fn ) {
    return this.on( types, selector, data, fn );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由此可见，delegate就是调用了on方法，并将参数传递过去，自己本身并没有做任何的处理，因而可以变相的将dalegate视为on方法的别名。例如，将一个&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素的事件处理程序委托到祖先元素&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素上，html请参考上一篇开头的html文档&lt;a href=&quot;/blog/2014/08/19/jQuery-source-analysis-event(1).html&quot; title=&quot;jQuery源码解读[7] -- Event事件处理（1）&quot;&gt;Event事件处理（1）&lt;/a&gt;，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('.div').on('click', '.a', function(){
    alert('delegate by on()');
});

$('.div').delegate('.a', 'click', function(){
    alert('delegate by delegate()');
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面两种方法实现的功能都是一样的，将&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素的click事件委托给&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素。&lt;/p&gt;

&lt;p&gt;任何时候只要有事件冒泡到&lt;code&gt;$('.div')&lt;/code&gt;上，它就查看该事件是否是click事件，以及该事件的目标元素是否与CCS选择器相匹配。如果两种检查的结果都为真的话，它就执行函数。&lt;/p&gt;

&lt;h3&gt;2、源码分析&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;add( elem, types, handler, data, selector )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;elem：事件绑定的元素名称&lt;/p&gt;

&lt;p&gt;types：事件处理名称，如：click、bulr、mouseout等&lt;/p&gt;

&lt;p&gt;selector： 一个选择器字符串，用于过滤出被选中的元素中能触发事件的后代元素&lt;/p&gt;

&lt;p&gt;data：当一个事件被触发时，要传递给事件处理函数的&lt;/p&gt;

&lt;p&gt;handler：事件被触发时，执行的函数&lt;/p&gt;

&lt;p&gt;其部分源码如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;add: function( elem, types, handler, data, selector ) {
    // ...

    // 尝试取出事件的namespace，如click.bbb.ccc中的bbb.ccc
    tmp = rtypenamespace.exec( types[t] ) || [];
    // 取出事件处理类型，如click
    type = origType = tmp[1];
    // 取出事件命名空间，如bbb.ccc，并根据&quot;.&quot;分隔成数组
    namespaces = ( tmp[2] || &quot;&quot; ).split( &quot;.&quot; ).sort();

    // 事件是否会改变当前状态，如果会则使用特殊事件
    special = jQuery.event.special[ type ] || {};

    // 根据是否已定义selector，决定使用哪个特殊事件api，如果没有非特殊事件，则用type
    type = ( selector ? special.delegateType : special.bindType ) || type;

    // 更具状态改变后的特殊事件
    special = jQuery.event.special[ type ] || {};

    // 组装用于特殊事件处理的对象
    handleObj = jQuery.extend({
            type: type,
            origType: origType,
            data: data,
            handler: handler,
            guid: handler.guid,
            selector: selector,
            needsContext: selector &amp;amp;&amp;amp; jQuery.expr.match.needsContext.test( selector ),
            namespace: namespaces.join(&quot;.&quot;)
        }, handleObjIn );

    // 第一次添加事件处理时，初始化事件处理函数队列
    if ( !(handlers = events[ type ]) ) {
        handlers = events[ type ] = [];
        handlers.delegateCount = 0;

        // 如果特殊事件处理程序函数返回false，使用addEventListener/attachEvent添加事件
        if ( !special.setup || special.setup.call( elem, data, namespaces, 
            eventHandle ) === false ) {
            // 为元素绑定全局事件处理函数
            if ( elem.addEventListener ) {
                elem.addEventListener( type, eventHandle, false );
            } else if ( elem.attachEvent ) {
                elem.attachEvent( &quot;on&quot; + type, eventHandle );
            }
        }
    }

    // 通过特殊事件add处理事件
    if ( special.add ) {
        // 添加事件
        special.add.call( elem, handleObj );
        // 设置处理函数的ID
        if ( !handleObj.handler.guid ) {
            handleObj.handler.guid = handler.guid;
        }
    }

    // 将事件处理函数推入处理列表
    if ( selector ) {
        handlers.splice( handlers.delegateCount++, 0, handleObj );
    } else {
        handlers.push( handleObj );
    }

    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从这里的源代码看，对于没有特殊事件特有监听方法和普通事件都用addEventListener来添加事件。而有特有监听方法的特殊事件，则调用相应的&lt;code&gt;special.add.call&lt;/code&gt;来添加事件。总之而言，此方法是jQuery中为元素添加事件监听器的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;on( types, selector, data, fn, one )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;types：事件处理程序名称&lt;/p&gt;

&lt;p&gt;selector：一个选择器字符串，用于过滤出被选中的元素中能触发事件的后代元素&lt;/p&gt;

&lt;p&gt;data：当一个事件被触发时，要传递给事件处理函数的&lt;/p&gt;

&lt;p&gt;fn：事件触发时执行的程序&lt;/p&gt;

&lt;p&gt;one：近在内部使用，用于标识是否该事件只能被触发一次&lt;/p&gt;

&lt;p&gt;其源码如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
    var type, origFn;

    // types可以是一个由types/handlers组成的map对象
    if ( typeof types === &quot;object&quot; ) {
        // 如果selector不是字符串
        // 则将传参由( types-Object, selector, data )变成( types-Object, data )
        if ( typeof selector !== &quot;string&quot; ) {
            data = data || selector;
            selector = undefined;
        }

        // 遍历所有types，递归调用将事件绑定到当前元素上
        for ( type in types ) {
            this.on( type, selector, data, types[ type ], one );
        }
        return this;
    }
    // 如果data为空，且fn为空
    if ( data == null &amp;amp;&amp;amp; fn == null ) {
        // 则传参由( types, selector )变成( types, fn )
        fn = selector;
        data = selector = undefined;

    // 否则如果只是fn为空
    } else if ( fn == null ) {
        // 且selector为字符串
        if ( typeof selector === &quot;string&quot; ) {

            // 则传参从( types, selector, data )变成( types, selector, fn )
            fn = data;
            data = undefined;
        } else {
            // 否则传参从( type, selector, data )变成( types, data, fn )
            fn = data;
            data = selector;
            selector = undefined;
        }
    }
    //如果fn为false则变成一个return false的函数
    if ( fn === false ) {
        fn = returnFalse;
    } else if ( !fn ) {
        //如果fn现在还不存在，则直接return this
        return this;
    }

    if ( one === 1 ) {  // 如果one为1
        origFn = fn;  // 保存，并重定义fn
        fn = function( event ) {
            // 这个事件只触发一次，触发完成就用off取消掉
            jQuery().off( event );
            return origFn.apply( this, arguments );
        };
        // 使用相同的ID，为了未来好删除事件
        fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
    }
    // 对所有用jQuery.event.add来添加事件
    return this.each( function() {
        jQuery.event.add( this, types, fn, data, selector );
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的代码可以看出，其实on()方法大部分的代码都是在模拟重载on()方法的重载，还有一小段代码提供了one()方法的实现，若为某个事件标识了one（即只会触发一次），那么在on()方法中就会备份别改写一个回调函数（事件触发时执行的函数），&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;origFn = fn;  // 保存，并重定义fn
fn = function( event ) {
    // 这个事件只触发一次，触发完成就用off取消掉
    jQuery().off( event );
    return origFn.apply( this, arguments );
};
// 使用相同的guid，为了未来好删除事件
fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过回调函数传递的事件对象参数，    使用off()方法将该触发事件取消绑定，达到不会在触发下一次，即仅触发了本次一次的目的，在改写的回调函数中，通过&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;origFn.apply( this, arguments );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用未改写前的回调函数来实现触发后的事件处理，最后还讲副本及改写函数都设置一个统一的guid，以便未来好删除事件。&lt;/p&gt;

&lt;p&gt;而实际上on()方法最核心的代码其实就只有两行，就是最后两行代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return this.each( function() {
    jQuery.event.add( this, types, fn, data, selector );
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先此处的this是一个jQuery对象，引用的是希望被绑定事件的元素，就像&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('.div').on('click mouseleave', '.p', function(){....});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所示，当上面的代码运行到on()方法最后两行时，this指的就是&lt;code&gt;$('.div')&lt;/code&gt;所表示的jQuery对象。&lt;/p&gt;

&lt;p&gt;on()方法源码中，对当前jQuery对象调用each方法，调用&lt;code&gt;jQuery.event&lt;/code&gt;的内部函数add()方法，为当前jQuery对象所包含的所有DOM元素添加事件。由此可以看出，这些源码中最最核心的还是add/remove方法，其它的各种样式的方法都在在这两个基础的方法上扩展实现的。&lt;/p&gt;

&lt;p&gt;相应的事件的触发，最核心的也是&lt;code&gt;jQuery.event&lt;/code&gt;中的trigger()方法。&lt;/p&gt;

&lt;p&gt;从源码中可以看出，通过&lt;code&gt;jQuery.fn.extend&lt;/code&gt;扩展到jQuery实例对象中的所有事件方法，都是通过直接调用on，off，trigger方法，间接调用add，remove，trigger，fix等一系列&lt;code&gt;jQuery.event&lt;/code&gt;中的方法来实现实现的绑定、移除和触发的，当然前面也说过，最终将其添加到浏览器DOM上还是通过浏览器原生的addEventListener/attachEvent，removeEventListener/detachEvent来实现的。&lt;/p&gt;

&lt;p&gt;而jQuery中所做的就是在这些浏览器元素的添加事件监听方法的基础上，通过&lt;code&gt;jQuery.event&lt;/code&gt;对象，将原生的事件对象进行扩展与增强，然后实现功能更加强大的事件处理，最后将这些增强过后的事件处理接口（如：on, delegate, bind, off 等）扩展到jQuery实例对象中，暴露给用户使用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;简写绑定&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前面说的都是一些标准的，通用的事件处理，下面我们来看一下一些简写的事件处理，就像如下所示，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('.div').click(function(){....});      or    $('.div').change(function(){....});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些方法不用通过on()方法，并为其传递事件处理类型名称，而是直接通过类型名称来创建事件处理，不需要在像下面这样创建事件处理，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('.div').on('change', function(){....});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相比之下，简写事件处理显得更加语意明确，书写简单，一看就能知道需要触发的条件是什么。其实现源代码如下所示，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery.each( (&quot;blur focus focusin focusout load resize scroll unload click dblclick &quot; +
    &quot;mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave &quot; +
    &quot;change select submit keydown keypress keyup error contextmenu&quot;)
    .split(&quot; &quot;), function( i, name ) {

    // 处理事件绑定
    jQuery.fn[ name ] = function( data, fn ) {
        return arguments.length &amp;gt; 0 ?
            this.on( name, null, data, fn ) :
            this.trigger( name );
    };
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先通过&lt;code&gt;.split&lt;/code&gt;将所有的简写事件处理分为一个数组，然后使用&lt;code&gt;jQuery.each&lt;/code&gt;遍历这些简写事件处理，通过&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery.fn[ name ] = function( data, fn ) {
    return arguments.length &amp;gt; 0 ?
        this.on( name, null, data, fn ) :
        this.trigger( name );
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将其扩展到jQuery的实例对象当中去，万变不离其宗，虽然在创建事件处理的时候是通过这些简写事件名称来创建的，实际上这些事件的添加到元素、触发，还是通过&lt;code&gt;jQuery.event&lt;/code&gt;中基础的on()和trigger()方法来实现的。&lt;/p&gt;

&lt;h2&gt;三、示例&lt;/h2&gt;

&lt;p&gt;由于在前面一篇博文，介绍事件处理的一些概念的时候，已经应用了很多的示例，此处不在给出，如果需要查看，可以跳转！&lt;a href=&quot;/blog/2014/08/19/jQuery-source-analysis-event(1).html&quot; title=&quot;jQuery源码解读[7] -- Event事件处理（1）&quot;&gt;Event事件处理（1）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未完待续。。。&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Jquery Source Analysis Event(1)</title>
   <link href="http://www.blogways.net/blog/2014/08/19/jQuery-source-analysis-event%281%29.html"/>
   <updated>2014-08-19T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/08/19/jQuery-source-analysis-event(1)</id>
   <content type="html">&lt;h2&gt;一、前言&lt;/h2&gt;

&lt;h3&gt;1、事件传播&lt;/h3&gt;

&lt;p&gt;当页面上发生一个事件时，每个层次上的DOM元素都有机会处理借个时间，如一下html为例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class='div'&amp;gt;&amp;amp;lt;div&amp;amp;gt;
    &amp;lt;span class='span'&amp;gt;&amp;amp;lt;span&amp;amp;gt;
            &amp;lt;a class='a'&amp;gt;&amp;amp;lt;a&amp;amp;gt;&amp;lt;/a&amp;gt;
        &amp;lt;/span&amp;gt;
        &amp;lt;p class='p'&amp;gt;&amp;amp;lt;p&amp;amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当使用图形表示上面的html，其结构如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/div.png&quot; alt=&quot;对应的html图形化结构图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从上面可以看出，&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素位于&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;,&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;及更外层的元素内，那么在鼠标单击&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素所在的区域时，明显可以看出同时也单击了其所有的父辈元素，如span、div等。也就是说，在鼠标点击内部元素时，内部元素所有的直接父辈元素也应该能获得响应这次单击的机会。&lt;/p&gt;

&lt;p&gt;允许多个元素响应单击事件的策略叫做&lt;strong&gt;&lt;em&gt;事件捕获&lt;/em&gt;&lt;/strong&gt;，在事件捕获的工程中，最外层元素最先获得事件，然后向内将事件交给范围更小一级的可以捕获当前事件的元素，例如当点击&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素时，其捕获过程如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;document -&amp;gt; 外层元素 -&amp;gt; div -&amp;gt; span -&amp;gt; a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的外层元素就是div元素的所有直接父辈元素，值得注意的是，&lt;code&gt;document&lt;/code&gt;是所有DOM元素的父辈，即无论任何事件在捕获过程中，事件首先会交给&lt;code&gt;document&lt;/code&gt;，然后在向跟具体的触发事件元素传递。&lt;/p&gt;

&lt;p&gt;两外一种相反的策略叫做&lt;strong&gt;&lt;em&gt;事件冒泡&lt;/em&gt;&lt;/strong&gt;，即当事件发生时，会首先将事件传递给最具体的元素，此处为&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素，然后在逐级向外传递事件，直到停止事件传播或传递到了&lt;code&gt;document&lt;/code&gt;，理出当点击&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素时，其冒泡过程如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a -&amp;gt; span -&amp;gt; div -&amp;gt; 外层元素 -&amp;gt; document
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于不同的浏览器采用的不同的事件策略，因此在DOM标准规定了同事使用两种策略：首先，事件从一般元素到具体元素逐层&lt;strong&gt;捕获&lt;/strong&gt;，然后，事件再通过&lt;strong&gt;冒泡&lt;/strong&gt;返回DOM树的顶层，事件处理程序可以注册到这个过程中的任何一个阶段，而jQuery中，如无特殊说明，默认将处理程序注册到&lt;strong&gt;冒泡&lt;/strong&gt;阶段。&lt;/p&gt;

&lt;p&gt;虽然默认是将处理程序注册到&lt;strong&gt;冒泡&lt;/strong&gt;阶段，但是事件冒泡可能会导致一些无法预料的问题，例如当我们为&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素添加一个mouseout时间处理程序，当用户鼠标退出&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素时，会按照预期的一样触发事件处理程序，因为事件处理程序和触发事件元素都为&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;所以不会有其他元素响应这个事件，但是当用户鼠标指针在&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素内移动到&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素外时，会触发一个mouseout事件，然后向外传递到&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;时，会触发为&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素指定的事件处理程序，这种结果显然不是所期望的。&lt;/p&gt;

&lt;h3&gt;2、事件对象&lt;/h3&gt;

&lt;p&gt;要解决前面所说的事件&lt;strong&gt;冒泡&lt;/strong&gt;所产生的问题，就需要说到事件对象了，事件对象是一种DOM结构，它会在元素获得处理事件的机会时传递给被调用的事件的处理程序，就拿前面的例子来说，当&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素触发mouseout事件并冒泡到&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素时，event对象对传递给&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素上mouseout事件处理程序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;event.target属性&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;jQuery中，扩展了事件对象中的event.target属性（保存着发生事件的目标元素），使其在所有的浏览器中都能够是用这个属性，通过event.target，可以确定DOM中首先接收到事件的元素（即实际被单击的元素），而在事件处理程序中的this指针，是对处理事件的DOM元素的引用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function(){
    $('.div').on( 'mouseout', function(event){
        if( event.target == this ){
            alert('mouseout div');
        }
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码就是利用了enevt事件对象，很好的解决了前面所说的mouseout事件在冒泡阶段会导致的问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;event.stopPropagation()方法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;同时事件对象还提供了一个.stopPropagation()方法，用于完全阻止事件冒泡，与target类似，这个方法也是DOM标准的基本方法，但是在IE8及更早版本中无法使用，而在jQuery中扩展了这个方法，可以放心的使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function(){
    $('.div').click(function(){
        alert('div click');
    });
    $('.span').click(function(){
        alert('span click');
    });
    $('.a').click(function(event){
        alert('a click');
        event.stopPropagation();
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;同时添加单击事件分别显示消息，同时在&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素内调用&lt;code&gt;event.stopPropagation();&lt;/code&gt;，执行上面代码，当单击&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;元素时，会弹出&lt;code&gt;span click&lt;/code&gt;和&lt;code&gt;div click&lt;/code&gt;，但是在单击&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素时，只会弹出&lt;code&gt;a click&lt;/code&gt;，由此可见stopPropagation方法成功阻止了事件的冒泡，事件处理程序只会被当前元素中执行，且事件不会继续冒泡，那么其它元素也就不会再触发此事件处理程序了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;event.preventDefault()方法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;很多元素都会有默认的事件触发动作，例如：当点击一个&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素时，会默认跳转到指定了连接；当单击表单中的submit按钮，会默认提交当前表单。在实际操作中，我们可能会需要验证某些信息，而不希望这些元素执行默认操作，通常我们的做法是在JavaScript代码中&lt;code&gt;return false;&lt;/code&gt;，返回false这种做法实际上就是组合使用了.stopPropagation和.preventDefault()，阻止事件传播，阻止元素默认触发动作。&lt;/p&gt;

&lt;h3&gt;3、事件委托&lt;/h3&gt;

&lt;p&gt;事件冒泡虽然可能会导致一些问题，但是也为我们带来了很多的好处，而&lt;strong&gt;事件委托&lt;/strong&gt;就是利用冒泡策略来实现的，顾名思义，事件委托就是将事件处理程序委托给其它元素，让其代为处理某些元素的事件处理，当然此处的&lt;em&gt;其它元素&lt;/em&gt;是指其所有直接父辈元素。&lt;/p&gt;

&lt;p&gt;一种委托方式是通过&lt;code&gt;event.target&lt;/code&gt;来判断是否触发特定元素的委托事件，例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function(){
    $('.div').click(function(event){
        if($(event.target).is('.p')){
            alert('delegate p to div')
        } else {
            alert('div click');
        }
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上代码所示，鼠标点击&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;元素会弹出&lt;code&gt;delegate p to div&lt;/code&gt;，&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;元素的事件处理程序委托给了&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素，当用户单击&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;元素时，本身并无事件处理程序，因此向外冒泡，触发&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;的父元素&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素的事件处理程序，其中通过&lt;code&gt;event.target&lt;/code&gt;判断目标元素是&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;元素，因而调用相应的事件处理，弹出&lt;code&gt;dalegate p to div&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;首先要说明的是，&lt;code&gt;event.target&lt;/code&gt;引用的是触发事件元素的html文档，而不是一个jQuery对象，可以在传递了事件对象的处理程序中通过如下代码显示，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;console.log( event.target );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当单击了&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;元素时，输出结果如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/eventtarget.png&quot; alt=&quot;span的event.target&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因而使用&lt;code&gt;$(html标签)&lt;/code&gt;创建一个对应html标签的jQuery对象，然后通过&lt;code&gt;is()&lt;/code&gt;选中元素是否是希望的元素，如果是则执行委托事件处理，否则就执行其默认处理。&lt;/p&gt;

&lt;p&gt;而另一种事件委托方式，就是通过jQuery内置的事件委托，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('.div').on( 'click mouseleave', '.p', function(event){
    if( event.type == 'click' ){
        alert('delegate p\'s click to div');
    } else if(event.type == 'mouseleave' ){
        alert('delegate p\'s mouseleave to div');
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码所示，将&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;元素的click和mouseleave事件委托给了&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素，当单击&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;元素时，会弹出&lt;code&gt;delegate p's click to div&lt;/code&gt;，相应的当鼠标离开&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;元素区域时，会弹出&lt;code&gt;delegate p's mouseleave to div&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;由上面可知，可以将某元素的事件处理程序委托给其所有直接父辈元素中的某一个元素，即冒泡阶段中，某元素之后的任何事件传递元素，而document作为所有页面元素的祖先元素，将事件委托给document很方便，但是也可能因为DOM嵌套层数太多，事件冒泡阶段的传递较多，导致事件处理效率不高，所以应该尽可能选择具体的委托元素，以减少不必要的开销。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;早委托&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果我们需要在某个页面中，处理某个链接的单击事件，并阻止其默认事件（即，单击立即跳转到相应的链接），如果我们等到文档就绪之后在为其绑定单击事件，那么可能在绑定事件处理程序之前，该链接已经被点击，然后跳转到另一个页面了。把事件处理程序绑定到document上，不再等到加载完整的DOM结构之前就运行，即将事件委托作为一个IIFE放入&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;中，一旦加载玩绑定函数立即绑定，那么后面加载html内容时，单击触发的所有事件都会冒泡到document元素，执行相应的功能，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function($){
    $(document).on( 'click mouseleave', '.a', function(event){
        alert('a click');
        event.preventDefault;
    });
})(jQuery);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3、自定义事件&lt;/h3&gt;

&lt;p&gt;由浏览器的DOM实现自然触发的事件对任何WEB应用来说都是至关重要的，但是jQuery代码不没有局限于此，jQuery中支持对事件的自定义，即我们可以手动为DOM元素添加一些&lt;strong&gt;&lt;em&gt;自定义事件&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;由于是自定义事件，因而其触发必须是手动的方式来触发，其应用方式就像函数的定义与调用一样，自定义事件就像创建一个完成某项功能的的函数，在需要完成某个功能时，通过触发方式来触发自定义事件，就像调用函数一样，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function(){
    $(document).on( 'AlertHello', function(event){
        alert('Hello World!');
    } );

    $('.p').click(function(){
        $(this).trigger('AlertHello');
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当点击&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;元素时，成功弹出&lt;code&gt;Hello World!&lt;/code&gt;，当然也可以对自定义事件传递自定义参数，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).on( 'AlertStr', function( event, str ){
    var s = str || &quot;Hello World!&quot;;
    alert(s);
}

$('.p').click(function(){
        $(this).trigger( 'AlertStr', 'jQuery');
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而此时单击&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;元素时，如你所想的，弹出的是&lt;code&gt;jQuery&lt;/code&gt;。&lt;/p&gt;

&lt;h3&gt;4、移除事件处理程序&lt;/h3&gt;

&lt;p&gt;有绑定事件处理程序，当然也有移除绑定，在jQuery中，移除事件处理程序通常是用.off()方法来实现，如移除&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;元素的单击事件，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('.span').click(function(){
        alert('span click');
});

$('.span').off('click');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再单击&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;元素时，不会弹出任何警示框了，开始为其绑定了一个单击事件，然后移除了单击事件click的事件处理程序，之后单击都不会弹出提示。&lt;/p&gt;

&lt;p&gt;当然此处通过代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('.span').off('click');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是将&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;元素的所有单击事件都移除，言外一致就是只要是click事件的处理程序就被移除，不在响应click事件，而现实中我们通常只是希望移除某个或某些特定的事件，这就要用到事件处理的命名空间了。&lt;/p&gt;

&lt;p&gt;通过命名空间可以让.off()方法更具有针对性，避免移除仍需要的事件处理程序，而事件处理的命名空间，事件绑定事件处理程序的时候，附带传入的信息，用以表示一个或者一类的事件处理程序，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function(){
    $('.p').on( 'click.alerthello', function(){
        alert('Hello!');
    });
    $('.p').on( 'click.alerthello', function(){
        alert('Hello World!');
    });
    $('.p').on( 'click.alertjquery', function(){
        alert('Hello jQuery!');
    });

    $('.p').off('click.alerthello');
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;单击&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;元素时，只弹出警示框显示&lt;code&gt;Hello jQuery!&lt;/code&gt;，而另外两个没有显示，说明成功移除了click单击事件中，&lt;code&gt;alerthello&lt;/code&gt;命名空间下所有的事件处理程序，而&lt;code&gt;alertjquery&lt;/code&gt;命名空间下的事件处理程序仍然保留。&lt;/p&gt;

&lt;h3&gt;5、DOM2级及IE 事件处理程序&lt;/h3&gt;

&lt;p&gt;DOM2级事件定义了两个方法，addEventListener()和removeEventListener()，用于处理指定和删除事件处理程序操作，这两个方法接收三个参数：事件处理程序名称、事件处理程序函数和一个布尔值（用于表示是否在捕获阶段调用事件处理程序，默认值为false，即在冒泡阶段调用事件处理程序）。&lt;/p&gt;

&lt;p&gt;IE中实现了与DOM中类似的两个方法：attachEvent()和detachEvent()，由于IE8及更早版本只支持冒泡阶段，因而这两个方法只接收两个参数：事件处理程序名称和事件处理程序函数。&lt;/p&gt;

&lt;p&gt;jQuery中的为DOM元素添加和删除事件处理程序中，最底层的操作也是通过这四个方法来实现的，实现了对IE及其它浏览器的事件处理程序的兼容。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;addEventListener( type, listener, capture )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;type 事件处理程序类型，即要监听的事件名称，例如click mouseout mouseleave等；&lt;/li&gt;
&lt;li&gt;listener 事件处理程序的具体实现函数，当规定的事件发生时，执行该函数；&lt;/li&gt;
&lt;li&gt;capture 如果为true，表示在事件捕获阶段调用事件处理程序。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;addEventListener()可能被调用多次，在同一个节点上为同一种类型的事件注册多个事件句柄。但要注意，DOM不能确定多个事件句柄被调用的顺序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;removeEventListener( type, listener, capture )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;type 要删除事件处理程序的类型&lt;/li&gt;
&lt;li&gt;listener 要删除的事件程序的函数&lt;/li&gt;
&lt;li&gt;capture 如果要删除是捕获阶段的事件处理程序，则为true；如果要删除的是冒泡阶段的事件处理程序，则为false&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;&lt;em&gt;attachEvent( type, listener )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;type 事件处理程序名称，带有一个“on”前缀，例如onclick onmouseout onmouseleave等；&lt;/li&gt;
&lt;li&gt;listener 事件处理程序的具体实现函数，当规定的事件发生时，执行该函数；&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;这个方法是一个特定与IE的事件注册方法。它和标准的addEventListener()方法（IE不支持它）具有相同的作用，只是两者传递的参数不同，而且IE中不支持&lt;strong&gt;&lt;em&gt;事件捕获&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;detachEvent( type, listener )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;type 要删除的事件监听器所针对的事件的类型，带有一个on前缀。&lt;/li&gt;
&lt;li&gt;listener 要删除事件处理程序函数&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;这个方法解除掉由attachEvent()方法所执行的事件句柄函数注册。它是removeEventListener()方法的特定与IE的替代。要为一个元素删除一个事件函数句柄，只需要使用你最初传递attachEvent()的相同参数来调用detachEvent()。&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未完待续。。。&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Jquery Source Analysis Queue</title>
   <link href="http://www.blogways.net/blog/2014/08/15/jQuery-source-analysis-queue.html"/>
   <updated>2014-08-15T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/08/15/jQuery-source-analysis-queue</id>
   <content type="html">&lt;h2&gt;一、前言&lt;/h2&gt;

&lt;p&gt;队列是一种特殊的线性表，它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。进行插入操作的端称为队尾，进行删除操作的端称为队头.最先插入在元素将是最先被删除；反之最后插入的元素将最后被删除，因此队列又称为“&lt;strong&gt;&lt;em&gt;先进先出FIFO&lt;/em&gt;&lt;/strong&gt;”（First In First Out）的线性表。&lt;/p&gt;

&lt;p&gt;jQuery提供了&lt;code&gt;jQuery.queue/dequeue&lt;/code&gt;和&lt;code&gt;jQuery.fn.queue/dequeue&lt;/code&gt;，实现对队列的入队、出队操作,不同于队列定义的是，&lt;code&gt;jQuery.queue&lt;/code&gt;和&lt;code&gt;jQuery.fn.queue&lt;/code&gt;不仅执行出队操作，返回队头元素，还会自动执行返回的队头元素。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;有一点要注意的是，在jQuery中，队列Queue只应用于动画模块！&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;二、源码分析&lt;/h2&gt;

&lt;h3&gt;1、函数原型介绍&lt;/h3&gt;

&lt;p&gt;jQuery中，队列的实际实现方式很简单，代码量也不是很大，总共就70~80行代码左右，直接通过&lt;code&gt;jQuery.extend&lt;/code&gt;和&lt;code&gt;jQuery.fn.extend&lt;/code&gt;分别将其实现扩展到jQuery的全局对象和实例对象中去，其函数原型，如下所示：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;jQuery.extend扩展全局对象：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery.extend({

    queue: function( elem, type, data ) {},

    dequeue: function( elem, type ) {},

    _queueHooks: function( elem, type ) {}
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;jQuery.fn.extend扩展实例对象：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery.fn.extend({

    queue: function( type, data ) {},

    dequeue: function( type ) {},

    clearQueue: function( type ) {},

    // Get a promise resolved when queues of a certain type
    // are emptied (fx is the type by default)
    // 当队列中指定类型的函数执行完毕后，（fx是默认的类型）
    // 返回一个解决延迟对象并完成回调函数后的promise对象，
    promise: function( type, obj ) {}
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的代码原型可以看出，全局对象对外提供了两个API：&lt;code&gt;queue/dequeue&lt;/code&gt;，这两个方法有两个作用，它们既是setter，又是getter，实例对象提供了四个API:&lt;code&gt;queue、dequeue、clearQueue、promise&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;其中实例对象的方法都是在调用全局对象的queue/dequeue方法的基础上实现的。而&lt;code&gt;jQuery.fn.extend&lt;/code&gt;中扩展了promise方法，实现了对延迟对象的支持，通过在promise中创建一个Deferred实例，修改相应的方法并返回承诺（promise）。&lt;/p&gt;

&lt;h3&gt;2、jQuery.queue、jQuery.dequeue 源码分析&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;queue( elem, type, data )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其源码，如下所示，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;queue: function( elem, type, data ) {
    var queue;

    if ( elem ) {   // elem必须存在，不然将没有含义
        // 改名，每个都要加上queue，用以标识不同的队列
        type = ( type || &quot;fx&quot; ) + &quot;queue&quot;;
        // 取出缓存数据，即缓存队列
        queue = jQuery._data( elem, type );

        // 如果data存在，才会进行后边转换数组、入队等操作，可以加速取出整个队列
        // 如果data不存在，直接跳到执行return queue || []，
        // 就相当于一个getter方法
        if ( data ) {
            // 如果队列不存在，或者队列存在且data是一个数组
            if ( !queue || jQuery.isArray(data) ) {
                // 通过创建新的数组来实现队列
                queue = jQuery._data( elem, type, jQuery.makeArray(data) );
            } else {
                // 如果队列存在，这直接将传递的数据加入队列
                // queue实际是一个数组
                queue.push( data );
            }
        }

        // 返回队列（即入队的同时，返回整个队列）
        // 简洁实用的避免空引用的技巧
        // 当queue存在时，直接返回queue，否则返回[]
        return queue || [];
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个参数elem是DOM元素，第二个参数type是字符串，第三个参数data可以是function或数组。前提提过它既是setter，有事getter，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当传递三个参数的时候（ elem，type，data ），它就是一个setter，将传递过来的数据加到队列；&lt;/li&gt;
&lt;li&gt;当传递两个参数的时候（ elem，type ），他就是一个getter，将type所指定的队列数据返回。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;从中可以看出，队列Queue中的数据是通过缓存数据Cache来实现的，而在实现时，调用的是&lt;code&gt;jQuery._data( elem, type, data )&lt;/code&gt;来创建缓存数据Cache，通过&lt;code&gt;jQuery._data( elem, type )&lt;/code&gt;来返回/读取缓存的数据，当queue存在，直接调用&lt;code&gt;queue.push( data )&lt;/code&gt;将数据data加入队列。&lt;/p&gt;

&lt;p&gt;由&lt;code&gt;type ＝ ( type || &quot;fx&quot; ) + &quot;queue&quot;;&lt;/code&gt;可见，队列Queue在jQuery中是专职处理fx动画的。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;dequeue( elem, type )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;匹配的元素上执行队列中的下一个函数，其源码，如下所示，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 出队并执行
// 调用jQuery.queue取得整个队列，在调用shift取出第一个元素
dequeue: function( elem, type ) {
    type = type || &quot;fx&quot;;

    var queue = jQuery.queue( elem, type ), // 取得队列
        startLength = queue.length,
        fn = queue.shift(),     // 取出队列中的第一个元素
        hooks = jQuery._queueHooks( elem, type ),
        next = function() {
            jQuery.dequeue( elem, type );
        };

    // 如果取出的fn是一个正在执行中标准动画fx，抛弃执行哨兵（inprogress），再取一个
    if ( fn === &quot;inprogress&quot; ) {
        fn = queue.shift();
        startLength--;
    }

    if ( fn ) {
        // 如果是标准动画，则在队列头部增加处理中标记属性，阻止fx自动处理
        if ( type === &quot;fx&quot; ) {
            // 在队列头部增加inprogress标记
            queue.unshift( &quot;inprogress&quot; );
        }

        // clear up the last queue stop function
        delete hooks.stop;
        // 执行取出的fn，并传入回调函数jQuery.dequeue
        // 可以看到fn必须是函数，否则会出错
        fn.call( elem, next, hooks );
    }

    // 此时的队列成为空队列，实质是一个空数组，
    if ( !startLength &amp;amp;&amp;amp; hooks ) {
        // 调用队列里面的hooks（通过jQuery._removeData）
        // 删除type对应的空数组，完成队列数据的清理工作
        hooks.empty.fire();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;源码中先从缓存Cache中取出队列数据，再判断队列的长度，然后通过&lt;code&gt;queue.shift();&lt;/code&gt;从队列中取出队头元素，然后做好一个预处理生成下一个的next，经判断修改最后调用相应的&lt;code&gt;.call()&lt;/code&gt;方法执行对头函数，在队列中所有Callbacks都执行完毕后，即&lt;code&gt;!startLength&lt;/code&gt;为真时，调用hooks完成清理工作中。&lt;/p&gt;

&lt;h2&gt;三、示例&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function fn1(){
    alert('test 1');
};
function fn2(){
    alert('test 2');
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;queue( elem, type, data )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// set
var vbody = $('body');

$.queue( vbody, 'test', fn1 );
$.queue( vbody, 'test', fn2 );

// get
var q = $.queue( vbody, 'test' );
console.log( q );  // 输出[function, function]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Chrome的JavaScript控制台中显示，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/queue_get.png&quot; alt=&quot;Queue get&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面是将elem当作一个参数传递给queue，其实还可以不用这样写，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('body').queue( 'test', fn1 );
$('body').queue( 'test', fn2 );

$('body').queue( 'test' );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种写法跟是那个面显示设置elem，所实现的功能是完全一样的!&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;dequeue( elem, type)&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.dequeue( vbody, 'test' );     // test 1
$.dequeue( vbody, 'test' );     // test 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而在实际的应用当中，我们不可能为队列中每个元素进行手动的通过dequeue来调用，前面介绍dequeue的时候说过，&lt;strong&gt;做好一个预处理生成下一个的next&lt;/strong&gt;，next方法可以让队列中中断的地方连续起来执行，不需要在手动的去允许，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function fn3( next ){
    alert('test 3');
    next();
};

$.queue( vbody, 'test', fn3 );
$.queue( vbody, 'test', fn2 );

$.dequeue( vbody, 'test' );     // test 3  , test 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;像上面这样，只要在传入的函数的参数当中，增加一个next方法变量，然后在当前函数功能执行完成后，调用next方法，队列动画就会继续向后面进行，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var $div = $('div.testqueue');

$div.css({postition: 'relative'})
    .fadeTo('fast', 0.5)
    .fadeTo('slow', 1.0)
    .slideUp('slow')
    .queue(function(next){
        $div.css({background: '#f00'});
        next();
    })
    .slideDown('slow');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;像上面这样传递一个回调函数，&lt;code&gt;.queue()&lt;/code&gt;方法会把该函数添加到相应元素的效果队列当中，在这个回调函数当中，改变了相应元素的背景颜色，然后调用next继续执行下面的动画，将在队列中中断的地方连接起来，如果此处不调用next方法，这动画会在此处中断，有兴趣的话可以自己去尝试一下。&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未完待续。。。&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Jquery Source Analysis Cache</title>
   <link href="http://www.blogways.net/blog/2014/08/14/jQuery-source-analysis-cache.html"/>
   <updated>2014-08-14T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/08/14/jQuery-source-analysis-cache</id>
   <content type="html">&lt;h2&gt;一、前言&lt;/h2&gt;

&lt;p&gt;Cache数据缓存系统现在广泛应用于DOM元素、动画、事件等方面，消除了将动画队列都存储到各DOM元素的自定义属性中所带来的隐患，另外如果给DOM元素添加过多的自定义的属性或数据可能会引起内存泄漏，其实质是使用了一种&lt;strong&gt;&lt;em&gt;低耦合的方式&lt;/em&gt;&lt;/strong&gt;将DOM和缓存数据联系起来。&lt;/p&gt;

&lt;p&gt;说到内存泄漏，相信大家都不会陌生，那么内存泄漏的定义是什么呢？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;内存泄漏也称作“存储渗漏”，用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元，直到程序结束（其实说白了就是该内存空间使用完毕之后未回收）即所谓内存泄漏；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内存泄漏形象的比喻是“操作系统可提供给所有进程的存储空间正在被某个进程榨干”，最终结果是程序运行时间越长，占用存储空间越来越多，最终用尽全部存储空间，整个系统崩溃。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;在&lt;code&gt;C/C++&lt;/code&gt;中，内存的分配和回收都是手动完成的，因而内存泄漏是经常发生的事情，而&lt;code&gt;JavaScript&lt;/code&gt;使用的是一种称为&lt;strong&gt;&lt;em&gt;垃圾收集&lt;/em&gt;&lt;/strong&gt;的技术来管理分配给它的内存，当&lt;code&gt;JavaScript&lt;/code&gt;代码生成一个需要使用新内存的项（如：创建一个对象或一个函数）时，系统就会为这个项留出一块内存空间。因为此对象或函数会被进行各种传递或引用，所以很多代码都会指向这块内存空间，&lt;code&gt;JavaScript&lt;/code&gt;会跟踪这些对内存空间的引用，当某块内存空间没有再被任何其他代码引用时，这个对象占用的内存就会被释放。&lt;/p&gt;

&lt;p&gt;但是由于浏览器的差异，这些&lt;code&gt;JavaScript&lt;/code&gt;的自动垃圾回收方法的实现并不一样，而且回收方法可能还存在着BUG，因而还是会导致内存泄露，&lt;code&gt;JavaScript&lt;/code&gt;中会导致内存泄露的情况：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 循环引用
 2. `JavaScript`闭包
 3. DOM插入顺序
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;循环引用，两个或两个以上的对象或方法相互之间引用，形成一个&lt;strong&gt;&lt;em&gt;闭合环状引用&lt;/em&gt;&lt;/strong&gt;，则会导致内存泄露，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var A = document.getElementById('mImage'),
     B = new Object();          or          A.relative = A;
 A.relative = B;
 B.relative = A;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;二、源码分析&lt;/h2&gt;

&lt;h3&gt;1、函数原型介绍&lt;/h3&gt;

&lt;p&gt;首先，在&lt;code&gt;jQuery&lt;/code&gt;源码中，一条不变的实现方式就是通过&lt;code&gt;jQuery.extend&lt;/code&gt;、&lt;code&gt;jQuery.fn.extend&lt;/code&gt;将Cache功能扩展给&lt;code&gt;jQuery&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在扩展Cache功能的时候，其代码量并不多，实际的功能实现都是通过调用内部的私有函数来实现的，下面看下这些私有函数及扩展功能函数的函数原型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 用来判断该元素是否能接受数据，返回true或false
jQuery.acceptData = function( elem ) {};

// 支持HTML5的data-属性
// 如果在指定元素elem没有找到key对应的数据data，就尝试读取HTML5的data属性
function dataAttr( elem, key, data ) {};

// 检测一个Cache对象是否为空
function isEmptyDataObject( obj ) {};

// jQuery内部实现Cache实际函数，存储缓存数据
function internalData( elem, name, data, pvt /* Internal Use Only */ ) {};
function internalRemoveData( elem, name, pvt ) {};   // 移除缓存数据

jQuery.extend({     // 扩展jQuery全局对象
    cache: {},  // 缓存对象，用于保存缓存数据

    // 如果你试图对下面的元素添加expando属性，
    // 它们会抛出不可捕捉的异常
    // 意思就是，以下元素没有Data：embed和applet，除了Flash之外的object
    noData: {
        &quot;applet &quot;: true,
        &quot;embed &quot;: true,
        &quot;object &quot;: &quot;clsid:D27CDB6E-AE6D-11cf-96B8-444553540000&quot;
    },

    // 用来判断HTMLElement或JS对象是否具有数据。返回true或false。
    // 即，如果调用了jQuery.data方法添加了属性，则返回true。
    hasData: function( elem ) {},

    // jQuery对外的缓存数据接口，用于存储数据
    data: function( elem, name, data ) {
        return internalData( elem, name, data );
    },
    // jQuery对外的缓存数据接口，用于删除数据
    removeData: function( elem, name ) {
        return internalRemoveData( elem, name );
    },

    // 私有函数，仅在内部使用
    _data: function( elem, name, data ) {
        return internalData( elem, name, data, true );
    },
    // 私有函数
    _removeData: function( elem, name ) {
        return internalRemoveData( elem, name, true );
    }
});

jQuery.fn.extend({  // 扩展jQuery实例对象
    // 在匹配的元素上存储任意数据，解决了循环引用和内存泄漏
    data: function( key, value ) {},

    // 在匹配的元素上移除给定key值的数据
    removeData: function( key ) {}
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2、internalData、internalRemoveData源码分析&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;$internalData( elem, name, data, pvt )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其源码，如下所示，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function internalData( elem, name, data, pvt /* Internal Use Only */ ) {
    if ( !jQuery.acceptData( elem ) ) {
         // 是否可以附加数据，不可以则直接返回
        return;
    }

    var ret, thisCache,
        internalKey = jQuery.expando,

    // 必须区分处理DOM元素和JS对象，
    // IE6-7不能垃圾回收对象跨DOM对象和JS对象进行的引用属性
    isNode = elem.nodeType,

    // 如果是DOM元素，则使用全局的jQuery.Cache
    // 如果是JS对象，则直接附加到实例对象上
    cache = isNode ? jQuery.cache : elem,

    // Only defining an ID for JS objects if its cache already exists allows
    // the code to shortcut on the same path as a DOM node with no cache
    // 如果JS对象的cache已经存在，则需要为JS对象定义一个ID
    // 如果是DOM元素，则直接通过elem[ internalKey ]返回id，
    // 如果是JS对象，且JS对象的属性internalKey存在，返回internalKey 
    id = isNode ? elem[ internalKey ] : elem[ internalKey ] &amp;amp;&amp;amp; internalKey;

    // 尝试在一个没有任何数据的对象上获取数据时，避免做更多的不必要工作
    if ( (!id || !cache[id] || (!pvt &amp;amp;&amp;amp; !cache[id].data)) 
                &amp;amp;&amp;amp; data === undefined &amp;amp;&amp;amp; typeof name === &quot;string&quot; ) {
        return;
    }

    if ( !id ) {
        // 只有DOM节点需要一个唯一的ID，因为DOM元素的数据存储在全局的cache中
        if ( isNode ) {
            id = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++;
        } else {
            id = internalKey;
        }
    }

    if ( !cache[ id ] ) {
        // 当对象使用JSON.stringify被序列化时，避免将jQuery元数据暴露在一个纯JS对象上
        cache[ id ] = isNode ? {} : { toJSON: jQuery.noop };
    }

    // 可以为jQuery.data传递一个对象或函数作为参数，而不必须是key/value的方式
    // 将参数浅拷贝到存在的缓存数据中
    if ( typeof name === &quot;object&quot; || typeof name === &quot;function&quot; ) {
        if ( pvt ) {
            cache[ id ] = jQuery.extend( cache[ id ], name );
        } else {
            cache[ id ].data = jQuery.extend( cache[ id ].data, name );
        }
    }

    thisCache = cache[ id ];

    // jQuery内部数据存在一个独立的对象（thisCache[ internalKey ]）上，
    // 是为了避免内部数据和用户定义数据冲突
    // 如果是私有数据
    if ( !pvt ) {
        if ( !thisCache.data ) {
            thisCache.data = {};    // 存放私有数据的对象不存在，则创建一个{}
        }

        thisCache = thisCache.data;     // 使用私有数据对象替换thisCache
    }

    // 如果data不是undefined，表示传入了data参数，则存储data到name属性上
    if ( data !== undefined ) {
        thisCache[ jQuery.camelCase( name ) ] = data;
    }

    // 如果一个数据属性是被限定的，
    // 则检测转换为驼峰表示法和未转换的数据属性的name
    if ( typeof name === &quot;string&quot; ) {

        // 首先尝试找到as-is属性数据
        ret = thisCache[ name ];

        // 如果ret为null或者undefined，尝试没有或者违背定义属性数据
        if ( ret == null ) {

            // 尝试找到骆驼拼写法属性（因为有可能之前name被驼峰化了）
            ret = thisCache[ jQuery.camelCase( name ) ];
        }
    } else {
        ret = thisCache;
    }

    return ret;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在源码中很多地方都出现了&lt;code&gt;expando&lt;/code&gt;和&lt;code&gt;jQuery.expando&lt;/code&gt;，那到底它们是何方神圣？首先看一下&lt;code&gt;jQuery.expando&lt;/code&gt;的源码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery.extend({
    // 为了区别不同的jQuery实例存储的数据，使用前缀“jQuery”+jQuery版本号+随机数作为Key
    expando: &quot;jQuery&quot; + ( version + Math.random() ).replace( /\D/g, &quot;&quot; ),

    // other code
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出&lt;code&gt;jQuery.expando&lt;/code&gt;实际上是一个字符串，使用&lt;code&gt;Math.random()&lt;/code&gt;生成，去掉了非数字字符，它作为HTMLElement或JavaScript对象的属性名，用以标识不同的HTML元素和JavaScript对象。&lt;/p&gt;

&lt;p&gt;前面提过，&lt;code&gt;internalData( elem, name, data, pvt )&lt;/code&gt;是&lt;code&gt;jQuery&lt;/code&gt;中实际实现存储缓存数据的方法，每次调用（插入一个缓存数据）都会调用&lt;code&gt;jQuery.expando&lt;/code&gt;来生成一个key值，用以给插入的数据做一个标识，以便以后通过key值来访问，而在此方法中使用&lt;code&gt;internalKey = jQuery.expando;&lt;/code&gt;，将key值保存在internalKey中用以内部使用。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;internalRemoveData( elem, name, pvt )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其源代码，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function internalRemoveData( elem, name, pvt ) {
    var thisCache, i,
        isNode = elem.nodeType,
        cache = isNode ? jQuery.cache : elem,
        id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

    // 缓存数据中没有指定要删除的数据，直接return
    if ( !cache[ id ] ) {   return;   }

    if ( name ) {
        // 取得实际要操作的缓存数据
        thisCache = pvt ? cache[ id ] : cache[ id ].data;
        if ( thisCache ) {

            // Support array or space separated string names for data keys
            // 支持数组或空格分割的字符串name作为数据的键值
            if ( !jQuery.isArray( name ) ) {
                // 在进行任何操作之前，尝试将整个字符串作为一个键值
                if ( name in thisCache ) {
                    name = [ name ];
                } else {

                    // split the camel cased version by spaces 
                    // unless a key with the spaces exists
                    // 将name转换为骆驼表示法
                    name = jQuery.camelCase( name );
                    // 判断尝试转换后的name是否在缓存数据中
                    if ( name in thisCache ) {
                        name = [ name ];    // 在，
                    } else {
                        name = name.split(&quot; &quot;);  // 不在，则将其用空格符分割
                    }
                }
            } else {

                // 如果“name”是一个key值的数组，
                // 当数据最初被创建时，通过 (&quot;key&quot;, &quot;val&quot;) 签名，
                // key值将会通过jQuery.map()被转换为骆驼表示法。
                // 由于没办法 告知 key是如何被添加，原始的和骆驼表示法的key值将会被移除
                // Since there is no way to tell _how_ a key was added, remove
                // both plain key and camelCase key. #12786
                // This will only penalize the array argument path. 
                name = name.concat( jQuery.map( name, jQuery.camelCase ) );
            }

            i = name.length;
            while ( i-- ) {
                delete thisCache[ name[i] ];
            }

            // 如果当前缓存中的数据被全部删除，             直接返回return
            if ( pvt ? !isEmptyDataObject(thisCache) 
                                : !jQuery.isEmptyObject(thisCache) ) {
                return;
            }
        }
    }

    if ( !pvt ) {
        delete cache[ id ].data;

        // 不销毁父缓存，除非在缓存中之剩下内部数据对象
        if ( !isEmptyDataObject( cache[ id ] ) ) {
            return;
        }
    }

    // 销毁缓存
    if ( isNode ) {
        jQuery.cleanData( [ elem ], true );

    // Use delete when supported for expandos or `cache` is not a window per isWindow
    // 当支持suport.deleteExpando或cache不是。。。时，(反正就是支持用delete来删除缓存)
    // 使用delete销毁缓存
    } else if ( support.deleteExpando || cache != cache.window ) {
        delete cache[ id ];
    // 当所有条件都不满足时，直接置null
    } else {
        cache[ id ] = null;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;internalRemoveData&lt;/code&gt;方法中，大部分源码就是在通过判断，分析和处理找到需要删除数据的name，并没有太难理解的地方那个，此处不再详细讲解。&lt;/p&gt;

&lt;h2&gt;三、示例&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;jQuery.data( elem, name, data )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;jQuery.data 这是提供给客户端程序员使用的方法，它同时是setter/getter。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;传一个参数，返回附加在指定元素的所有数据，即&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  thisCachejQuery.data(elem); // thisCache
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;传二个参数，返回指定的属性值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  jQuery.data(elem, 'name');  或  $.data(elem, 'name');
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;传三个参数，设置属性及属性值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  jQuery.data(elem, 'name', 'Jack');      或    $.data(elem, 'name', 'Jack');
  jQuery.data(elem, 'oName', {});         或    $.data(elem, 'oName', {});
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;传四个参数，第四个参数pvt仅提供给jQuery库自身使用，即&lt;code&gt;jQuery._data&lt;/code&gt;方法中传&lt;code&gt;true&lt;/code&gt;，因为jQuery的事件模块严重依赖于jQuery.data，为避免人为的不小心重写，所以在这个版本中加入的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;为JavaScript对象提供缓存，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var oMyJs = {};
$.data(oMyJs, 'info', 'Hello World');
$.data(oMyJs, 'info'); // Hello World
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为HTMLElement提供缓存，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// html
&amp;lt;div id=&quot;mdiv&quot;&amp;gt;&amp;lt;/div&amp;gt;

// js
var elem = $('mdiv');
$.data(elem, 'info', 'Hello World');
$.data(elem, 'info');     // Hello World
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你使用的时Chrome，你可以打开JavaScript控制台，并添上&lt;code&gt;console.log(oMyJs/elem);&lt;/code&gt;，运行你就能看到元素上附加的数据了，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/oMyJs.png&quot; alt=&quot;$.data( oMyJs )&quot; /&gt;
&lt;img src=&quot;/images/elem.png&quot; alt=&quot;$.data( elem )&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未完待续。。。&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Jquery Source Analysis Callback Deferred</title>
   <link href="http://www.blogways.net/blog/2014/08/13/jQuery-source-analysis-callback-deferred.html"/>
   <updated>2014-08-13T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/08/13/jQuery-source-analysis-callback-deferred</id>
   <content type="html">&lt;h2&gt;一、前言&lt;/h2&gt;

&lt;h3&gt;1、jQuery.Callbacks&lt;/h3&gt;

&lt;p&gt;首先，来考虑一个问题，我们想让某些函数按照先后顺序执行，你最先想到的是什么？队列？那让我们来看一下用队列函数来实现，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function fnLikeQueue( fnList, callback){
    var fnTask;
    while(fnList.length &amp;gt; 0){
        fnTask = fnList.shift();
        fnTask();   // 执行函数
    }
    callback();
};
fnLikeQueue( [function(){
        alert('one');
    }, function(){
        alert('two');
    }, function(){
        alert('three');
    }], function(){
        alert('I\'m a callback');
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行上面代码将会顺序弹出警示框，显示，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;one,two,three,i'm a callback
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方法要判断函数序列的长度，每次运行还要取出一个函数在执行，而且向函数序列中添加新的函数也不是很方便，直观感觉不是很Fashion，现在来试试&lt;code&gt;jQuery.Callbacks&lt;/code&gt;，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var callbacks = $.Callbacks();
callbacks.add(function() {
    alert('one');
});
callbacks.add(function() {
    alert('two');
});
callbacks.fire();   // 显示 'one', 'two'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用起来要便捷很多，代码又很清晰，所以&lt;code&gt;jQuery.Callbacks&lt;/code&gt;是一个多用途的回调函数列表对象，提供了一种强大的方法来管理回调函数队列。&lt;/p&gt;

&lt;h3&gt;2、Deferred&lt;/h3&gt;

&lt;p&gt;实际开发过程中，我们经常遇到某些耗时很长的JavaScript操作，其中既有异步的操作（比如ajax读取服务器数据），也有同步的操作（比如遍历一个大型数组），我们不可能等待这些操作完成，然后再继续后面的操作。&lt;/p&gt;

&lt;p&gt;通常的做法是，为它们指定回调函数（Callback），即规定当操作执行完毕后，应该执行的某些动作。&lt;/p&gt;

&lt;p&gt;但是，在回调函数方面，jQuery的功能非常弱。为了改变这一点，jQuery开发团队就设计了Deferred对象，简单说，Deferred对象就是jQuery的&lt;strong&gt;回调函数解决方案&lt;/strong&gt;，其含义是&quot;延迟&quot;到未来某个点再执行。&lt;/p&gt;

&lt;p&gt;通过调用&lt;code&gt;$.Deferred()&lt;/code&gt;构造函数可以创建一个新的延迟对象，每个延迟对象都会向其它代码&lt;strong&gt;承诺&lt;/strong&gt;（promise）提供数据，对于任何延迟对象，调用它的&lt;code&gt;.promise()&lt;/code&gt;方法可以取得其承诺对象，通过调用其承诺对象的相应方法，可以添加承诺兑现时调用的处理程序：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通过&lt;code&gt;.done()&lt;/code&gt;方法添加的处理程序会在延迟对象被 &lt;strong&gt;成功解决&lt;/strong&gt; 之后调用；&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;.fail()&lt;/code&gt;方法添加的处理程序会在延迟对象被 &lt;strong&gt;拒绝&lt;/strong&gt; 之后调用；&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;.always()&lt;/code&gt;方法添加的处理程序会在延迟对象完成其任务（&lt;strong&gt;无论解决还是拒绝&lt;/strong&gt;）时调用。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;首先，看下jQuery中Ajax的传统写法，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.ajax({
    url: 'index.html',
    success: function(){
        alert('Done!');
    },
    error:function(){
        alert('Fail!');
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中success为请求成功后调用的操作，而error是请求失败后执行的操作，而在有了Deferred对象之后，就不需要像上面一样，再在ajax的请求选项中编写很多很长的操作，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.ajax('index.html')
 .done(function(){  alert('Done!');  })
 .fail(function(){  alert('Fail!');  });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，done()相当于success方法，fail()相当于error方法。采用连缀写法以后，大大提高了代码的可读性。&lt;/p&gt;

&lt;h2&gt;二、jQuery.Callbacks源码分析&lt;/h2&gt;

&lt;h3&gt;1、函数原型介绍&lt;/h3&gt;

&lt;p&gt;在下面的代码中，可以看懂Callbacks的原型中需要传递一个参数options，一个由空格分开选项的可选项列表，常用的参数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;once&lt;/strong&gt;:   确保这个回调列表只执行（ .fire() ）一次(像一个递延 Deferred).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;memory&lt;/strong&gt;: 保持以前的值，将添加到这个列表的后面的最新的值立即执行调用任何回调 (像一个递延 Deferred).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;unique&lt;/strong&gt;: 确保一次只能添加一个回调(所以在列表中没有重复的回调).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;stopOnFalse&lt;/strong&gt;: 当一个回调函数返回false 时中断调用&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;code&gt;jQuery.Callbacks&lt;/code&gt;是在jQuery内部使用，如为&lt;code&gt;.ajax&lt;/code&gt;，&lt;code&gt;$.Deferred&lt;/code&gt;等组件提供&lt;strong&gt;基础功能&lt;/strong&gt;的函数，在jQuery引入了Deferred对象（异步列队）之后，jQuery内部基本所有有异步的代码都被promise所转化成同步代码执行。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;jQuery.Callbacks&lt;/code&gt;的函数原型，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery.Callbacks = function( options ) {

    // 在需要的情况下，将字符串格式选项转换成对象格式，
    // 在转换时会优先检测缓存
    options = typeof options === &quot;string&quot; ?
        ( optionsCache[ options ] || createOptions( options ) ) :
        jQuery.extend( {}, options );

    var 
        firing,     // 标记当前Callbacks列表是否正在运行
        // Last fire value (for non-forgettable lists)
        // 
        memory,
        fired,  // 标记是否Callbacks列表是否已经执行
        firingLength,  // Callbacks运行时，循环结束位置
        firingIndex,  // 当前正在运行的Callbacks的索引（下标）

        // Callbacks列表运行时，开始循环的第一个回调函数
        // 供add和fireWith方法使用
        firingStart,                            
        list = [],  // 实际的回调函数列表

        // 只有在选项没有设置为once时，stack才存在 
        // stack用来存储参数信息（此时函数列表已经处于firing状态，
        // 必须将其他地方调用fire时的参数存储，之后再至此执行fire
        stack = !options.once &amp;amp;&amp;amp; [],

        // 用给定的参数调用所有的回调函数
        fire = function( data ) {},
        // 实际的 Callbacks 对象
        self = {
            // 回调列表中添加一个回调函数或回调函数的集合
            add: function() {},

            // 从回调列表中的删除一个回调函数或回调函数集合
            remove: function() {},

            // 返回是否列表中已经拥有一个相同的回调函数
            has: function( fn ) {},

            // 从列表中删除所有的回调函数
            empty: function() {},

            // 禁用列表中的回调函数
            disable: function() {},

            // 确定列表是否已被禁用
            disabled: function() {},

            // 锁定当前状态的回调函数列表
            lock: function() {},

            // 确定回调函数列表是否已被锁定
            locked: function() {},

            // 访问给定的上下文和参数列表中的所有回调函数
            fireWith: function( context, args ) {},

            // 用给定的参数调用所有的回调函数
            fire: function() {},                
            // 判断回调函数是否被已经被调用了至少一次
            fired: function() {}
        };
    return self;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2、add、fire源码分析&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;$.Callbacks().add( callbacks )&lt;/code&gt;的源码如下所示，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;add: function() {
    if ( list ) {
        var start = list.length;    // 保存当前list长度
        (function add( args ) {
            jQuery.each( args, function( _, arg ) {
                var type = jQuery.type( arg );
                // 如果传递过来的参数是函数，
                // 没有设置‘unique’，则将传递过来的回调函数直接push到列表中
                // 如果设置了‘unique’，则判断现在列表中是否已存在，
                // 若不存在，则直接push到Callbacks列表
                if ( type === &quot;function&quot; ) {
                    if ( !options.unique || !self.has( arg ) ) {
                        list.push( arg );
                    }
                } else if ( arg &amp;amp;&amp;amp; arg.length &amp;amp;&amp;amp; type !== &quot;string&quot; ) {
                    // 如果传递过来的时一个数组，则递归调用add实现回调函数的添加
                    add( arg );
                }
            });
        })( arguments );

        // 当回调函数正在执行时，则修改firingLength，确保当前添加的回调函数能够被执行
        if ( firing ) {
            firingLength = list.length;

        // 如果不是firing状态，并且设置了memory
        //（肯定是在fired状态时才会执行这一步，因为memory是在fire一次后才会被赋值） 
        // 此时memory已经是上次fire是传递的参数，
        // 那么将会直接执行刚添加的函数集，而无需fire 
        } else if ( memory ) {
            firingStart = start;
            fire( memory );
        }
    }
    return this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当开发人员通过&lt;code&gt;.add( callbacks )&lt;/code&gt;向回调函数列表添加回调函数时，在函数内直接将参数传递给一个&lt;code&gt;立即调用函数表达式(IIFE)&lt;/code&gt;，根据传递参数的类型，采取不同的方式将其添加到回调列表中去。&lt;/p&gt;

&lt;p&gt;这里需要注意的一处是，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ( !options.unique || !self.has( arg ) ) {
    list.push( arg );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它隐含的表达了两个判断，&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;是否设置了“unique”；&lt;/li&gt;
&lt;li&gt;在设置了“unique”的前提下，判断是否在回调列表中存在，&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;使用一般的函数语句，通常是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if( !options.unique ){
    // push
}else if(!self.has( arg )){
    push
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面也有提到，像源码中的这种书写方式，看起来非常的简洁，唯一的不好就是阅读起来不是很方便。
&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;fire&lt;/code&gt;&lt;/strong&gt;方法，外部调用此方法是，jQuery内部的调用方向为，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;self.fire --&amp;gt; self.fireWith --&amp;gt; file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在前面的Callbacks函数原型中介绍过，self是真正的Callbacks对象，也就是我们使用是调用的Callbacks对象就是self，那么这里的self.fire和self.fireWith只是Callbacks对外提供的方法，而实际上实现fire功能的是Callbacks内部私有的&lt;code&gt;fire&lt;/code&gt;方法，也就是此处要讲的源码，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 运行回调函数列表
fire = function( data ) {
    // 如果参数memory为true，则记录data
    memory = options.memory &amp;amp;&amp;amp; data;
    fired = true;   // 标记运行回调函数
    firingIndex = firingStart || 0;
    firingStart = 0;
    firingLength = list.length;
    firing = true;  // 标记正在运行回调函数

    for ( ; list &amp;amp;&amp;amp; firingIndex &amp;lt; firingLength; firingIndex++ ) {
        if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false 
                        &amp;amp;&amp;amp; options.stopOnFalse ) {
            memory = false;     // 阻止未来可能由于add所产生的回调
            break;  // 由于参数options设置了stopOnFalse，
            // 所有当有回调函数运行结果为false时，退出循环
        }
    }
    // 标记结束运行回调
    firing = false;
    if ( list ) {   // 如果Callbacks列表存在
        if ( stack ) {  // stack存在

            // stack不为空，即stack中存有参数信息，
            // 当firing在运行时，通过add添加的Callbacks都将保存到stack中
            if ( stack.length ) {
                //从stack中取出，递归fire执行stack中的Callbacks
                fire( stack.shift() );
            }
        } else if ( memory ) {
            list = [];
        } else {
            // 阻止回调列表中的回调
            self.disable();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中需要注意的是，在未参数memory赋值时，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;memory = options.memory &amp;amp;&amp;amp; data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行此语句后，当&lt;code&gt;options.memory&lt;/code&gt;的值为&lt;code&gt;true&lt;/code&gt;时，memory的值是data中的值，这跟&lt;code&gt;C/C++&lt;/code&gt;、&lt;code&gt;JAVA
&lt;/code&gt;等语言不同，在&lt;code&gt;C/C++&lt;/code&gt;、&lt;code&gt;JAVA&lt;/code&gt;中，执行上面语句过后的值是一个&lt;code&gt;boolean&lt;/code&gt;类型的值（true 或 false）。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;JavaScript&lt;/code&gt;中，它能完成非常‘完美’的功能，&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当options.memory存在时，该语句就相当于一条赋值语句&lt;code&gt;memory = data;&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;当options.memory不存在时，memory值为&lt;code&gt;false&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;像这样写之后，就再也不用为写一些复杂的判断语句了，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if( options.memory ){
    memory = data;
} else {                    或者  memory = options.memory ? data : false;
    memory = false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而且看上去非常的“&lt;strong&gt;优雅&lt;/strong&gt;”不是么？ 当然还有&lt;code&gt;||&lt;/code&gt;操作也一样，以前我们这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if( options.memory ){
    memory = true;
} else {                    或者 memory = options.memory ? true : data;
    memory = data;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们可以这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;memory = options.memory || data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以复制下面代码到&lt;a href=&quot;%22http://jsfiddle.net/%22&quot; title=&quot;http://jsfiddle.net/&quot;&gt;JSFiddle.net&lt;/a&gt;去测试一下！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var options = true,
data = 'I\'m a String',
ret;
ret = options &amp;amp;&amp;amp; data; //!options &amp;amp;&amp;amp; data;  //options || data; //!options || data;
alert(ret);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，这都只能在&lt;code&gt;JavaScript&lt;/code&gt;中这么写，你要是在&lt;code&gt;C/C++&lt;/code&gt;、&lt;code&gt;JAVA&lt;/code&gt;中也这么写，&lt;strong&gt;恭喜你，慢慢调BUG吧~~&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;fire&lt;/code&gt;源码中，真正最终执行回调函数的代码是，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;list[ firingIndex ].apply( data[ 0 ], data[ 1 ] )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于&lt;code&gt;apply&lt;/code&gt;的使用，可以参考&lt;a href=&quot;%22/blog/2014/07/22/somethings-of-array-and-function.html%22&quot; title=&quot;http://www.blogways.net/blog/2014/07/22/somethings-of-array-and-function.html&quot;&gt;JavaScript中，Array和Function的那些事儿&lt;/a&gt;！&lt;/p&gt;

&lt;h3&gt;3、示例&lt;/h3&gt;

&lt;p&gt;下面是两个函数fn1和fn2：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function fn1( value ) {
    alert( value );
}

function fn2( value ) {
    fn1(&quot;fn2 says: &quot; + value);
    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;$.Callbacks( 'once' )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;确保这个回调列表只执行（ .fire() ）一次。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var callbacks = $.Callbacks('once');
callbacks.add( fn1 );
callbacks.fire( 'hello' );

callbacks.add( fn2 );
callbacks.fire( 'world' );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只会显示“hello”，而不会显示“world”，因为在创建Callbacks实例对象的时候，传递了参数“once”，仅运行一次，因而后面的&lt;code&gt;callbacks.fire( 'world' );&lt;/code&gt;是不会执行的。&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;$.Callbacks( 'memory' )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;保持以前的值，将添加到这个列表的后面的最新的值立即执行调用任何回调函数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var callbacks = $.Callbacks('memory');
callbacks.add(function() {
    alert('f1');
});

callbacks.fire(); //输出 'f1',这时函数列表已经执行完毕!

callbacks.add(function() {
    alert('f2');
}); //memory作用在这里，没有fire，一样有结果: f2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;$.Callbacks( 'unique' )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;确保一次只能添加一个回调函数(所以在列表中没有重复的回调函数)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var callbacks = $.Callbacks('unique');
callbacks.add( fn1 );   // 添加成功
callbacks.add( fn1 );   // 添加失败
// 显示结果hello world
callbacks.fire( 'hello world' );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;$.Callbacks( 'stopOnFlase' )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当一个回调函数返回false 时，中断调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var callbacks = $.Callbacks('stopOnFalse');
callbacks.add(f1);
callbacks.add(function(){
    return false;
});
callbacks.add(f2);
// 只显示 hello world!
callbacks.fire( 'hello world!' );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h2&gt;三、Deferred源码分析&lt;/h2&gt;

&lt;h3&gt;1、函数原型介绍&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;通过jQuery.extend&lt;/code&gt;将Deferred扩展到jQuery&lt;strong&gt;全局对象&lt;/strong&gt;中去，扩展原理前面已经讲过，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery.extend({
    Deferred: function( fnc ){},
    // Deferred 帮助
    when: function( subordinate /* , ..., subordinateN */ ) {}
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先来看下Deferred的代码结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Deferred: function( func ) {
    var tuples = [
        // 动作，添加监听器，处理程序列表（回调函数列表），最终状态
        // 创建了三个$.Callbacks对象，分别表示成功、失败、处理中三种状态
        [ &quot;resolve&quot;, &quot;done&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;resolved&quot; ],
        [ &quot;reject&quot;, &quot;fail&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;rejected&quot; ],
        [ &quot;notify&quot;, &quot;progress&quot;, jQuery.Callbacks(&quot;memory&quot;) ]
    ],
    state = &quot;pending&quot;,
    promise = {
        state: function() {},
        always: function() {},
        then: function( /* fnDone, fnFail, fnProgress */ ) {},

        // 为当前deferred，返回一个promise对象
        // 如果传递参数obj对象给此方法，则promise将被扩展到此obj对象
        promise: function( obj ) {}
    },
    deferred = {};

    // 增加一组特定的方法
    jQuery.each( tuples, function( i, tuple ) {
        deferred[ tuple[0] + &quot;With&quot; ] = list.fireWith;
    }

    return deferred;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Deferred实例的创建，跟Callbacks的雷士，调用一个函数，然后返回的是内部构建的Deferred对象，创建了一个promise对象，具有state、always、then、primise方法，扩展primise对象生成最终的Deferred对象，返回该对象。&lt;/p&gt;

&lt;h3&gt;2、源码分析&lt;/h3&gt;

&lt;p&gt;Deferred部分源码，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery.each( tuples, function( i, tuple ) {
    var list = tuple[ 2 ],
        stateString = tuple[ 3 ];

    // 通过下面的语句，实现对应的将$.Callbacks实例对象，
    // 绑定到promise对象上
    promise[ tuple[1] ] = list.add;

    // 处理状态
    if ( stateString ) {
        list.add(function() {
            // state = [ resolved | rejected ]
            state = stateString;

        // 默认会预先向doneList,failList中的list添加三个回调函数
        }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
    }

    // deferred[ resolve | reject | notify ]
    deferred[ tuple[0] ] = function() {
        deferred[ tuple[0] + &quot;With&quot; ]( this === deferred ? promise : this, arguments );
        return this;
    };
    deferred[ tuple[0] + &quot;With&quot; ] = list.fireWith;
});

// 将promise对象合并到deferred对象中
// 使用的是promise.promise( obj )，通过调用jQuery.extend扩展
// promise( obj ){
//     return obj != null ? jQuery.extend( obj, promise ) : promise;
// }
promise.promise( deferred );

return deferred;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;源码中通过&lt;code&gt;promise[ tuple[1] ] = list.add;&lt;/code&gt;将回调函数绑定到相应的promise对象上，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;promise.done = $.Callbacks(&quot;once memory&quot;).add
promise.fail = $.Callbacks(&quot;once memory&quot;).add
promise.progress = $.Callbacks(&quot;memory&quot;).add
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;i ^ 1&lt;/code&gt;按位异或运算，实际上第二个传参数是1、0索引对调了，所以取值是&lt;code&gt;failList.disable&lt;/code&gt;与&lt;code&gt;doneList.disable&lt;/code&gt;。&lt;/p&gt;

&lt;h3&gt;3、示例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var d = $.Deferred();

setTimeout(function(){
        d.resolve( 'hello world' );
},0);

d.then( function( value ){
  console.log( value );
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当延迟对象被 resolved 时，任何通过&lt;code&gt;deferred.then&lt;/code&gt;或&lt;code&gt;deferred.done&lt;/code&gt;添加的处理函数，都会被调用。回调函数的执行顺序和它们被添加的顺序是一样的。传递给&lt;code&gt;deferred.resolve()&lt;/code&gt;的args参数，会传给每个回调函数。当延迟对象进入&lt;code&gt;resolved&lt;/code&gt;状态后，再添加的任何处理函数，当它们被添加时，就会被立刻执行，并带上传入给&lt;code&gt;.resolve()&lt;/code&gt;的参数。&lt;/p&gt;

&lt;p&gt;调用d.resolve(22) 就等于是调用，匿名函数并传入参数值&quot;hello world&quot;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function(val){
    console.log(val);   // 显示hello world
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多关于Deferred对象的例子及讲解，请参考&lt;a href=&quot;%22http://www.ruanyifeng.com/blog/2011/08/a_detailed_explanation_of_jquery_deferred_object.html%22&quot; title=&quot;http://www.ruanyifeng.com/blog/2011/08/a_detailed_explanation_of_jquery_deferred_object.html&quot;&gt;jQuery的deferred对象详解&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未完待续。。。&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Jquery Source Analysis Dom Traversal</title>
   <link href="http://www.blogways.net/blog/2014/08/12/jQuery-source-analysis-dom-traversal.html"/>
   <updated>2014-08-12T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/08/12/jQuery-source-analysis-dom-traversal</id>
   <content type="html">&lt;h2&gt;一、前言&lt;/h2&gt;

&lt;p&gt;DOM遍历有两个核心的函数，其它的遍历方法都通过调用这两个方法来间接实现相应的功能，这两个核心函数的函数原型，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dir: function( elem, dir, until ) {},
sibling: function( n, elem ) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;dir( elem, dir, until )&lt;/code&gt;，从一个元素出发，迭代检索某个方向上的所有元素并记录，直到与遇到 document 对象或遇到 until 匹配的元素；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sibling( n, elem )&lt;/code&gt;，返回 n 元素的所有后续兄弟元素，包含 n，不包含 elem, 返回 n 的兄弟节点(把 n, elem 设为相同元素时，则不返回本身).&lt;/p&gt;

&lt;p&gt;然后通过&lt;code&gt;jQuery.extend()&lt;/code&gt;方法将两个核心函数扩展到&lt;code&gt;jQuery&lt;/code&gt;全局对象中去，以便后面需要的时候直接通过&lt;code&gt;jQuery.dir/sibling&lt;/code&gt;调用。&lt;/p&gt;

&lt;h3&gt;1、dir( elem, dir, until )和sibling( n, elem )的实现&lt;/h3&gt;

&lt;p&gt;在&lt;code&gt;jquery-1.11.1.js&lt;/code&gt;中，其源码如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery.extend({
    // elem     起始元素
    // dir      迭代方向，可选值：parentNode nextSibling previousSibling
    // until    选择器表达式，如果遇到until匹配的元素，迭代终止
    dir: function( elem, dir, until ) {
        var matched = [],   // 保存匹配元素
            // 根据dir从elem取出一个元素作为匹配的开始节点，
            // cur表示匹配开始节点，为当前节点在dir迭代方向的下一个节点，
            // 因此匹配结果不包含本节点
            cur = elem[ dir ];

        // 通过while循环 、 cur = cur[dir]（根据迭代方向，向后移动一个节点），
        // 实现向迭代方向的遍历，
        // 当遍历完，或遇到document（cur.nodeType === 9），
        // until匹配的元素（ jQuery( cur ).is( until ) ）时，结束遍历，返回结果
        while ( cur &amp;amp;&amp;amp; cur.nodeType !== 9 &amp;amp;&amp;amp; (until === undefined 
                        || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
            if ( cur.nodeType === 1 ) {
                // 将匹配的Element元素压入matched结果集中
                matched.push( cur );
            }
            cur = cur[dir];     // 像dir方向，往后一个节点
        }
        return matched;
    },

    // n      起始元素（包含在返回结果中）
    // elem   剔除元素（不包含在结果集中）
    sibling: function( n, elem ) {
        var r = [];

        // 将 n 是否存在作为判断循环是否继续的依据，
        // 先判断 n 的存在与否，再移动当前节点，
        // 因此结果集中包含 n 
        for ( ; n; n = n.nextSibling ) {
            // 当元素类型为Element 且 节点不为 elem 时，
            // 将当前元素压入结果集，
            if ( n.nodeType === 1 &amp;amp;&amp;amp; n !== elem ) {
                r.push( n );
            }
        }
        return r;
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的代码可以发现，虽然两个核心函数的代码量很少，但是实际上用它们能实现的功能是非常强大的。就拿&lt;code&gt;dir&lt;/code&gt;函数来说，它支持3个迭代方向，这意味着它能实现至少3个函数的功能，再加上&lt;code&gt;until&lt;/code&gt;是选择器表达式，所有它能遍历筛选的元素是非常多的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dir( elem, dir, until )&lt;/code&gt;函数中判断遇到&lt;code&gt;until&lt;/code&gt;匹配元素结束迭代的判断语句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until ) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其隐含的表达出了执行最后一个判断语句（即遇到&lt;code&gt;until&lt;/code&gt;匹配元素结束迭代）的执行条件是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;until !== undefined &amp;amp;&amp;amp; cur.nodeType === 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即&lt;code&gt;until&lt;/code&gt;必须存在，&lt;code&gt;cur&lt;/code&gt;节点必须是&lt;code&gt;Element&lt;/code&gt;元素，这种写法虽然阅读和维护都不是很方便，但是看上去比较简洁，同时节约了很多的代码，在&lt;code&gt;jQuery&lt;/code&gt;中很多地方都使用了这种写法，有兴趣可以自己去看看。&lt;/p&gt;

&lt;h3&gt;2、has、closest、index、add、addBack扩展&lt;/h3&gt;

&lt;p&gt;在向&lt;code&gt;jQuery&lt;/code&gt;扩展两个核心函数的同时，也通过&lt;code&gt;jQuery.fn.extend&lt;/code&gt;向&lt;strong&gt;实例对象&lt;/strong&gt;扩展了遍历方法，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery.fn.extend({
    // 判断当前元素集合中，是否包含target选择符指定的元素
    // 当前元素集合指调用has的实例对象当中的元素
    has: function( target ) {},

    // 与选择符selectors匹配的第一个元素，遍历路径从选中元素开始，
    // 沿DOM树向上在其中祖先节点中查找
    closest: function( selectors, context ) {},

    // 在当前元素集合中，返回给定elem元素所在的索引位置
    index: function( elem ) {},

    // 为选中的元素（当前匹配元素集合），加上与给定选择符selector匹配的元素
    add: function( selector, context ) {},

    // 为选中的元素，加上内部jQuery栈中与给定选择符selector匹配的元素
    addBack: function( selector ) {}
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;二、遍历方法&lt;/h2&gt;

&lt;h3&gt;1、遍历方法的函数原型&lt;/h3&gt;

&lt;p&gt;首先调用两个核心函数，实现相应的遍历方法，然后将这些方法一起包装到一个对象&lt;code&gt;{}&lt;/code&gt;当中，最后通过&lt;code&gt;jQuery.each&lt;/code&gt;遍历这个方法对象，并在其回调函数中通过&lt;code&gt;jQuery.fn[ name ] = function9){}&lt;/code&gt;添加到&lt;strong&gt;实例对象&lt;/strong&gt;中，其函数原型如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery.each({
    parent: function( elem ) {  // 父元素
        var parent = elem.parentNode;

        // 有父元素，且父元素不为DocumentFragment时，返回父元素
        // 否则返回null
        return parent &amp;amp;&amp;amp; parent.nodeType !== 11 ? parent : null;
    },
    parents: function( elem ) {     // 祖先元素
        // 检索所有祖先元素，直到document
        return jQuery.dir( elem, &quot;parentNode&quot; );
    },

    // 每个选中元素的所有祖先元素，直到但不包含util的祖先元素，
    parentsUntil: function( elem, i, until ) {  
        // 检索所有祖先元素，直到遇到与until匹配的元素
        return jQuery.dir( elem, &quot;parentNode&quot;, until );
    },
    next: function( elem ) {    // 每个选中元素紧邻的下一个同辈元素
        return sibling( elem, &quot;nextSibling&quot; );
    },
    prev: function( elem ) {    // 每个选中元素紧邻的上一个同辈元素
        return sibling( elem, &quot;previousSibling&quot; );
    },
    nextAll: function( elem ) {     // 每个选中元素之后的所有同辈元素
        return jQuery.dir( elem, &quot;nextSibling&quot; );
    },
    prevAll: function( elem ) {     // 每个选中元素之前的所有同辈元素
        return jQuery.dir( elem, &quot;previousSibling&quot; );
    },

    // 匹配每个选中元素之后的所有同辈元素，
    // 直到遇到与until匹配的元素，不包含until
    nextUntil: function( elem, i, until ) {  
        return jQuery.dir( elem, &quot;nextSibling&quot;, until );
    },
    prevUntil: function( elem, i, until ) {
        return jQuery.dir( elem, &quot;previousSibling&quot;, until );
    },

    // 给定节点的所有同辈元素
    siblings: function( elem ) {
        // elem父元素的第一个子节点的所有兄弟元素，排除当前节点
        return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
    },
    // 子节点
    children: function( elem ) {
        // elem的第一个子节点的所有兄弟元素，即为elem的所有子节点
        return jQuery.sibling( elem.firstChild );
    },
    // 所有的子节点，包含Element、Text、Comment
    contents: function( elem ) {
        return jQuery.nodeName( elem, &quot;iframe&quot; ) ?
            elem.contentDocument || elem.contentWindow.document :
            jQuery.merge( [], elem.childNodes );
    }
}, function( name, fn ) {
    // 将遍历对象中的方法扩展到jQuery实例对象中去
    jQuery.fn[ name ] = function( until, selector ) {

        // 将当前匹配集合中的元素，用fn处理，
        // 然后用until过滤处理结果，最后返回匹配结果
        var ret = jQuery.map( this, fn, until );

        // 不过函数名不以Until结尾
        if ( name.slice( -5 ) !== &quot;Until&quot; ) {
            // 不需要参数until，只有一个参数selector，util只到这里为止
            selector = until;
        }
        if ( selector &amp;amp;&amp;amp; typeof selector === &quot;string&quot; ) {
            // 对ret数组用selector进行过滤，只留下匹配的元素
            // jQuery.filter会调用jQuery.find.matches &amp;gt; Sizzle.matches 
            // &amp;gt; Sizzle，Sizzle查找、过滤的结果已经经过排序、去重
            ret = jQuery.filter( selector, ret );
        }

        if ( this.length &amp;gt; 1 ) {
            // 去除重复
            if ( !guaranteedUnique[ name ] ) {
                ret = jQuery.unique( ret );
            }

            // parent或prev的遍历matched应该反转，使matched顺序更符合逻辑
            if ( rparentsprev.test( name ) ) {
                // 倒序
                ret = ret.reverse();
            }
        }
        // 根据操作结果，构造新的jQuery对象并返回用以后续操作
        return this.pushStack( ret );
    };
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;应用：&lt;/h3&gt;

&lt;p&gt;HTML：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// html
&amp;lt;h2&amp;gt;Shakespeare's Plays&amp;lt;/h2&amp;gt;
&amp;lt;table&amp;gt;
    &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;As You Like It&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;Comedy&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;All's Well that Ends Well&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;Comedy&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;1601&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;Hamlet&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;Tragedy&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;1604&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;Macbeth&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;Tragedy&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;1606&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;Romeo and Juliet&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;Tragedy&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;1595&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;Henry IV, Part I&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;History&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;1596&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;Henry V&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;History&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;1599&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CSS：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.highlight {
    font-size: large;
    font-family: monospace;
    font-weight: bold;
    font-style: italic;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;1、next()&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;next()&lt;/code&gt;，每个选中元素紧邻的下一个同辈元素，给表格中包含Henry的邻近单元格加一个高亮，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('td:contains(&quot;Henry&quot;)').next().addClass('highlight');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;td:contains(Henry)&lt;/code&gt;筛选出包含Henry内容的单元格（两处），则此时的选中元素是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;td&amp;gt;Henry IV, Part I&amp;lt;/td&amp;gt; 和 &amp;lt;td&amp;gt;Henry V&amp;lt;/td&amp;gt;，
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;next()&lt;/code&gt;为选中元素的下一个同辈元素，所以在&lt;code&gt;next()&lt;/code&gt;过后的选中元素是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;td&amp;gt;History&amp;lt;/td&amp;gt; 和 &amp;lt;td&amp;gt;History&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将代码复制到&lt;a href=&quot;http://jsfiddle.net&quot;&gt;JSFiddle&lt;/a&gt;测试显示结果，表格里面的两个History显示为hightlight类的样式了。&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h3&gt;2、nextAll()&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;nextALl()&lt;/code&gt;，选中元素之后的所有同辈元素，给表格包含Henry的之后所有单元格加高亮，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('td:contains(&quot;Henry&quot;)').nextAll().addClass('highlight');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其它与前面是一样的，不一样的时，在执行了&lt;code&gt;nextAll()&lt;/code&gt;之后，选中的元素是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;td&amp;gt;Tragedy&amp;lt;/td&amp;gt;、&amp;lt;td&amp;gt;1595&amp;lt;/td&amp;gt;、&amp;lt;td&amp;gt;History&amp;lt;/td&amp;gt; 和 &amp;lt;td&amp;gt;1599&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试运行过后，可以看到两个包含Henry行的当前但与昂之后的所有单元格均显示为hightlight类的样式了。&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h3&gt;3、addBack()、parent()、children()&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;addBack()&lt;/code&gt;，选中的元素，加上内部&lt;code&gt;jQuery&lt;/code&gt;栈中之前选中的那一组元素，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('td:contains(&quot;Henry&quot;)').nextAll().addBack().addClass('highlight');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在执行&lt;code&gt;addBack()&lt;/code&gt;之后，相应行中所有单元格都显示为hightlight类的样式了。事实上，要选择同一组元素，可以采用的方法很多，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('td:contains(&quot;Henry&quot;)').parent().children().addClass('highlight');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;h3&gt;4、siblings()&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;siblings()&lt;/code&gt;，当前选中节点的所有同辈元素，剔除当前选中元素，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$('td:contains(&quot;Tragedy&quot;)').siblings().addClass('highlight');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在执行&lt;code&gt;siblings()&lt;/code&gt;之前的选中元素为表格中包含“Tragedy”的三个单元格&lt;code&gt;&amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;&lt;/code&gt;元素，而执行了&lt;code&gt;siblings()&lt;/code&gt;之后，选中的元素为前面选中元素的所有同辈元素，即：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;td&amp;gt;Hamlet&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;1604&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;Macbeth&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;1606&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;Romeo and Juliet&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;1595&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行测试过后，这几项就会显示为highlight类的样式了。&lt;/p&gt;

&lt;p&gt;测试网站推荐&lt;a href=&quot;http://jsfiddle.net&quot;&gt;JSFiddle&lt;/a&gt;!!&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未完待续。。。&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Jquery Source Analysis Two</title>
   <link href="http://www.blogways.net/blog/2014/08/10/jQuery-source-analysis-two.html"/>
   <updated>2014-08-10T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/08/10/jQuery-source-analysis-two</id>
   <content type="html">&lt;h2&gt;一、前言&lt;/h2&gt;

&lt;p&gt;前面一次讲了在&lt;code&gt;jQuery&lt;/code&gt;源码中，是通过&lt;code&gt;jQuery.extend&lt;/code&gt;和&lt;code&gt;jQuery.fn.extend&lt;/code&gt;将后续的大部分功能进行扩展的。&lt;code&gt;jQuery.extend&lt;/code&gt;扩展&lt;code&gt;jQuery&lt;/code&gt;的&lt;strong&gt;全局对象&lt;/strong&gt;，&lt;code&gt;jQuery.fn.extend&lt;/code&gt;扩展&lt;code&gt;jQuery&lt;/code&gt;的&lt;strong&gt;实例对象&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;要了解&lt;code&gt;jQuery&lt;/code&gt;工具函数的扩展，首先要了解&lt;code&gt;jQuery.extend&lt;/code&gt;和&lt;code&gt;jQuery.fn.extend&lt;/code&gt;的实现，便于了解其工作原理，这样在后面的学习中才不会有疑惑的地方。&lt;/p&gt;

&lt;h3&gt;1、jQuery.extend和jQuery.fn.extend的实现&lt;/h3&gt;

&lt;p&gt;在&lt;code&gt;jquery-1.11.1.js&lt;/code&gt;中，其源码如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// .extend( [ boolean, ] target, src1, src2, ... )
// .fn.extend( target)
// 上面为两个函数的原型，其中extend包含一个可选的boolean型参数，其含义为是否进行深度扩展
// 此处的target为 接受扩展 的对象
jQuery.extend = jQuery.fn.extend = function() {
    var src, copyIsArray, copy, name, options, clone,

    // 若无特殊情况，参数中的第一个为target，若没有传递参数，默认为{}
    target = arguments[0] || {},            i = 1,
    length = arguments.length,

    // 是否进行深度复制的flag，即为参数中[ boolean ]所传递过来的值，默认为false
    deep = false;   

    // 处理深度复制的情况，若设置了[ boolean ]，则其位置必为arguments中第一个(arguments[0])
    if ( typeof target === &quot;boolean&quot; ) {
        deep = target;

        // 跳过 [ boolean ] 参数，取得target扩展对象
        target = arguments[ i ] || {};
        i++;
    }

    // 处理target是一个string或其他什么（可能发生在深度复制中）
    if ( typeof target !== &quot;object&quot; &amp;amp;&amp;amp; !jQuery.isFunction(target) ) {
        target = {};
    }

    // 如果只有一个参数被传递过来，则扩展jQuery自己，即将target值设为this
    if ( i === length ) {
        target = this;
        i--;
    }

    for ( ; i &amp;lt; length; i++ ) {
        // 只处理不为空或undefined值
        if ( (options = arguments[ i ]) != null ) {
            // 扩展基础对象
            for ( name in options ) {
                src = target[ name ];
                copy = options[ name ];

                // 防止死循环
                if ( target === copy ) {
                    continue;   // 当传递过来的参数中的所有属性及方法，
                }

                // 如果进行深度扩展，且我们正在合并的是一个纯对象或者数组，就递归调用
                if ( deep &amp;amp;&amp;amp; copy &amp;amp;&amp;amp; ( jQuery.isPlainObject(copy) 
                        || (copyIsArray = jQuery.isArray(copy)) ) ) {
                    if ( copyIsArray ) {
                        copyIsArray = false;
                        clone = src &amp;amp;&amp;amp; jQuery.isArray(src) ? src : [];
                    } else {
                        clone = src &amp;amp;&amp;amp; jQuery.isPlainObject(src) ? src : {};
                    }
                    // 别直接修改原始对象，而是使用他们的一个副本
                    target[ name ] = jQuery.extend( deep, clone, copy );
                // 排除参数中的undefined值
                } else if ( copy !== undefined ) {
                    target[ name ] = copy;
                }
            }
        }
    }
    // 返回修改过后的对象
    return target;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;源码中通过&lt;code&gt;target[ name ] = jQuery.extend( deep, clone, copy );&lt;/code&gt;和&lt;code&gt;target[ name ] = copy;&lt;/code&gt;来具体实现目标对象的扩展，前者在选择了深度扩展且扩展对象为数组或纯对象时，通过递归调用&lt;code&gt;jQuery.extend&lt;/code&gt;实现，后者是直接赋值。&lt;/p&gt;

&lt;p&gt;两者相同一点就是同名属性或方法的直接赋值，这就使得后面的属性或方法会&lt;strong&gt;覆盖&lt;/strong&gt;前面或者&lt;code&gt;target&lt;/code&gt;中的同名属性或方法。而当&lt;code&gt;jQuery.extend&lt;/code&gt;只有一个参数的时候，会将其扩展到&lt;code&gt;jQuery&lt;/code&gt;的&lt;strong&gt;全局对象&lt;/strong&gt;或&lt;strong&gt;实例对象&lt;/strong&gt;当中去，我们可以利用这一特性，扩展&lt;code&gt;jQuery&lt;/code&gt;的功能，而实际上我们也是这么做的，这个会在后面谈到，此处不再详细说明。&lt;/p&gt;

&lt;h2&gt;二、工具函数&lt;/h2&gt;

&lt;h3&gt;1、工具函数的函数原型&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;jQuery.extend&lt;/code&gt;中扩展的&lt;strong&gt;全局对象&lt;/strong&gt;工具函数，其函数原型如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery.extend({
    // 在页面中生成一个唯一标识每一个副本jQuery
    expando: &quot;jQuery&quot; + ( version + Math.random() ).replace( /\D/g, &quot;&quot; ),

    // 在没有ready模块时，假定jQuery准备完成
    isReady: true,
    // 抛出指定的错误信息
    error: function( msg ) {    throw new Error( msg );    },
    // 空操作
    noop: function() {},
    isFunction: function( obj ) {},     // 判断参数是否为一个函数

    // 当Array存在判断函数时，只做一个简单的赋值引用，若无则手动创建一个
    isArray: Array.isArray || function( obj ) {},   

    isWindow: function( obj ) {},   // 判断参数是否为浏览器窗口对象window

    isNumeric: function( obj ) {},  // 判断参数是不是数值

    isEmptyObject: function( obj ) {},  // 判断参数是否是一个空对象

    // 判断参数obj是不是通过对象字面量或new Object创建的
    isPlainObject: function( obj ) {},  

    type: function( obj ) {},  // 返回obj类型

    globalEval: function( data ) {},   // 在全局上下文中，求给定的JavaScript字符串数据的值

    // 将参数字符串转换为骆驼表示法，如camelCase,nodeName等，
    // 基本上jQuery中所有的方法都是用的骆驼表示法
    camelCase: function( string ) {},   

    nodeName: function( elem, name ) {},    // 返回指定元素的节点名称与给定的名字是否一样

    // args 仅在each内部使用，对obj执行规定运行的函数callback
    each: function( obj, callback, args ) {},

    trim: function( text ) {},  // 去除参数text末尾中的空白符，包括回车、空格、制表符、换行符

    // results 仅在内部使用，转换一个类似数组的对象成为真正的JavaScript数组
    makeArray: function( arr, results ) {   }, 

    // 确定第一个参数在数组中的位置(如果没有找到则返回 -1 )
    inArray: function( elem, arr, i ) {},  

    merge: function( first, second ) {},  // 将两个参数合并，并返回合并后的值

    grep: function( elems, callback, invert ) {},  // 数组元素过滤筛选

    // arg 仅在内部使用，对当前集合elems中的每个元素调用callback，
    // 将返回结果作为一个新的jQuery对象
    map: function( elems, callback, arg ) {},

    // 一个对象的全局的GUID计数器
    guid: 1,

    // optionally partially applying any arguments
    // 创建一个新的，在指定上下文中执行的函数
    proxy: function( fn, context ) {},

    now: function() { return +( new Date() ); },  // 返回当前时间

    // jQuery.support is not used in Core but other projects attach their
    // properties to it so it needs to exist.
    support: support
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;jQuery.fn.extend&lt;/code&gt;中扩展的&lt;strong&gt;实例对象&lt;/strong&gt;工具函数，其函数原型如下代码所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery.fn.extend({
    // 返回与给定selector选择符匹配的后代元素
    find: function( selector ) {},
    // 与给定的选择符selector匹配的选中元素
    filter: function( selector ) {},

    not: function( selector ) {},   // 选中给定元素集中与给定选择符不匹配的元素

    // 根据选择符来检测匹配元素集合，如果这些元素中至少有一个元素匹配给定的参数，则返回 true
    is: function( selector ) {}     
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;三、源码分析&lt;/h2&gt;

&lt;h3&gt;1、each（ obj, callback ）遍历&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;jQuery&lt;/code&gt;中，&lt;code&gt;each&lt;/code&gt;的源码中关键代码如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var value,
    i = 0,
    length = obj.length,
    isArray = isArraylike( obj );

    if ( isArray ) {
        for ( ; i &amp;lt; length; i++ ) {
            value = callback.call( obj[ i ], i, obj[ i ] );
            if ( value === false ) {
                break;
            }
        }
    } else {
        for ( i in obj ) {
            value = callback.call( obj[ i ], i, obj[ i ] );

            if ( value === false ) {
                break;
            }
        }
    }
return obj;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先通过&lt;strong&gt;数组&lt;/strong&gt;和&lt;strong&gt;对象&lt;/strong&gt;两种方式来遍历参数&lt;code&gt;obj&lt;/code&gt;，对&lt;code&gt;obj&lt;/code&gt;中的每个元素调用&lt;code&gt;callback.call&lt;/code&gt;将每个元素绑定到回调函数上执行，并返回执行结果。&lt;/p&gt;

&lt;p&gt;当回调函数返回&lt;code&gt;false&lt;/code&gt;，则停止循环。在其源码中还涉及到&lt;code&gt;callback.apply&lt;/code&gt;的方式来调用回调函数，其作用于&lt;code&gt;call&lt;/code&gt;一样，都是将函数绑定到另外一个对象上去运行。关于&lt;code&gt;call&lt;/code&gt;与&lt;code&gt;apply&lt;/code&gt;的详细说明，可以跳转到&lt;a href=&quot;http://www.blogways.net/blog/2014/07/22/somethings-of-array-and-function.html&quot; title=&quot;JavaScript中，Array和Function的那些事儿&quot;&gt;JavaScript中，Array和Function的那些事儿&lt;/a&gt;查看详细信息！&lt;/p&gt;

&lt;h3&gt;示例：&lt;/h3&gt;

&lt;p&gt;测试代码如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
        &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
            $(document).ready(function(){
                $(&quot;button&quot;).click(function(){
                    $(&quot;li&quot;).each(function(){
                        alert($(this).text())
                    });
                });
            });
    &amp;lt;/script&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;button&amp;gt;输出每个列表项的值&amp;lt;/button&amp;gt;
        &amp;lt;ul&amp;gt;
            &amp;lt;li&amp;gt;Coffee&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;Milk&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;Soda&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行上面代码，会依次弹出三个警示框，分别显示&lt;code&gt;&amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;&lt;/code&gt;中的值。你可以到&lt;a href=&quot;http://www.w3school.com.cn/tiy/t.asp?f=jquery_traversing_each&quot;&gt;$.each()遍历&lt;/a&gt;运行测试样例！&lt;/p&gt;

&lt;p&gt;其中&lt;code&gt;function(){}&lt;/code&gt;就是&lt;code&gt;each( obj, callback )&lt;/code&gt;中的回调函数&lt;code&gt;callback&lt;/code&gt;，此处只是显示列表项的值，不需要指定特定的&lt;code&gt;index&lt;/code&gt;和&lt;code&gt;element&lt;/code&gt;，在某些情况下需要用之来辨别当前所遍历的元素，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var info = [ 
        { &quot;name&quot;:&quot;aaa&quot;, &quot;age&quot;:22, &quot;hobby&quot;:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] },
        { &quot;name&quot;:&quot;bbb&quot;, &quot;age&quot;:23, &quot;hobby&quot;:[&quot;a&quot;,&quot;b&quot;,&quot;d&quot;] },
        { &quot;name&quot;:&quot;ccc&quot;, &quot;age&quot;:22, &quot;hobby&quot;:[&quot;a&quot;,&quot;c&quot;,&quot;d&quot;] } 
    ];
$.each( info, function( index, item ){
    var name = item.name,
        age = item.age,
        hobby = item.hobby;
    alert(&quot;My name is &quot; + name + &quot;,I am &quot; + age + 
                    &quot; years old,my hobbies are &quot; + hobby);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码会逐条输出&lt;code&gt;info&lt;/code&gt;中的信息，你可以将上面代码复制到&lt;a href=&quot;http://jsfiddle.net&quot;&gt;JSFiddle&lt;/a&gt;运行测试！&lt;/p&gt;

&lt;p&gt;其中&lt;code&gt;index&lt;/code&gt;为当前元素在&lt;code&gt;info&lt;/code&gt;中的索引，&lt;code&gt;item&lt;/code&gt;是对当前遍历元素的引用，因此在函数体内使用&lt;code&gt;item.name/age/hobby&lt;/code&gt;即可得到当前遍历元素的值，然后通过&lt;code&gt;alert()&lt;/code&gt;显示到界面。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未完待续。。。&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Jquery Source Analysis One</title>
   <link href="http://www.blogways.net/blog/2014/08/10/jQuery-source-analysis-one.html"/>
   <updated>2014-08-10T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/08/10/jQuery-source-analysis-one</id>
   <content type="html">&lt;h2&gt;一、前言&lt;/h2&gt;

&lt;p&gt;首先了解一下&lt;strong&gt;块级作用域&lt;/strong&gt;与&lt;strong&gt;函数作用域&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;块级作用域&lt;/strong&gt;：任何一对花括号{}中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;函数作用域&lt;/strong&gt;：定义在函数中的参数和变量在函数外部是不可见的。&lt;/p&gt;

&lt;p&gt;大家都知道&lt;code&gt;Javascript&lt;/code&gt;中是没有块级作用域的，那么作为&lt;code&gt;Javascript&lt;/code&gt;的一个框架，&lt;code&gt;jQuery&lt;/code&gt;要应用到各种环境中，要怎么解决命名空间冲突的问题是一个关键。&lt;/p&gt;

&lt;h3&gt;1、立即调用函数表达式（IIFE）&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;jQuery&lt;/code&gt;源码中，你会看到如下的代码结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function( global, factory){
    //code
}(typeof window !== &quot;undefined&quot; ? window : this, function( window, noGlobal){
    //code

    if ( typeof noGlobal === strundefined ) {
        window.jQuery = window.$ = jQuery;
    }
    return jQuery;
}));
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;这是一个&lt;code&gt;立即调用函数表达式(IIFE)&lt;/code&gt;，创建一个匿名函数&lt;code&gt;function( global, factory){}&lt;/code&gt;，创建完成后立即传递参数并运行。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在函数名后面直接加一对&lt;code&gt;()&lt;/code&gt;表示调用该函数,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; function fn( a, b ){};
 fn();   //调用函数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 而IIFE只是将分开的两步作为一步来书写，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ( function( a, b ){
     //code
 }( x, y ) );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 这就叫做&lt;code&gt;立即调用函数表达式(IIFE)&lt;/code&gt;。此外，还有另一种书写方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; (functioin( a, b ){
     //code
 })( x, y );
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;通过定义一个&lt;code&gt;IIFE&lt;/code&gt;，相当于创建了一个“私有”的命名空间，该命名空间中的&lt;strong&gt;所有变量和方法&lt;/strong&gt;只为自己所有，如不进行特殊处理，函数外无法访问这些变量及方法，不会破坏全局的命名空间，达到了与&lt;code&gt;块级作用域&lt;/code&gt;一样的效果。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;提及&lt;code&gt;立即调用函数表达式()IIFE)&lt;/code&gt;，你会发现一个非常有趣的事实，测试代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $(document).ready(function(){
     (function(){
         undefined = &quot;now it's defined&quot;;
         alert(undefined);
         alert(typeof undefined);
     })();
     //会弹出警示框，now it's defined   ;   string
 });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 感兴趣的话可以将代码代码复制到&lt;strong&gt;&lt;a href=&quot;http://jsfiddle.net&quot;&gt;JSFiddle.net&lt;/a&gt;&lt;/strong&gt;自己测试一下。结果是只有firefox的测试结果为&lt;code&gt;undefined&lt;/code&gt;，其他主流浏览器都显示为&lt;code&gt;now it's defined&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt; 鉴于上面出现的问题，所以在&lt;code&gt;jQuery&lt;/code&gt;源码中用了&lt;code&gt;strundefined = typeof undefined;&lt;/code&gt;在未来得及更改&lt;code&gt;undefined&lt;/code&gt;之前为其创建一个不可变的常数副本。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;window.jQuery = window.$ = jQuery;&lt;/code&gt;通过此代码，将&lt;code&gt;jQuery&lt;/code&gt;和&lt;code&gt;$&lt;/code&gt;标示符暴露给&lt;code&gt;window&lt;/code&gt;，最后&lt;code&gt;return jQuery;&lt;/code&gt;返回jQuery实例供外部使用。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;二、代码结构&lt;/h2&gt;

&lt;h3&gt;1、jQuery源码结构&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;jQuery&lt;/code&gt;源码中，从前到后代码实现的功能如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function( global, factory){
    //code
}(typeof window !== &quot;undefined&quot; ? window : this, function( window, noGlobal){

    jQuery = function( selector, context ) {
        return new jQuery.fn.init( selector, context );
    };

    jQuery.fn = jQuery.prototype = {
        // Code
    };

    jQuery.extend = jQuery.fn.extend = function() {
        // Code
    };

    jQuery.extend({
        //Code
    });
    // jQuery选择器引擎
    var Sizzle = (function( window ){
        // Code
        // 使用立即调用函数表达式(IIFE)，生成Sizzle
    })( window );

    init = jQuery.fn.init = function( selector, context ) {
        // Code
    }
    // Give the init function the jQuery prototype for later instantiation
    init.prototype = jQuery.fn;

    // DOM遍历方法

    // Callback及Deferred，回调函数及延迟方法

    // Support 浏览器测试

    // Data 数据缓存；

    // Queue 队列操作；

    // Event 事件处理；浏览器兼容处理

    // DOM 操作方法；DOM节点插入方法；

    // CSS

    // FX 动画

    // Attr 特性与属性（attr、prop、class）

    // 异步请求 AJAX

    // 位置坐标、窗口视口大小


    return jQuery;
}));    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上为&lt;code&gt;jQuery&lt;/code&gt;源码的大致的代码结构，从中可以看出代码结构非常清晰、条理明确，以上为&lt;code&gt;jquery-1.11.1.js&lt;/code&gt;版本当中的代码结构。&lt;/p&gt;

&lt;h2&gt;三、源码分析&lt;/h2&gt;

&lt;h3&gt;1、构造jQuery对象&lt;/h3&gt;

&lt;p&gt;在我们使用&lt;code&gt;jQuery&lt;/code&gt;的时候，并没有像&lt;code&gt;javascript&lt;/code&gt;一样，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// js                                   // jquery
var jq = function(){                    $(document).ready(...);
    // constructor 构造器                $.getJSON(...);
};                                      $.ajax(...);

jq.prototype = {
    // prototype 原型
    find: function(){},
    show: function(){}
};

var jq1 = new jq();
jq1.find();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;jQuery&lt;/code&gt;没有通过&lt;code&gt;new&lt;/code&gt;来创建实例，按照我们的书写方式，那么&lt;code&gt;$()&lt;/code&gt;应该返回的是一个&lt;code&gt;jQuery&lt;/code&gt;的实例对象，源码中的实现方式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery = function( selector, context ) {
    return new jQuery.fn.init( selector, context );
};
    （）
jQuery.fn = jQuery.prototype = {
    // Code
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过将&lt;code&gt;jQuery&lt;/code&gt;类当作一个工厂方法来创建实例，将该创建方法放到&lt;code&gt;prototype&lt;/code&gt;原型当中，那么在我们调用的时候就不必通过&lt;code&gt;new&lt;/code&gt;关键字来创建了，直接调用&lt;code&gt;jQuery( selector, context )&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果直接将创建方法&lt;code&gt;init&lt;/code&gt;放到&lt;code&gt;prototype&lt;/code&gt;当中:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery = function( selector, context ) {
    return new jQuery.prototype.init( selector, context );
};

jQuery.fn = jQuery.prototype = {
    init: function(){
        this.age = 23;
        return this;    // 返回jQuery实例对象
    },
    age: 18
    // code
};
jQuery().age    // 23
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上所示，因为使用的时工厂模式来创建并返回一个&lt;code&gt;jQuery&lt;/code&gt;的实例，那么&lt;code&gt;init&lt;/code&gt;中&lt;code&gt;return this;&lt;/code&gt;的&lt;code&gt;this&lt;/code&gt;就表示当前实例（&lt;code&gt;jQuery&lt;/code&gt;对象的实例），这久导致了一个严重的问题，&lt;code&gt;init&lt;/code&gt;方法当中指像直接的&lt;code&gt;this&lt;/code&gt;没有了。&lt;/p&gt;

&lt;p&gt;实际的情况是，内部的&lt;code&gt;this&lt;/code&gt;会覆盖上传的，因此返回的对象不是一个代表&lt;code&gt;jQuery&lt;/code&gt;的实例，而是一个&lt;code&gt;init&lt;/code&gt;的实例，所以&lt;code&gt;jQuery.age&lt;/code&gt;的值不是18，而是23.&lt;/p&gt;

&lt;p&gt;因为&lt;code&gt;init&lt;/code&gt;和&lt;code&gt;jQuery&lt;/code&gt;的&lt;strong&gt;作用域相同&lt;/strong&gt;（都为&lt;code&gt;jQuery.prototype.init&lt;/code&gt;）才会导致上面情况的发生，在源码中的解决方式是将&lt;code&gt;jQuery&lt;/code&gt;的作用域挂载到&lt;code&gt;jQuery.fn.init&lt;/code&gt;当中，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery.fn = jQuery.prototype = {
    // code
};
init = jQuery.fn.init = function( selector, context ) {
    // Code
}
init.prototype = jQuery.fn;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先执行&lt;code&gt;jQuery.fn = jQuery.prototype&lt;/code&gt;，再执行&lt;code&gt;(jQuery.fn.)init.prototype = jQuery.fn;&lt;/code&gt;，在执行那个这些语句后，挂载到&lt;code&gt;jQuery.fn.init&lt;/code&gt;上就相当于挂载到了&lt;code&gt;jQuery.prototype.init&lt;/code&gt;，即挂载到了&lt;code&gt;jQuery&lt;/code&gt;函数上。&lt;/p&gt;

&lt;p&gt;最后的结果是挂载到了我们最终使用的&lt;code&gt;jQuery&lt;/code&gt;对象实例上，&lt;code&gt;jQuery.fn.init&lt;/code&gt;是实际上创建&lt;code&gt;jQuery&lt;/code&gt;实例对象的地方。&lt;/p&gt;

&lt;h3&gt;2、jQuery.extend和jQuery.fn.extend&lt;/h3&gt;

&lt;p&gt;合并两个或更多对象的属性到第一个对象中，&lt;code&gt;jQuery&lt;/code&gt;中后续的&lt;strong&gt;大部分功能&lt;/strong&gt;都时通过该函数进行扩展，通过&lt;code&gt;jQuery.fn.extend&lt;/code&gt;扩展的函数，大部分都会调用通过&lt;code&gt;jQuery.extend&lt;/code&gt;扩展的同名函数。函数原型如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.extend( target, object1, object2, ... )
.fn.extend( target, object1, object2, ... )
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;如果传入两个或多个对象，所有对象的属性会被添加到第一个对象&lt;code&gt;target&lt;/code&gt;中，&lt;/li&gt;
&lt;li&gt;如果只传入一个对象，则将对象的属性添加到&lt;code&gt;jQuery&lt;/code&gt;对象中。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;用这种方式，我们可以为&lt;code&gt;jQuery&lt;/code&gt;命名空间增加新的方法。可以用于编写&lt;code&gt;jQuery&lt;/code&gt;插件，如果不想改变传入的对象，可以传入一个空对象：&lt;code&gt;$.extend({}, object1, object2, ... );&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;默认合并操作是不迭代的，即便&lt;code&gt;target&lt;/code&gt;的某个属性是对象或属性，也会被完全覆盖而不是合并&lt;/li&gt;
&lt;li&gt;第一个参数是&lt;code&gt;true&lt;/code&gt;，则会迭代合并&lt;/li&gt;
&lt;li&gt;从&lt;code&gt;object&lt;/code&gt;原型继承的属性会被拷贝&lt;/li&gt;
&lt;li&gt;&lt;code&gt;undefined&lt;/code&gt;值不会被拷贝&lt;/li&gt;
&lt;li&gt;因为性能原因，&lt;code&gt;JavaScript&lt;/code&gt;自带类型的属性不会合并&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;更详细讲解请参考&lt;a href=&quot;http://www.cnblogs.com/RascallySnake/archive/2010/05/07/1729563.html&quot;&gt;jQuery.extend 函数详解&lt;/a&gt; ！&lt;/p&gt;

&lt;h3&gt;3、jQuery.extend 示例&lt;/h3&gt;

&lt;h4&gt;1）$.extend(object) / $.extend( target, obj1, obj2, ... )&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;$.extend( object )&lt;/code&gt;方法就是将&lt;code&gt;object&lt;/code&gt;合并到&lt;code&gt;jQuery&lt;/code&gt;的&lt;strong&gt;全局对象&lt;/strong&gt;中去，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.extend({
    sum: function( a, b ){ 
        return a + b;
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将&lt;code&gt;sum&lt;/code&gt;方法扩展到&lt;code&gt;jQuery&lt;/code&gt;的全局方法中去，类似于&lt;code&gt;C/C++&lt;/code&gt;、&lt;code&gt;JAVA&lt;/code&gt;当中的静态方法。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$.extend( target, obj1, obj2, ... )&lt;/code&gt;方法将&lt;code&gt;obj1, obj2, ...&lt;/code&gt;合并到&lt;code&gt;target&lt;/code&gt;当中，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var result = $.extend( {}, { name: 'A', age: 20}, {name: 'B', gender: 'female'} );
// result = { name: 'B', age: 20, gender: 'female'};
// 此处target为 {} ,将obj1，obj2合并到一个新的对象中
// 在不希望改变target的情况下使用
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2) $.fn.extend(obj)&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;$.fn.extend( object )&lt;/code&gt;方法是讲&lt;code&gt;object&lt;/code&gt;合并到&lt;code&gt;jQuery&lt;/code&gt;的&lt;strong&gt;实例对象&lt;/strong&gt;中去。&lt;/p&gt;

&lt;p&gt;类似&lt;code&gt;C/C++&lt;/code&gt;、&lt;code&gt;JAVA&lt;/code&gt;中&lt;strong&gt;类的方法&lt;/strong&gt;，只有&lt;code&gt;jQuery&lt;/code&gt;的实例可以调用！&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未完待续。。。&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Somethings Of Array And Function</title>
   <link href="http://www.blogways.net/blog/2014/07/22/somethings-of-array-and-function.html"/>
   <updated>2014-07-22T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/07/22/somethings-of-array-and-function</id>
   <content type="html">&lt;div class=&quot;code fl&quot;&gt;
    &lt;dl&gt;
    &lt;dt&gt;目录&lt;/dt&gt;
    &lt;dd&gt;
    &lt;ol type=&quot;I&quot;&gt;
        &lt;li&gt;&lt;a href=&quot;#1&quot;&gt;概述&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;
            &lt;a href=&quot;#2&quot;&gt;Function的那些事儿&lt;/a&gt;
            &lt;ol type=&quot;1&quot;&gt;
                &lt;li&gt;arguments不是Array，但可以构造出一个Array对象来！&lt;/li&gt;
                &lt;li&gt;相同功能，不同调用形式的两方法——apply和call&lt;/li&gt;
                &lt;li&gt;去优雅地使用apply和call吧！&lt;/li&gt;
                &lt;li&gt;使用bind方法，再造函数！&lt;/li&gt;
                &lt;li&gt;uncurryThis，你知道吗？&lt;/li&gt;
            &lt;/ol&gt;
        &lt;/li&gt;
        &lt;li&gt;
            &lt;a href=&quot;#3&quot;&gt;Array的那些事儿&lt;/a&gt;
            &lt;ol type=&quot;1&quot;&gt;
                &lt;li&gt;可以浅度复制数组的slice方法&lt;/li&gt;
                &lt;li&gt;不仅仅作用于数组的堆栈操作，四方法：push/pop/shift/unshift&lt;/li&gt;
                &lt;li&gt;可删可插入的splice方法&lt;/li&gt;
                &lt;li&gt;forEach/map/reduce的实现与效率！&lt;/li&gt;
                &lt;li&gt;其他：join/concat/sort/reverse/...&lt;/li&gt;
            &lt;/ol&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#4&quot;&gt;结束&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
    &lt;/dd&gt;
    &lt;/dl&gt;
&lt;/div&gt;


&lt;p&gt;&lt;a name=&quot;1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;一、概述&lt;/h3&gt;

&lt;p&gt;在JavaScript中，内置对象Array和Function本身提供了不少方法，有些方法为人所熟知，有些方法则不被注意。而有些方法虽然被人所熟悉，却又有不被重视的使用场景，去实现一些妙用。&lt;/p&gt;

&lt;p&gt;本文结合当下自己的使用心得，一方面做个分享，一方面也是个备忘，哈哈！&lt;/p&gt;

&lt;p&gt;&lt;a name=&quot;2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;二、Function的那些事儿&lt;/h3&gt;

&lt;h4&gt;2.1 arguments不是Array！&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;arguments&lt;/code&gt;是函数被执行时，传入的实参集合。他直接在函数里面被类似于一个数组进行访问。&lt;/p&gt;

&lt;p&gt;在Chrome浏览器的控制台执行下面代码（&lt;em&gt;本文代码都可以在Chrome浏览器的控制台中运行&lt;/em&gt;）：&lt;/p&gt;

&lt;p&gt;```
function testFunc() {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;console.log(arguments);

for(var i=0; i&amp;lt;arguments.length; ++i) {
    console.log(arguments[i]);
}

for(var idx in arguments) {
    console.log(arguments[idx]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```
传入参数运行:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
testFunc(1,2,3,4)
&lt;/code&gt;
执行结果：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
[1, 2, 3, 4]
1
2
3
4
1
2
3
4
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;从上面例子中，我们可以访问&lt;code&gt;arguments&lt;/code&gt;的&lt;code&gt;length&lt;/code&gt;属性，来确定实参的个数，以及通过下标对&lt;code&gt;arguments&lt;/code&gt;进行访问，获取我们需要的某个参数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;注意&lt;/span&gt;：arguments不是一个Array！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;示例代码：&lt;/p&gt;

&lt;p&gt;```
var testFunc = function() {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;console.log(&quot;[] 是一个 Array？&quot;+Array.isArray([]));
console.log(&quot;arguments 是一个Array？&quot;+Array.isArray(arguments));
console.log(&quot;arguments toString:&quot; + arguments.toString());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```
传入参数运行:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
testFunc(1,2,3,4)
&lt;/code&gt;
执行结果：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
[] 是一个 Array？true
arguments 是一个Array？false
arguments toString:[object Arguments]
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;提示&lt;/span&gt;：我们可以基于arguments构造一个数组对象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;示例代码：&lt;/p&gt;

&lt;p&gt;```
var testFunc = function() {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var args = Array.prototype.slice.apply(arguments);
console.log(&quot;args 是一个 Array?&quot;+Array.isArray(args));
console.log(args);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;p&gt;运行：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
testFunc(1,2,3,4)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;结果：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
args 是一个 Array?true
[1, 2, 3, 4]
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;当然，你也可以在构造的同时，对实参进行裁剪。参考代码如下：&lt;/p&gt;

&lt;p&gt;```
var testFunc = function() {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var args = Array.prototype.slice.call(arguments, 1);
console.log(args);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;h4&gt;2.2 相同功能，不同参数形式的两方法——apply和call&lt;/h4&gt;

&lt;p&gt;这两个方法的功能相同，只是定义参数方式不同：
它们的作用都是将函数绑定到另外一个对象上去运行，两者仅在定义参数方式有所区别：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Function.apply(thisArg,argArray);&lt;/p&gt;

&lt;p&gt;Function.call(thisArg[,arg1,arg2…]);&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;他们的功能，都是将函数绑定到一个指定的对象上去运行，即所有函数内部的this指针都会被赋值为thisArg。&lt;/p&gt;

&lt;p&gt;这种功能，可以实现将函数作为特定对象的方法，进行执行的目的。&lt;/p&gt;

&lt;p&gt;为什么会有这两种不同的形式呢？是为满足需求，而决定的！&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Function.call&lt;/code&gt;的形式很自然，调用起来很方便，就像&lt;code&gt;2.1&lt;/code&gt;小节最后那个例子那样。在这个例子中，你肯定不愿意使用&lt;code&gt;Function.apply&lt;/code&gt;，是不是？&lt;/p&gt;

&lt;p&gt;但是，它存在一个缺点：当函数的参数个数是动态的，只能在运行过程中才能确定下来，那么使用&lt;code&gt;Function.call&lt;/code&gt;就不合适了，就只能使用&lt;code&gt;Function.apply&lt;/code&gt;了。在运行过程中，将动态的参数都放到数组中去，然后把数组作为一个参数，传给&lt;code&gt;Function.apply&lt;/code&gt;。这样就完美的解决问题了！&lt;/p&gt;

&lt;h4&gt;2.3 去优雅地使用apply和call吧&lt;/h4&gt;

&lt;p&gt;有一个动态数组:&lt;/p&gt;

&lt;p&gt;```
var numbers=[]
for(var i=0; i&amp;lt;100; ++i) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;numbers[i] = Math.floor(Math.random()*10000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;p&gt;要求：从中找到最大数和最小数。&lt;/p&gt;

&lt;p&gt;先看看常规的方法吧：&lt;/p&gt;

&lt;p&gt;```
max = -Infinity, min = +Infinity;&lt;/p&gt;

&lt;p&gt;numbers.forEach(function(item) {
  if (item &gt; max) max = item;
  if (item &amp;lt; min) min = item;
})
```&lt;/p&gt;

&lt;p&gt;那么，如何优雅地使用&lt;code&gt;apply&lt;/code&gt;去编码呢？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
var max = Math.max.apply(null, numbers);
var min = Math.min.apply(null, numbers);
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;就执行效率而言，后者也比前者快！&lt;/p&gt;

&lt;p&gt;当然，就解决这个题目而言，还有更快的方案，有兴趣地话，可以看看笔者的测试：&lt;a href=&quot;http://jsperf.com/apply-vs-loop-for-max/2&quot;&gt;&lt;code&gt;http://jsperf.com/apply-vs-loop-for-max/2&lt;/code&gt;&lt;/a&gt;。这个测试的结果，可能会颠覆你的认知，让你惊讶的。^_^&lt;/p&gt;

&lt;h4&gt;2.4 使用bind方法，定制函数！&lt;/h4&gt;

&lt;p&gt;先看定义：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;fun.bind(thisArg[, arg1[, arg2[, ...]]])&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;如果说，前面的&lt;code&gt;apply&lt;/code&gt;和&lt;code&gt;call&lt;/code&gt;方法是将函数绑定到特定的对象上去执行。那么，&lt;code&gt;bind&lt;/code&gt;方法，就是只绑定，不执行。&lt;/p&gt;

&lt;p&gt;它生成一个新的方法，它可以给已知的函数&lt;code&gt;fun&lt;/code&gt;绑定执行的对象&lt;code&gt;thisArg&lt;/code&gt;，还可以绑定执行的参数&lt;code&gt;[, arg1[, arg2[, ...]]]&lt;/code&gt;，绑定的参数可以是部分，也可以是全部。&lt;/p&gt;

&lt;p&gt;所以，就实现的功能而言，&lt;code&gt;bind&lt;/code&gt;方法也可以借助&lt;code&gt;apply&lt;/code&gt;方法，用下面代码模拟：&lt;/p&gt;

&lt;p&gt;```
Function.prototype.bind = function(ctx) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var fn = this;
var args = Array.prototype.slice.call(arguments, 1);
return function() {
    fn.apply(ctx, args.concat(Array.prototype.slice.call(arguments)));
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;p&gt;那么，&lt;code&gt;bind&lt;/code&gt;有哪些作用，适合用在哪些场合呢？&lt;/p&gt;

&lt;p&gt;看下面这段代码：&lt;/p&gt;

&lt;p&gt;背景设定：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
this.x = 9;
var module = {
  x: 81,
  getX: function() { return this.x; }
};
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;调用：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
module.getX(); // 81
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如你所愿，执行结果是 &lt;code&gt;81&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;有时，你可能不经意间，进行赋值：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
var getX = module.getX;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;再运行：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
getX(); // 9, because in this case, &quot;this&quot; refers to the global object
&lt;/code&gt;
可能，你希望结果是 &lt;code&gt;81&lt;/code&gt;，但却是&lt;code&gt;9&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;怎么才能让结果仍然是 &lt;code&gt;81&lt;/code&gt;呢？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
// create a new function with 'this' bound to module
var boundGetX = getX.bind(module);
boundGetX(); // 81
&lt;/code&gt;
是的，如上使用&lt;code&gt;bind&lt;/code&gt;就可以了！&lt;/p&gt;

&lt;h4&gt;2.5 uncurryThis，你知道吗？&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;uncurryThis&lt;/code&gt;话题，来自于&lt;code&gt;Brendan Eich&lt;/code&gt;(&lt;code&gt;JavaScript&lt;/code&gt;之父)的一个&lt;a href=&quot;http://twitter.com/BrendanEich/status/128975787448741891&quot;&gt;tweet&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;uncurryThis&lt;/code&gt;的最重要的用途，就是&lt;strong&gt;将对象的方法变为函数去使用&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;特殊一点，可以将A对象的方法a使用到B对象上去。在前面&lt;code&gt;2.1&lt;/code&gt;小节中，我们就用到了这个技巧，在&lt;code&gt;Arguments&lt;/code&gt;对象上使用了&lt;code&gt;Array&lt;/code&gt;对象的方法&lt;code&gt;slice&lt;/code&gt;。很有用，不是吗？&lt;/p&gt;

&lt;p&gt;那么怎么实现&lt;code&gt;uncurryThis&lt;/code&gt;呢？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;扩展Function原型去实现（Brendan Eich写的实现代码）:&lt;/p&gt;

&lt;p&gt;  &lt;code&gt;
Function.prototype.uncurryThis = function () {
      var f = this;
      return function () {
          var a = arguments;
          return f.apply(a[0], [].slice.call(a, 1));
      };
};
 &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;  使用：&lt;/p&gt;

&lt;p&gt;  &lt;code&gt;
var toUpperCase = String.prototype.toUpperCase.uncurryThis();
[ &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot; ].map(toUpperCase)
 &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;  运行结果：&lt;/p&gt;

&lt;p&gt;  &lt;code&gt;
[ 'FOO', 'BAR', 'BAZ' ]
 &lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;独立的函数实现：&lt;/p&gt;

&lt;p&gt;  &lt;code&gt;
var uncurryThis = function(f) {
      var call = Function.call;
      return function() {
          return call.apply(f, arguments);
      };
};
 &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;  使用：&lt;/p&gt;

&lt;p&gt;  &lt;code&gt;
var toUpperCase = uncurryThis(String.prototype.toUpperCase);
[ &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot; ].map(toUpperCase)
 &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;  运行结果：&lt;/p&gt;

&lt;p&gt;  &lt;code&gt;
[ 'FOO', 'BAR', 'BAZ' ]
 &lt;/code&gt;
&lt;a name=&quot;3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;三、Array的那些事儿&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Array是个很常用的内置对象，在Javascript规范的逐步完善中，其内置方法在不知不觉中已经提供了很多了。本文仅介绍一些常用的方法。&lt;/p&gt;

&lt;h4&gt;3.1 可以浅度复制数组的slice方法&lt;/h4&gt;

&lt;p&gt;定义：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;arr.slice(begin[, end])&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;说明：返回一个新的浅度复制数组，包含从 &lt;code&gt;begin&lt;/code&gt; 到 &lt;code&gt;end&lt;/code&gt; （不包括该元素）的 &lt;code&gt;arr&lt;/code&gt; 中的元素。(&lt;em&gt;原数组内容不发生变化&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;表示在原数组上，选取的范围。如果&lt;code&gt;end&lt;/code&gt;省略，表示原数组的结尾。 如果&lt;code&gt;begin&lt;/code&gt;省略，表示从0位开始。也可以是负数，表示从原数组的尾部开始计算位置。&lt;/p&gt;

&lt;p&gt;举例：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
var arr = [1,2,3,4,5,6,7,8];
arr.slice(2,4);      // [3, 4]
arr.slice(4);        // [5, 6, 7, 8]
arr.slice(-3);       // [6, 7, 8]
arr.slice(3, -2);    // [4, 5, 6]
arr.slice(-3, -1);   // [6, 7]
arr.slice();         // [1,2,3,4,5,6,7,8]
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;提示&lt;/span&gt;：利用&lt;code&gt;Array.prototype.slice&lt;/code&gt;,我们可以将一个类似array对象，转换为array对象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;arguments&lt;/code&gt;不是数组，但可以转换为数组。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
var args = Array.prototype.slice.call(arguments);
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们还可以看一个例子：&lt;/p&gt;

&lt;p&gt;```
function a() { return {length:2, 0:&quot;hello&quot;, 1:&quot;world&quot;}}&lt;/p&gt;

&lt;p&gt;var t = a();&lt;/p&gt;

&lt;p&gt;var z = Array.prototype.slice.call(t);&lt;/p&gt;

&lt;p&gt;t instanceof Array;      // false
z instanceof Array       // true
console.log(z);          // [&quot;hello&quot;, &quot;world&quot;]
```&lt;/p&gt;

&lt;h4&gt;3.2 不仅仅作用于数组的堆栈操作，四方法：push/pop/shift/unshift&lt;/h4&gt;

&lt;p&gt;先看定义：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;arr.push(element1, ..., elementN)&lt;/p&gt;

&lt;p&gt;arr.pop()&lt;/p&gt;

&lt;p&gt;arr.shift()&lt;/p&gt;

&lt;p&gt;arr.unshift(element1, ..., elementN)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;push&lt;/code&gt;将n个元素&lt;code&gt;element1, ..., elementN&lt;/code&gt;追加到数组的尾部，其返回值为调用后数组的长度；&lt;/p&gt;

&lt;p&gt;  &lt;code&gt;
var sports = [&quot;soccer&quot;, &quot;baseball&quot;];
var total = sports.push(&quot;football&quot;, &quot;swimming&quot;);
console.log(sports); // [&quot;soccer&quot;, &quot;baseball&quot;, &quot;football&quot;, &quot;swimming&quot;]
console.log(total);  // 4
&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;pop&lt;/code&gt;将数组的最后一个对象删除，其返还值就是这个删除的元素。如果是个空数组，则返回值为&lt;code&gt;undefined&lt;/code&gt;;&lt;/p&gt;

&lt;p&gt;  &lt;code&gt;
var myFish = [&quot;angel&quot;, &quot;clown&quot;, &quot;mandarin&quot;, &quot;surgeon&quot;];
var popped = myFish.pop();
console.log(myFish);  // [&quot;angel&quot;, &quot;clown&quot;, &quot;mandarin&quot;]
console.log(popped);  // &quot;surgeon&quot;
 &lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;shift&lt;/code&gt; 删除数组的第一个数，并且数组内剩余的值，坐标依次前移。返回值为删掉的元素。如果是个空数组，那么返回值为&lt;code&gt;undefined&lt;/code&gt;;&lt;/p&gt;

&lt;p&gt;  &lt;code&gt;
var myFish = [&quot;angel&quot;, &quot;clown&quot;, &quot;mandarin&quot;, &quot;surgeon&quot;];
var shifted = myFish.shift();
console.log(myFish);   // [&quot;clown&quot;, &quot;mandarin&quot;, &quot;surgeon&quot;]
console.log(shifted);  // &quot;angel&quot;
 &lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;unshift&lt;/code&gt;将n个元素&lt;code&gt;element1, ..., elementN&lt;/code&gt;插入道数组的头部。其返回值为调用后数组的长度。&lt;/p&gt;

&lt;p&gt;  &lt;code&gt;
var arr = [1, 2];
arr.unshift(0); // result of call is 3, the new array length
// arr is [0, 1, 2]
arr.unshift(-2, -1); // = 5
// arr is [-2, -1, 0, 1, 2]
arr.unshift( [-3] );
// arr is [[-3], -2, -1, 0, 1, 2]
 &lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;通过上面这四个方法，可以对数组进行堆栈操作了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;注意&lt;/span&gt;：这四个用作堆栈操作的方法，其实还支持非数组对象。不过，支持的对象需要类似数组。从某种角度而言，这也是支持你实现自定义的具有堆栈功能的对象。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所谓的类似数组，就是有&lt;code&gt;length&lt;/code&gt;属性，可以通过&lt;code&gt;0...n&lt;/code&gt;下标去访问元素。仅此，即可！&lt;/p&gt;

&lt;p&gt;看代码：&lt;/p&gt;

&lt;p&gt;```
var myQueue = function() {return {length:0}};&lt;/p&gt;

&lt;p&gt;var tz = new myQueue();&lt;/p&gt;

&lt;p&gt;Array.prototype.push.call(tz, &quot;hello&quot;, &quot;world&quot;);  // 2&lt;/p&gt;

&lt;p&gt;console.log(Array.prototype.slice.call(tz));  //[&quot;hello&quot;, &quot;world&quot;]&lt;/p&gt;

&lt;p&gt;Array.prototype.shift.call(tz);     // &quot;hello&quot;&lt;/p&gt;

&lt;p&gt;console.log(Array.prototype.slice.call(tz));  //[&quot;world&quot;]&lt;/p&gt;

&lt;p&gt;Array.prototype.unshift.call(tz, &quot;hello&quot;);    // 2&lt;/p&gt;

&lt;p&gt;console.log(Array.prototype.slice.call(tz));  //[&quot;hello&quot;, &quot;world&quot;]&lt;/p&gt;

&lt;p&gt;Array.prototype.pop.call(tz);     // &quot;world&quot;&lt;/p&gt;

&lt;p&gt;console.log(Array.prototype.slice.call(tz));  //[&quot;hello&quot;]&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;神奇吧！&lt;/p&gt;

&lt;h4&gt;3.3 可删可插入的splice方法&lt;/h4&gt;

&lt;p&gt;先看定义：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;array.splice(index , howMany[, element1[, ...[, elementN]]])&lt;/p&gt;

&lt;p&gt;array.splice(index)   // SpiderMonkey/Firefox/Chrome extension&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;其中， &lt;code&gt;index&lt;/code&gt;表示数组中操作所开始的位置。如果大于数组的长度，那就重定位为数组的尾端。如果是负数，那就从数组的尾端向前移。&lt;code&gt;howMany&lt;/code&gt;，表示要删除的个数，如果是0，则表示不删除。&lt;code&gt;[, element1[, ...[, elementN]]]&lt;/code&gt;，表示要插入的个数。 该方法的返回值为：删除的元素数组。&lt;/p&gt;

&lt;p&gt;看实例：&lt;/p&gt;

&lt;p&gt;```
var myFish = [&quot;angel&quot;, &quot;clown&quot;, &quot;mandarin&quot;, &quot;surgeon&quot;];&lt;/p&gt;

&lt;p&gt;//removes 0 elements from index 2, and inserts &quot;drum&quot;
var removed = myFish.splice(2, 0, &quot;drum&quot;);
//myFish is [&quot;angel&quot;, &quot;clown&quot;, &quot;drum&quot;, &quot;mandarin&quot;, &quot;surgeon&quot;]
//removed is [], no elements removed&lt;/p&gt;

&lt;p&gt;//removes 1 element from index 3
removed = myFish.splice(3, 1);
//myFish is [&quot;angel&quot;, &quot;clown&quot;, &quot;drum&quot;, &quot;surgeon&quot;]
//removed is [&quot;mandarin&quot;]&lt;/p&gt;

&lt;p&gt;//removes 1 element from index 2, and inserts &quot;trumpet&quot;
removed = myFish.splice(2, 1, &quot;trumpet&quot;);
//myFish is [&quot;angel&quot;, &quot;clown&quot;, &quot;trumpet&quot;, &quot;surgeon&quot;]
//removed is [&quot;drum&quot;]&lt;/p&gt;

&lt;p&gt;//removes 2 elements from index 0, and inserts &quot;parrot&quot;, &quot;anemone&quot; and &quot;blue&quot;
removed = myFish.splice(0, 2, &quot;parrot&quot;, &quot;anemone&quot;, &quot;blue&quot;);
//myFish is [&quot;parrot&quot;, &quot;anemone&quot;, &quot;blue&quot;, &quot;trumpet&quot;, &quot;surgeon&quot;]
//removed is [&quot;angel&quot;, &quot;clown&quot;]&lt;/p&gt;

&lt;p&gt;//removes 2 elements from index 3
removed = myFish.splice(3, Number.MAX_VALUE);
//myFish is [&quot;parrot&quot;, &quot;anemone&quot;, &quot;blue&quot;]
//removed is [&quot;trumpet&quot;, &quot;surgeon&quot;]
```&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;提示&lt;/span&gt;：我们可以用splice方法来实现数组的堆栈操作：push/pop/shift/unshift方法&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;函数方式实现：&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;```
var push = function(arr) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var args = Array.prototype.slice.call(arguments,1);
args = [arr.length, 0].concat(args);
Array.prototype.splice.apply(arr, args);
return arr.length;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;var pop = function(arr) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (arr.length==0) return undefined;
var el = Array.prototype.splice.call(arr, arr.length-1);
return el[0];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;var shift = function(arr) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (arr.length==0) return undefined;
var el = Array.prototype.splice.call(arr, 0, 1);
return el[0];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;var unshift = function(arr) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var args = Array.prototype.slice.call(arguments,1);
args = [0, 0].concat(args);
Array.prototype.splice.apply(arr, args);
return arr.length;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;原型方式实现：&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;```
Array.prototype.push = function() {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var self = this;
var args = Array.prototype.slice.call(arguments);
args = [self.length, 0].concat(args);
Array.prototype.splice.apply(self, args);
return self.length;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;Array.prototype.pop = function() {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var self = this;
if (self.length==0) return undefined;
var el = Array.prototype.splice.call(self, self.length-1);
return el[0];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;Array.prototype.shift = function() {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var self = this;
if (self.length==0) return undefined;
var el = Array.prototype.splice.call(self, 0, 1);
return el[0];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;Array.prototype.unshift = function() {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var self = this;
var args = Array.prototype.slice.call(arguments);
args = [0, 0].concat(args);
Array.prototype.splice.apply(self, args);
return self.length;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;由于是使用&lt;code&gt;splice&lt;/code&gt;方法来替代实现的，所以，这些方法不能用于类似数组对象。&lt;/p&gt;

&lt;p&gt;笔者做了下性能对比测试：原生的最快，原型形式模拟的次之，函数形式模拟的最慢。性能测试见：&lt;a href=&quot;http://jsperf.com/splice-vs-push-pop-shift-unshift&quot;&gt;http://jsperf.com/splice-vs-push-pop-shift-unshift&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;3.4 forEach/map/reduce的实现与效率！&lt;/h4&gt;

&lt;p&gt;先看定义：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;arr.forEach(callback[, thisArg])&lt;/p&gt;

&lt;p&gt;arr.reduce(callback,[initialValue])&lt;/p&gt;

&lt;p&gt;arr.map(callback[, thisArg])&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;给使用示例：&lt;/p&gt;

&lt;p&gt;```
var numbers=[]
for(var i=0; i&amp;lt;100; ++i) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;numbers[i] = i;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;var sum = 0;
numbers.forEach(function(item) {
  sum += item;
})&lt;/p&gt;

&lt;p&gt;console.log(sum);   //4950&lt;/p&gt;

&lt;p&gt;var sum = numbers.reduce(function(sum, item){&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return sum+item;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}, 0);&lt;/p&gt;

&lt;p&gt;console.log(sum);  //4950&lt;/p&gt;

&lt;p&gt;numbers.slice(1,4).map(function(item){return Math.pow(item,2)});  //[1, 4, 9]&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;不太想写新手入门教程。写到这里，想说的是&lt;span style=&quot;color:red&quot;&gt;注意&lt;/span&gt;下面几点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;reduce&lt;/code&gt;可以替代&lt;code&gt;forEach&lt;/code&gt;的实现，并且效率略高一点点。实现和测试可见：&lt;a href=&quot;http://jsperf.com/apply-vs-loop-for-max/2&quot;&gt;&lt;code&gt;http://jsperf.com/apply-vs-loop-for-max/2&lt;/code&gt;&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;无论&lt;code&gt;forEach&lt;/code&gt;还是&lt;code&gt;reduce&lt;/code&gt;，都没有手写的&lt;code&gt;loop&lt;/code&gt;循环效率高。具体测试可见&lt;a href=&quot;http://jsperf.com/apply-vs-loop-for-max/2&quot;&gt;&lt;code&gt;http://jsperf.com/apply-vs-loop-for-max/2&lt;/code&gt;&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;无论&lt;code&gt;forEach&lt;/code&gt;还是&lt;code&gt;map&lt;/code&gt;，其中的&lt;code&gt;callback&lt;/code&gt;都是同步执行的，&lt;code&gt;async.js&lt;/code&gt;框架中提供了对应的异步实现。&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;3.5 其他：join/concat/sort/reverse/every/some...&lt;/h4&gt;

&lt;p&gt;Array内置了很多方法，下面在给出几个使用较多的方法的定义及使用示例。&lt;/p&gt;

&lt;p&gt;定义：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;str = arr.join(separator)&lt;/p&gt;

&lt;p&gt;arr.concat(value1, value2, ..., valueN)&lt;/p&gt;

&lt;p&gt;arr.sort([compareFunction])&lt;/p&gt;

&lt;p&gt;arr.reverse()&lt;/p&gt;

&lt;p&gt;arr.every(callback[, thisArg])&lt;/p&gt;

&lt;p&gt;arr.some(callback[, thisArg])&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;使用示例：&lt;/p&gt;

&lt;p&gt;```
var a = new Array(&quot;Wind&quot;,&quot;Rain&quot;,&quot;Fire&quot;);
var myVar1 = a.join();      // assigns &quot;Wind,Rain,Fire&quot; to myVar1
var myVar2 = a.join(&quot;, &quot;);  // assigns &quot;Wind, Rain, Fire&quot; to myVar2
var myVar3 = a.join(&quot; + &quot;); // assigns &quot;Wind + Rain + Fire&quot; to myVar3&lt;/p&gt;

&lt;p&gt;var alpha = ['a', 'b', 'c'];
var alphaNumeric = alpha.concat(1, [2, 3]);   //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 1, 2, 3]
alphaNumeric = alpha.concat(1,[2,3],[[4]]);   //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 1, 2, 3, [4]]&lt;/p&gt;

&lt;p&gt;var scores = [1, 2, 10, 21];
scores.sort(); // [1, 10, 2, 21]
scores.sort(function(a,b){return a-b}); //[1, 2, 10, 21]&lt;/p&gt;

&lt;p&gt;var myArray = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;];
myArray.reverse();    // [&quot;three&quot;, &quot;two&quot;, &quot;one&quot;]&lt;/p&gt;

&lt;p&gt;function isBigEnough(element, index, array) {
  return (element &gt;= 10);
}
var passed = [12, 5, 8, 130, 44].every(isBigEnough);   //false
passed = [12, 54, 18, 130, 44].every(isBigEnough);     //true&lt;/p&gt;

&lt;p&gt;passed = [2, 5, 8, 1, 4].some(isBigEnough);  //false
passed = [12, 5, 8, 1, 4].some(isBigEnough);  //true&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;注意&lt;/span&gt;：&lt;code&gt;concat&lt;/code&gt;是浅层复制，从上面例子中也可以看出来。&lt;/strong&gt;，如果想实现深层复制，可以参考&lt;code&gt;underscore.js&lt;/code&gt;框架中的&lt;code&gt;_.flatten&lt;/code&gt;,或者参考&lt;code&gt;prototype.js&lt;/code&gt;框架中的&lt;code&gt;Array#flatten()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;a name=&quot;4&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;四、结束&lt;/h3&gt;

&lt;p&gt;非常高兴，你能耐心看完这篇文章，希望能给你带来帮助！欢迎讨论！&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Express4.x API 翻译[4] -- Router</title>
   <link href="http://www.blogways.net/blog/2014/06/16/node-express4.x-api-4.html"/>
   <updated>2014-06-16T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/06/16/node-express4.x-api-4</id>
   <content type="html">&lt;h2&gt;Express4.x API 翻译[4] -- Router&lt;/h2&gt;

&lt;h3&gt;Router()&lt;/h3&gt;

&lt;p&gt;路由器是一个孤立的中间件和路由实例。路由器被看作是唯一能胜任中间件和路由的迷你应用。每个express应用都包含一个内置的路由器。&lt;/p&gt;

&lt;p&gt;路由器行为像中间件本身，可以在应用或者其他路由里使用。&lt;/p&gt;

&lt;p&gt;使用&quot;express.Router()&quot;创建一个新的路由器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var router = express.Router([options]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改变路由行为的可选项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;caseSensitive 开启大小写敏感，默认不开启，&quot;/Foo&quot;和&quot;/foo&quot;同样处理。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Strict 开启严格路由，默认&quot;/foo&quot;和&quot;/foo/&quot;指向同一个路由。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  // invoked for any requests passed to this router
  router.use(function(req, res, next) {
    // .. some logic here .. like any other middleware
    next();
  });

  // will handle any request that ends in /events
  // depends on where the router is &quot;use()'d&quot;
  router.get('/events', function(req, res, next) {
    // ..
  });
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;然后你可以使用一个特定的根url路由器，像这样分离路由到多个文件或者迷你应用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// only requests to /calendar/* will be sent to our &quot;router&quot;
app.use('/calendar', router);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;router.use([path], function)&lt;/h3&gt;

&lt;p&gt;使用中间件功能，可配置挂载路径，默认挂到&quot;/&quot;根路径。&lt;/p&gt;

&lt;p&gt;中间件像一个管道，请求从第一个你定义的中间件开始，然后沿着这个线路一直向下，匹配每一个中间件堆栈中符合的路由。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var express = require('express');
var app = express();
var router = express.Router();

// simple logger for this router's requests
// all requests to this router will first hit this middleware
router.use(function(req, res, next) {
  console.log('%s %s %s', req.method, req.url, req.path);
  next();
});

// this will only be invoked if the path ends in /bar
router.use('/bar', function(req, res, next) {
  // ... maybe some additional /bar logging ...
  next();
});

// always invoked
router.use(function(req, res, next) {
  res.send('Hello World');
});

app.use('/foo', router);

app.listen(3000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;挂载路径被剥离，是不可见的中间件功能。此功能的主要用途是挂载中间件的操作不需要根据它的前缀路径来修改代码。&lt;/p&gt;

&lt;p&gt;使用router.user()定义中间件的顺序非常重要，他们依次被调用，因此这个决定中间件的优先级。例如通常logger是第一个需要用到的中间件，用来记录每个请求：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var logger = require('morgan');

router.use(logger());
router.use(express.static(__dirname + '/public'));
router.use(function(req, res){
  res.send('Hello');
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在假设你想忽略静态文件请求的日志，但在logger()之间继续记录路径跟中间件日志，你只需要将static()移到前面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;router.use(express.static(__dirname + '/public'));
router.use(logger());
router.use(function(req, res){
  res.send('Hello');
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一个具体的例子是来自多个文件目录的文件服务，优先从&quot;./public&quot;中查找：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.use(express.static(__dirname + '/public'));
app.use(express.static(__dirname + '/files'));
app.use(express.static(__dirname + '/uploads'));
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;router.param([name], callback)&lt;/h3&gt;

&lt;p&gt;路由参数映射逻辑。例如当一个路由中包含:user，加载逻辑会自动提供req.user给路由，或者执行参数输入验证。&lt;/p&gt;

&lt;p&gt;下面的代码说明了如果回调，很像中间件，从而支持异步操作，但多了一个id参数。当执行加载用户时，验证req.user，不成功抛出一个错误到next(err)。&lt;/p&gt;

&lt;p&gt;要注意，触发一个命名参数函数来运行路由，仅仅在next在没有被参数处理错误调用的情况下执行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;router.param('user', function(req, res, next, id){
  User.find(id, function(err, user){
    if (err) {
      return next(err);
    }
    else if (!user) {
      return next(new Error('failed to load user'));
    }

    req.user = user;
    next();
  });
});

// this route uses the &quot;:user&quot; named parameter
// which will cause the 'user' param callback to be triggered
router.get('/users/:user', function(req, res, next) {
  // req.user WILL be defined here
  // if there was an error, normal error handling will be triggered
  // and this function will NOT execute
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外你可能只传递一个回调函数，在这种情况下你有机会修改router.param()API。例如express_params定义的回调函数允许你限制参数为给定的正则表达式。&lt;/p&gt;

&lt;p&gt;这个例子有点超前，检查当第二个参数为正则表达式时，返回类似&quot;user&quot;参数示例的回调函数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;router.param(function(name, fn){
  if (fn instanceof RegExp) {
    return function(req, res, next, val){
      var captures;
      if (captures = fn.exec(String(val))) {
        req.params[name] = captures;
        next();
      } else {
        next('route');
      }
    }
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该方法现在被用来有效的验证参数，或者解析他们提供分组：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;router.param('id', /^\d+$/);

router.get('/user/:id', function(req, res){
  res.send('user ' + req.params.id);
});

router.param('range', /^(\w+)\.\.(\w+)?$/);

router.get('/range/:range', function(req, res){
  var range = req.params.range;
  res.send('from ' + range[1] + ' to ' + range[2]);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;router.user()方法也支持命名参数，使其他路由提供的挂载点能使用命名参数预加载。&lt;/p&gt;

&lt;h3&gt;router.route(path)xl&lt;/h3&gt;

&lt;p&gt;返回一个可以用来处理HTTP请求带有可选中间件的中间件路由。推荐使用router.route()避免重复路由定义和拼写错误。&lt;/p&gt;

&lt;p&gt;根据前面所学建立route.param()示例，我们看到router.route()可以让我们轻松的应对各种HTTP请求处理。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var router = express.Router();

router.param('user_id', function(req, res, next, id) {
  // sample user, would actually fetch from DB, etc...
  req.user = {
    id: id,
    name: 'TJ'
  };
  next();
});

router.route('/users/:user_id')
.all(function(req, res, next) {
  // runs for all HTTP verbs first
  // think of it as route specific middleware!
})
.get(function(req, res, next) {
  res.json(req.user);
})
.put(function(req, res, next) {
  // just an example of maybe updating the user
  req.user.name = req.params.name;
  // save user ... etc
  res.json(req.user);
})
.post(function(req, res, next) {
  next(new Error('not implemented'));
})
.delete(function(req, res, next) {
  next(new Error('not implemented'));
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个方法重新使用单'/users/:user_id'路径，添加对各种HTTP请求的处理。&lt;/p&gt;

&lt;h3&gt;router.VERB(path, [callback...], callback)&lt;/h3&gt;

&lt;p&gt;Express中router.VERB()方法提供路由功能，其中WERB属于HTTP请求，例如router.post()。可以有多个回调，所有回调同等对待，行为很像中间件，遇到异常时这些回调会调用next(‘route’)不再执行剩余的回调。这种机制可以用来执行有先决条件的路由，然后将控制权移交到其他没有限制的路由。&lt;/p&gt;

&lt;p&gt;下面的代码演示了最简单路由定义。Express将这些路径转换成正则表达式，内部用来匹配即将到来的请求。在执行路由匹配时查询字符串不用考虑，例如&quot;GET /&quot;匹配的路由与&quot;GET /?name=tobi&quot;是一致的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;router.get('/', function(req, res){
  res.send('hello world');
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正则表达式也可以使用，当你有非常特殊的限制的时候是很有用的，例如&quot;GET /commits/71dbb9c&quot;能很好的匹配路由&quot;GET /commits/71dbb9c..4c084f9&quot;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;router.get(/^\/commits\/(\w+)(?:\.\.(\w+))?$/, function(req, res){
  var from = req.params[0];
  var to = req.params[1] || 'HEAD';
  res.send('commit range ' + from + '..' + to);
});
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>Express4.x API 翻译[3] -- Response</title>
   <link href="http://www.blogways.net/blog/2014/06/13/node-express4.x-api-3.html"/>
   <updated>2014-06-13T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/06/13/node-express4.x-api-3</id>
   <content type="html">&lt;h2&gt;Express4.x API 翻译[3] -- Response&lt;/h2&gt;

&lt;h3&gt;res.status(code)&lt;/h3&gt;

&lt;p&gt;node &lt;code&gt;res.statusCode=&lt;/code&gt;可链接的别名&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.status(404).sendfile('path/to/404.png');
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;res.set(field, [value])&lt;/h3&gt;

&lt;p&gt;设置响应头内字段值，或者通过一个对象一次设置多个字段。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.set('Content-Type', 'text/plain');

res.set({
  'Content-Type': 'text/plain',
  'Content-Length': '123',
  'ETag': '12345'
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;res.header(field, [value])别名。&lt;/p&gt;

&lt;h3&gt;res.get(field)&lt;/h3&gt;

&lt;p&gt;获取响应头内字段值，不区分大小写。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.get('Content-Type');
// =&amp;gt; &quot;text/plain&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;res.cookie(name, value, [options])&lt;/h3&gt;

&lt;p&gt;设置cookie名称和值，可以是字符串或者对象转换成的JSON。路径选项默认为&quot;/&quot;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.cookie('name', 'tobi', { domain: '.example.com', path: '/admin', secure: true });
res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;maxAge选项可以很方便的设置从当前时间开始以毫秒为单位的过期时间。下面的写法等同于上一个例子。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个对象可以通过序列化成JSON传递，它由bodyParser()中间件自动解析。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.cookie('cart', { items: [1,2,3] });
res.cookie('cart', { items: [1,2,3] }, { maxAge: 900000 });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方法也支持签名cookie。添加一个简单的signed选项。res.cookie()将隐藏传递给cookieParser(secret)对值签名。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.cookie('name', 'tobi', { signed: true });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后你可以使用req.signedCookie来访问这个值。&lt;/p&gt;

&lt;h3&gt;res.clearCookie(name, [options])&lt;/h3&gt;

&lt;p&gt;删除cookie里面值。默认路径为&quot;/&quot;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.cookie('name', 'tobi', { path: '/admin' });
res.clearCookie('name', { path: '/admin' });
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;res.redirect([status], url)&lt;/h3&gt;

&lt;p&gt;重定向到给定的url，可选状态编码默认为302&quot;Found&quot;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.redirect('/foo/bar');
res.redirect('http://example.com');
res.redirect(301, 'http://example.com');
res.redirect('../login');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Express支持几种形式的重定向，首先一个完整合格的URI重定向到不同的域名：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.redirect('http://google.com');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二种形式是相对路径的重定向，例如你正在http://example.com/admin/post/new，接着重定向到/admin，你将会登录http://example.com/admin：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.redirect('/admin');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其次相对于应用程序挂载点的相对重定向。例如你有一个博客应用程序挂载在/blog下，理论上来说并不知道它挂载在哪边，因此重定向到/admin/post/new将会跳转到http://example.com/admin/post/new，相对挂载点的重定向将会跳转到http://example.com/blog/admin/post/new：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.redirect('admin/post/new');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然相对路径的重定向也是支持的。如果你在http://example.com/admin/post/new，下面的重定向转跳转到http://example.com/admin/post：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.redirect('..');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后一个特殊情况是back重定向，重定向到Referer(或Refererer)，找不到默认为/。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.redirect('back');
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;res.location&lt;/h3&gt;

&lt;p&gt;设置location头。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.location('/foo/bar');
res.location('foo/bar');
res.location('http://example.com');
res.location('../login');
res.location('back');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以使用res.redirect()相同的urls。&lt;/p&gt;

&lt;p&gt;例如你的应用挂载在/blog下，使用下面的代码设置location头为/blog/admin：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.location('admin')
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;res.send([body|status], [body])&lt;/h3&gt;

&lt;p&gt;发送一个响应。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.send(new Buffer('whoop'));
res.send({ some: 'json' });
res.send('
some html

');
res.send(404, 'Sorry, we cannot find that!');
res.send(500, { error: 'something blew up' });
res.send(200);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此方法适用于执行大量的简单非流式的响应任务，例如在未提前定义和提供自动HEAD和HTTP缓存刷新支持的情况下自动设定Content-Length。
当传入的内容为Buffer，那么Content-Type会被设置为&quot;application/octet-stream&quot;，除非预先定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.set('Content-Type', 'text/html');
res.send(new Buffer('
some html

'));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当发送字符串时Content-Type设置默认为&quot;text/html&quot;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.send('
some html

');
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当发送数组或者对象时Express将会转换成JSON格式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.send({ user: 'tobi' })
res.send([1,2,3])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后如果返回的是一个数字，没有前面提到的任何一个响应体，Express会为你设置一个响应字符串。例如200将会响应文本&quot;OK&quot;，400响应&quot;Not Found&quot;等等。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.send(200)
res.send(404)
res.send(500)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;res.json([status|body], [body])&lt;/h3&gt;

&lt;p&gt;发送一个JSON返回。当返回对象或者数组时该方法与res.send()相同，然而它可以用来将非对象(null, undefined, 等等)转换成精准的JSON，尽管严格来说这些并不是有效的JSON。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.json(null)
res.json({ user: 'tobi' })
res.json(500, { error: 'message' })
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;res.jsonp([status|body], [body])&lt;/h3&gt;

&lt;p&gt;使用JSONP发送JSON响应。该方法与res.json()相同，但多了对JSONP回调的支持。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.jsonp(null)
// =&amp;gt; null

res.jsonp({ user: 'tobi' })
// =&amp;gt; { &quot;user&quot;: &quot;tobi&quot; }

res.jsonp(500, { error: 'message' })
// =&amp;gt; { &quot;error&quot;: &quot;message&quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认JSONP回调函数名是callback，但你可以通过修改jsonp callback name参数重新定义。以下是JSONP响应的一些例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ?callback=foo
res.jsonp({ user: 'tobi' })
// =&amp;gt; foo({ &quot;user&quot;: &quot;tobi&quot; })

app.set('jsonp callback name', 'cb');

// ?cb=foo
res.jsonp(500, { error: 'message' })
// =&amp;gt; foo({ &quot;error&quot;: &quot;message&quot; })
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;res.type(type)&lt;/h3&gt;

&lt;p&gt;设置Content-Type类型为mime的类型，或者当&quot;/&quot;存在时Content-Type被简单的设置成该类型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.type('.html');
res.type('html');
res.type('json');
res.type('application/json');
res.type('png');
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;res.format(object)&lt;/h3&gt;

&lt;p&gt;执行请求时存在请求Accept头上下文转换。该方法使用req.accepted，这是一个按可接受类型重要性排序的数组，否则第一个回调函数被调用。当没有匹配的回调函数执行时服务器返回406 &quot;Not Acceptable&quot;，或者调用默认的回调函数。&lt;/p&gt;

&lt;p&gt;设置Content-Type为你选择一个回调函数，但你可以在回调函数中使用res.set()或者res.type()等修改。&lt;/p&gt;

&lt;p&gt;下例当Accept头字段设置成&quot;application/json&quot;或&quot;&lt;em&gt;/json&quot;时响应{ &quot;message&quot;: &quot;hey&quot; }，但如果设置成&quot;&lt;/em&gt;/*&quot;时将会响应&quot;hey&quot;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.format({
  'text/plain': function(){
    res.send('hey');
  },

  'text/html': function(){
    res.send('
hey

');
  },

  'application/json': function(){
    res.send({ message: 'hey' });
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了规范化的MIME类型你还可以使用扩展名映射这些类型，提供一个稍微不那么详细的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.format({
  text: function(){
    res.send('hey');
  },

  html: function(){
    res.send('
hey

');
  },

  json: function(){
    res.send({ message: 'hey' });
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;res.attachment([filename])&lt;/h3&gt;

&lt;p&gt;设置Content-Disposition头字段为&quot;attachment&quot;。如果给定一个文件名，那么Content-Type将会通过res.type()自动设置成基于扩展名的类型，Content-Disposition的&quot;filename=&quot;参数同时也被设置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.attachment();
// Content-Disposition: attachment

res.attachment('path/to/logo.png');
// Content-Disposition: attachment; filename=&quot;logo.png&quot;
// Content-Type: image/png
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;res.sendfile(path, [options], [fn]])&lt;/h3&gt;

&lt;p&gt;传输文件到给定的路径。&lt;/p&gt;

&lt;p&gt;自动设置默认基于文件扩展名的Content-Type响应头。当传输发生错误时fn(err)回调函数被调用。&lt;/p&gt;

&lt;p&gt;选项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;maxAge 以毫秒为单位默认为0&lt;/li&gt;
&lt;li&gt;root 相对文件名根目录&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;在下例中该方法为文件服务提供细粒度支持：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.get('/user/:uid/photos/:file', function(req, res){
  var uid = req.params.uid
    , file = req.params.file;

  req.user.mayViewFilesFrom(uid, function(yes){
    if (yes) {
      res.sendfile('/uploads/' + uid + '/' + file);
    } else {
      res.send(403, 'Sorry! you cant see that.');
    }
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如有任何问题或者疑问请参阅send附加文档。&lt;/p&gt;

&lt;h3&gt;res.download(path, [filename], [fn])&lt;/h3&gt;

&lt;p&gt;传输路径中的文件作为附件，通常浏览器会提醒用户下载。Content-Disposition &quot;filename=&quot;参数，也就是显示在浏览器对话框的默认文件名，你也可以提供一个自定义文件名。&lt;/p&gt;

&lt;p&gt;当传输完成或者中途发生错误时将会调用fn回调函数，该方法使用res.sendfile()来传输文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.download('/report-12345.pdf');

res.download('/report-12345.pdf', 'report.pdf');

res.download('/report-12345.pdf', 'report.pdf', function(err){
  if (err) {
    // handle error, keep in mind the response may be partially-sent
    // so check res.headersSent
  } else {
    // decrement a download credit etc
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;res.links(links)&lt;/h3&gt;

&lt;p&gt;加入给定的链接来填充&quot;Link&quot;响应头字段。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.links({
  next: 'http://api.example.com/users?page=2',
  last: 'http://api.example.com/users?page=5'
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;处理后：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Link: &amp;lt;http://api.example.com/users?page=2&amp;gt;; rel=&quot;next&quot;, 
      &amp;lt;http://api.example.com/users?page=5&amp;gt;; rel=&quot;last&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;res.locals&lt;/h3&gt;

&lt;p&gt;响应本地化变量作用域为request，因此只适用于在该request/response周期内呈现的视图，如果有的话。其实该API跟app.locals是等同的。&lt;/p&gt;

&lt;p&gt;这个对象适用于的request级别的信息，例如request路径，用户认证，用户设置等。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.use(function(req, res, next){
  res.locals.user = req.user;
  res.locals.authenticated = ! req.user.anonymous;
  next();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;res.render(view, [locals], callback)&lt;/h3&gt;

&lt;p&gt;渲染一个视图，同时向回调函数传递渲染后的字符串。发生错误时内部调用next(err)。回调函数传入可能发生的错误以及渲染后的页面，这样就不会自动执行响应了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;res.render('index', function(err, html){
  // ...
});

res.render('user', { name: 'Tobi' }, function(err, html){
  // ...
});
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>Express4.x API 翻译[2] -- Request</title>
   <link href="http://www.blogways.net/blog/2014/06/11/node-express4.x-api-2.html"/>
   <updated>2014-06-11T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/06/11/node-express4.x-api-2</id>
   <content type="html">&lt;h2&gt;Express4.x API 翻译[2] -- Request&lt;/h2&gt;

&lt;h3&gt;req.params&lt;/h3&gt;

&lt;p&gt;此属性是一个包含映射路由&quot;parameters&quot;的对象。例如你使用/user/:name路由，那么&quot;name&quot;属性对你来说就是一个req.params.name变量。该对象默认为{}。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// GET /user/tj
req.params.name
// =&amp;gt; &quot;tj&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当在定义路由规则时使用了正则表达式，使用req.params[N]获取所有参数匹配数组，其中N表示数组的第几个。此规则适用于包含未定义的通配符的路由字符串，例如&lt;code&gt;/file/*&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// GET /file/javascripts/jquery.js
req.params[0]
// =&amp;gt; &quot;javascripts/jquery.js&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;req.query&lt;/h3&gt;

&lt;p&gt;此属性是一个包含解析查询字符串的对象，默认为{}。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// GET /search?q=tobi+ferret
req.query.q
// =&amp;gt; &quot;tobi ferret&quot;

// GET /shoes?order=desc&amp;amp;shoe[color]=blue&amp;amp;shoe[type]=converse
req.query.order
// =&amp;gt; &quot;desc&quot;

req.query.shoe.color
// =&amp;gt; &quot;blue&quot;

req.query.shoe.type
// =&amp;gt; &quot;converse&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;req.param(name)&lt;/h3&gt;

&lt;p&gt;返回当前name参数的值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ?name=tobi
req.param('name')
// =&amp;gt; &quot;tobi&quot;

// POST name=tobi
req.param('name')
// =&amp;gt; &quot;tobi&quot;

// /user/tobi for /user/:name 
req.param('name')
// =&amp;gt; &quot;tobi&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查找优先级如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;req.params&lt;/li&gt;
&lt;li&gt;req.body&lt;/li&gt;
&lt;li&gt;req.query&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;直接使用req.body，req.params，和req.query应该更新清晰，除非你确实需要接收每个对象的输入。&lt;/p&gt;

&lt;h3&gt;req.route&lt;/h3&gt;

&lt;p&gt;当前匹配的路由包含多个属性，如路由的原始路径字符串以及转换后的正则表达式等。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.get('/user/:id?', function(req, res){
  console.log(req.route);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ path: '/user/:id?',
  keys: [ { name: 'id', optional: true } ],
  regexp: /^\/user(?:\/([^\/]+?))?\/?$/i,
  params: [ id: '12' ] }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;req.cookies&lt;/h3&gt;

&lt;p&gt;当cookieParser()中间件使用时该对象默认为{}，除此之外还包含由用户代理发送的cookies。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Cookie: name=tj
req.cookies.name
// =&amp;gt; &quot;tj&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如有任何问题或者疑问请参阅cookie-parser附加文档。&lt;/p&gt;

&lt;h3&gt;req.signedCookies&lt;/h3&gt;

&lt;p&gt;当cookieParser(secret)中间件使用该对象默认为{}，还包括用户代理发送的签名cookies，未签名以及准备使用的。签名cookies存放于一个单独的对象，以显示开发者的意图，否则可以通过在req.cookie设置值发起恶意攻击，从而很轻易的欺骗。需要注意的是签名的cookie并不意味着它是隐藏的或者是加密的，这个防止篡改的秘密只是简单的将签名私有化。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Cookie: user=tobi.CP7AWaXDfAKIRfH49dQzKJx7sKzzSoPq7/AcBBRVwlI3
req.signedCookies.user
// =&amp;gt; &quot;tobi&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如有任何问题或者疑问请参阅cookie-parser附加文档。&lt;/p&gt;

&lt;h3&gt;req.get(field)&lt;/h3&gt;

&lt;p&gt;获取请求头内的field字段，不区分大小写。Referrer和Referer字段可以互换。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;req.get('Content-Type');
// =&amp;gt; &quot;text/plain&quot;

req.get('content-type');
// =&amp;gt; &quot;text/plain&quot;

req.get('Something');
// =&amp;gt; undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;别名为req.header(field)。&lt;/p&gt;

&lt;h3&gt;req.accepts(types)&lt;/h3&gt;

&lt;p&gt;检查给定的types是不是可以接受的，当结果为true时返回最佳匹配，否则返回undefined，在这种情况下你应该返回406&quot;Not Acceptable&quot;。&lt;/p&gt;

&lt;p&gt;type可以是单一的mine类型的字符串，比如&quot;application/json&quot;，扩展名如&quot;json&quot;，也可以是以逗号分隔的列表或者数组。当为列表或数组时将返回最佳匹配。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Accept: text/html
req.accepts('html');
// =&amp;gt; &quot;html&quot;

// Accept: text/*, application/json
req.accepts('html');
// =&amp;gt; &quot;html&quot;
req.accepts('text/html');
// =&amp;gt; &quot;text/html&quot;
req.accepts('json, text');
// =&amp;gt; &quot;json&quot;
req.accepts('application/json');
// =&amp;gt; &quot;application/json&quot;

// Accept: text/*, application/json
req.accepts('image/png');
req.accepts('png');
// =&amp;gt; undefined

// Accept: text/*;q=.5, application/json
req.accepts(['html', 'json']);
req.accepts('html, json');
// =&amp;gt; &quot;json&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如有任何问题或者疑问，请参阅accepts附加文档。&lt;/p&gt;

&lt;h3&gt;req.acceptsCharset(charset)&lt;/h3&gt;

&lt;p&gt;检查给定的字符集是否可以支持。&lt;/p&gt;

&lt;p&gt;如有任何问题或者疑问，请参阅accepts附加文档。&lt;/p&gt;

&lt;h3&gt;req.acceptsLanguage(lang)&lt;/h3&gt;

&lt;p&gt;检查给定的lang是否支持。&lt;/p&gt;

&lt;p&gt;如有任何问题或者疑问，请参阅accepts附加文档。&lt;/p&gt;

&lt;h3&gt;req.is(type)&lt;/h3&gt;

&lt;p&gt;检查传入请求字符串是否包含了&quot;Content-Type&quot;头字段，并且给出匹配的mine类型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// With Content-Type: text/html; charset=utf-8
req.is('html');
req.is('text/html');
req.is('text/*');
// =&amp;gt; true

// When Content-Type is application/json
req.is('json');
req.is('application/json');
req.is('application/*');
// =&amp;gt; true

req.is('html');
// =&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如有任何问题或者疑问，请参阅type-is附加文档。&lt;/p&gt;

&lt;h3&gt;req.ip&lt;/h3&gt;

&lt;p&gt;返回远程地址，或者当信任代理已启用时返回代理地址。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;req.ip
// =&amp;gt; &quot;127.0.0.1&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;req.ips&lt;/h3&gt;

&lt;p&gt;当信任代理为true时，解析&quot;X-Forwarded-For&quot;ip地址列表返回一个数组，否则返回一个空数组。例如当值为&quot;client, proxy1, proxy2&quot;时你会获得[&quot;client&quot;, &quot;proxy1&quot;, &quot;proxy2&quot;]数组，其中&quot;proxy2&quot;是最远的下游地址。&lt;/p&gt;

&lt;h3&gt;req.path&lt;/h3&gt;

&lt;p&gt;返回请求的URL路径名。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// example.com/users?sort=desc
req.path
// =&amp;gt; &quot;/users&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;req.host&lt;/h3&gt;

&lt;p&gt;Returns the hostname from the &quot;Host&quot; header field (void of portno).&lt;/p&gt;

&lt;p&gt;返回从&quot;Host&quot;头字段内取出的主机名(不包含端口)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Host: &quot;example.com:3000&quot;
req.host
// =&amp;gt; &quot;example.com&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;req.fresh&lt;/h3&gt;

&lt;p&gt;检查请求是否刷新，通过对Last-Modified和/或ETag进行匹配，表明资源是不是最新的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;req.fresh
// =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如有任何问题或者疑问，请参阅fresh附加文档。&lt;/p&gt;

&lt;h3&gt;req.stale&lt;/h3&gt;

&lt;p&gt;检查请求是否过期，如果Last-Modified和/或ETag不匹配，表有资源是过期的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;req.stale
// =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;req.xhr&lt;/h3&gt;

&lt;p&gt;检查请求头里是否包含&quot;X-Requested-With&quot;字段并且值为&quot;XMLHttpRequest&quot;(jQuery等)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;req.xhr
// =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;req.protocol&lt;/h3&gt;

&lt;p&gt;当使用TLS请求时返回&quot;http&quot;或&quot;https&quot;协议字符串。当信任路由设置为开启时&quot;X-Forwarded-Proto&quot;头字段将被信任。如果你正在运行一个支持https协议的反向代理，那么这个是支持的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;req.protocol
// =&amp;gt; &quot;http&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;req.secure&lt;/h3&gt;

&lt;p&gt;检查TLS连接是否建立。这是一个简写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;'https' == req.protocol;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;req.subdomains&lt;/h3&gt;

&lt;p&gt;Return subdomains as an array.
返回子域数组。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Host: &quot;tobi.ferrets.example.com&quot;
req.subdomains
// =&amp;gt; [&quot;ferrets&quot;, &quot;tobi&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;req.originalUrl&lt;/h3&gt;

&lt;p&gt;此属性很像req.url，但它保留了原始请求的url，允许你在做内部路由时自由重写req.url。例如app.use()中间件将重写req.url重新定义挂载点。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// GET /search?q=something
req.originalUrl
// =&amp;gt; &quot;/search?q=something&quot;
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>Node Plugin</title>
   <link href="http://www.blogways.net/blog/2014/06/10/node-plugin.html"/>
   <updated>2014-06-10T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/06/10/node-plugin</id>
   <content type="html">&lt;h2&gt;一、非插件化开发在node-express下的实现&lt;/h2&gt;

&lt;p&gt;以下为我们日志分析系统中添加一个查询明细页面要添加的代码：&lt;/p&gt;

&lt;p&gt;1、建立明细页面调转逻辑控制文件detail.js，添加代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exports.qrydetail = function(req, res) {
    res.render('query/detail',{
        layout: false,
        errors: req.flash('error') 
    })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、建立登录页面detail.html；&lt;/p&gt;

&lt;p&gt;3、在路由控制文件routes.js引入detail.js：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var detailModule = require('../app/controllers/detail')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4、在路由控制文件routes.js中添加路由：app.get('/detail.html',       detailModule.qrydetail)；&lt;/p&gt;

&lt;p&gt;访问：http://localhost:3000/detail.html&lt;/p&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;p&gt;1) 每次添加链接都需要修改routes.js，时间久了文件很大不便于维护；&lt;/p&gt;

&lt;p&gt;2) 多人协作routes.js会同时被多人修改；&lt;/p&gt;

&lt;p&gt;3) 无法支持不改动代码多模块的安装卸载&lt;/p&gt;

&lt;h2&gt;二、插件化模块添加&lt;/h2&gt;

&lt;p&gt;1、plugin安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install plugin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、与express集成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var plugin = require('plugin')；
//Plug-in technology    
plugin(app).require(config.root+'/app/controllers/plugin').load();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码含义为：node服务启动时会加载'/app/controllers/plugin'目录下所有js文件作为项目插件（当然文件内容有一定格式）&lt;/p&gt;

&lt;p&gt;3、添加一个查询明细页面&lt;/p&gt;

&lt;p&gt;1) 建立明细查询模块页面detail.js，代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exports.plugin = function(server) {

   server.get('/detail.html', function(req, res) { 
        res.render('query/detail',{
            layout: false,
            errors: req.flash('error') 
        })                    
   });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2) 建立登录页面detail.html；&lt;/p&gt;

&lt;p&gt;访问：http://localhost:3000/detail.html&lt;/p&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;p&gt;a) 无需修改routes.js；&lt;/p&gt;

&lt;p&gt;b) 支持不改动代码多模块的安装卸载(卸载将'/app/controllers/plugin'目录下detail.js文件删除即可)&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>node 日志管理log4js</title>
   <link href="http://www.blogways.net/blog/2014/06/09/node-log4js.html"/>
   <updated>2014-06-09T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/06/09/node-log4js</id>
   <content type="html">&lt;h2&gt;一、默认的控制台输出&lt;/h2&gt;

&lt;p&gt;我们使用express框架时，开发模式用node或者supervisor启动nodejs应用时，控制台都是显示如下的日志。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET /css/bootstrap.min.css 304 1ms
GET /css/my.css 304 0ms
GET /js/bootstrap.min.js 304 4ms
GET /js/jquery-1.9.1.min.js 304 6ms
GET /js/holder.js 304 3ms
GET /cat/json/latest 200 6ms
GET /cat/json/master 200 4ms
GET /cat/json/classic 200 2ms
GET /about 200 6ms
GET /css/bootstrap.min.css 304 2ms
GET /css/my.css 304 2ms
GET /js/bootstrap.min.js 304 2ms
GET /js/jquery-1.9.1.min.js 304 1ms
GET /js/holder.js 304 1ms
GET /js/bootstrap.min.js 304 1ms
GET / 304 6ms
GET /js/jquery-1.9.1.min.js 304 2ms
GET /css/my.css 304 1ms
GET /css/bootstrap.min.css 304 1ms
GET /js/bootstrap.min.js 304 2ms
GET /js/holder.js 304 2ms
GET /cat/json/latest 200 3ms
GET /cat/json/master 200 2ms
GET /cat/json/classic 200 2ms
GET /admin/ 304 13ms
GET /css/bootstrap.min.css 304 3ms
GET /js/jquery-1.9.1.min.js 304 2ms
GET /css/my.css 304 2ms
GET /js/bootstrap.min.js 304 1ms
GET /js/holder.js 304 2ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们也可以在代码中，用console.log()打印一些控制台日志。&lt;/p&gt;

&lt;p&gt;修改routes/index.js&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exports.index = function(req, res){
console.log(&quot;This is an index page!&quot;);
res.render('index', {
        title:'首页|moive.me',
        page:'index'
    });
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;访问页面，结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This is an index page!
GET / 304 19ms
GET /css/bootstrap.min.css 304 4ms
GET /css/my.css 304 2ms
GET /js/jquery-1.9.1.min.js 304 38ms
GET /js/holder.js 304 29ms
GET /js/bootstrap.min.js 304 28ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的输出的结果，都是在控制台显示，一旦server重启日志就丢失了。对于程序开发来说，这样的输出已经够用了。但是在生产环境上，我们希望能把控制台的输出，保存到文件中，而且需要更多的信息，不仅仅是默认的简化的日志信息。&lt;/p&gt;

&lt;p&gt;由于express框架没有日志功能，我们需要引入log4js包来完成这个功能。&lt;/p&gt;

&lt;h2&gt;二、配置log4js与express框架集成&lt;/h2&gt;

&lt;p&gt;1、安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install log4js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、修改项目入口配置文件，如日志分析项目express.js&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var log4js = require('log4js');
log4js.configure({
  appenders: [
    { type: 'console' }, //控制台输出
    {
      type: 'file', //文件输出
      filename: 'logs/log.log', 
      maxLogSize: 1024,
      backups:3,
      category: 'normal' 
    }
  ]
});
var logger = log4js.getLogger('normal');
logger.setLevel('INFO');
...

app.use(log4js.connectLogger(logger, {level:log4js.levels.INFO}));
app.use(app.router);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要在express.js中进行log4js的配置。
appenders中配置了两个输出，一个是控制台输出，一个是文件输出。&lt;/p&gt;

&lt;p&gt;appenders.type=file的对象,指定文件输出位置及文件大小，当超过maxLogSize大小时，会自动生成一个新文件。logs的文件目录要动手创建。
level:log4js.levels.INFO, 设置默认日志输出级别是INFO。&lt;/p&gt;

&lt;p&gt;log4js的输出级别6个: trace, debug, info, warn, error, fatal
logger.trace(‘Entering cheese testing’);
logger.debug(‘Got cheese.’);
logger.info(‘Cheese is Gouda.’);
logger.warn(‘Cheese is quite smelly.’);
logger.error(‘Cheese is too ripe!’);
logger.fatal(‘Cheese was breeding ground for listeria.’);&lt;/p&gt;

&lt;p&gt;如果输出级别是INFO，则不会打印出低于info级别的日志trace,debug，只打印info,warn,error,fatal。这样做的好处在于，在生产环境中我们可能只关心异常和错误，并不关心调试信息。从而大大减少日志的输出，能减少磁盘写入。而在开发环境中，我们可以需要打印非常多的信息，帮助开发人员定位错误，调试代码。&lt;/p&gt;

&lt;p&gt;还有一个好处就是，代码中可以混有各种的日志打印代码。我们只要在一个配置文件中，修改输出级别，日志输出就会发生变化，不用修改所有的代码。如果所有地方都是console.log()，那么上线的时候，改动这个东西就要花很多时间。&lt;/p&gt;

&lt;h2&gt;三、根据项目配置log4js&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;增加replaceConsole代替console.log()&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; var log4js = require('log4js');
 log4js.configure({
   appenders: [
     { type: 'console' },{
       type: 'file', 
       filename: 'logs/log.log', 
       maxLogSize: 1024,
       backups:4,
       category: 'normal' 
     }
   ],
   replaceConsole: true
 });
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;调整日志输出的格式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; app.use(log4js.connectLogger(logger, {level: 
 level:log4js.levels.INFO, format:':method :url'}));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自动调整日志输出级别&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 日志级别对应规则：
 http responses 3xx, level = WARN
 http responses 4xx &amp;amp; 5xx, level = ERROR
 else, level = INFO  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置level为auto:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  app.use(log4js.connectLogger(logger, {level: 'auto', format:':method :url'}));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;四、调整log4js结构&lt;/h2&gt;

&lt;p&gt;我们在配置log4js时会有一个问题。就是以上所有配置信息都是在express.js中做的，logger也是在这里直接定义的。如果在控制器(routes)想用log4js进行输出，我们现在拿不到logger的句柄。&lt;/p&gt;

&lt;p&gt;新建立log.js&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var log4js = require('log4js');

log4js.configure({

    appenders: [
        {
            type: 'console',
            category: &quot;console&quot;

        }, //控制台输出
        {
            type: &quot;file&quot;,
            filename: 'logs/log.log',
            pattern: &quot;_yyyy-MM-dd&quot;,
            maxLogSize: 20480,
            backups: 3,
            category: 'dateFileLog'

        }//日期文件格式
    ],
    replaceConsole: true,   //替换console.log
    levels:{
        dateFileLog: 'debug',
        console: 'debug'
    }
});


var dateFileLog = log4js.getLogger('dateFileLog');
var consoleLog = log4js.getLogger('console');
exports.logger = consoleLog;


exports.use = function(app) {
    app.use(log4js.connectLogger(consoleLog, {level:'INFO', format:':method :url'}));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们把logger单独定义出来，并且做为API暴露出来，此处是开发调试，没有使用文件输出。
这样在其他模块中使用logger输出日志只需如下操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var logger = require('../../log').logger;
logger.debug(&quot;collectTime=%s&quot;,collectTime);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就已经玩转log4js了，如果部署生产需要文件输出只要修改log.js中dateFileLog级别，然后设置exports.logger=dateFileLog即可。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Express4.x API 翻译[1] -- Application</title>
   <link href="http://www.blogways.net/blog/2014/06/09/node-express4.x-api-1.html"/>
   <updated>2014-06-09T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/06/09/node-express4.x-api-1</id>
   <content type="html">&lt;h2&gt;Express4.x API 翻译[1] -- Application&lt;/h2&gt;

&lt;p&gt;之前参与过一个node的项目，使用express框架，感觉这种异步IO以及事件驱动的架构设计用在一些高并发的场景还是大有可为的，决定深入学习一下。刚开始写几个例子就发现问题了，以前用的是3.5的版本，可以很好的集成在webstorm工具里面使用，到4.x版本的时候就一堆问题，工具已经无法创建新的项目，单独用命令生成，发现启动方法也跟以前不一样，4.x是用npm去启动bin下面的www文件，一些以前的写法现在也用不了，本想回到之前的版本，但看4.x的版本更新很快，应该也是以后的趋势，而且专注高性能，有必要直接学习之。从哪下手比较好呢，网上4.x的例子跟文档都很少，索性还是从API看起吧，刚好英文比较差，算是一起学了。&lt;/p&gt;

&lt;h3&gt;express()&lt;/h3&gt;

&lt;p&gt;创建一个 express 应用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var express = require('express');
var app = express();

app.get('/', function(req, res){
  res.send('hello world');
});

app.listen(3000);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Application&lt;/h2&gt;

&lt;h3&gt;settings&lt;/h3&gt;

&lt;p&gt;提供以下设置用来改变Express行为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;env&lt;/code&gt; 环境模式，默认为process.env.NODE_ENV (NODE_ENV 环境变量) 或者 &quot;development&quot;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trust proxy&lt;/code&gt; 启用反向代理，默认disabled&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jsonp callback name&lt;/code&gt; 通过 ?callback= 更新默认回调函数的名称&lt;/li&gt;
&lt;li&gt;&lt;code&gt;json replacer&lt;/code&gt; JSON replacer callback，默认为null&lt;/li&gt;
&lt;li&gt;&lt;code&gt;case sensitive routing&lt;/code&gt; 路由启用区分大小写，默认为disabled，&quot;/Foo&quot;和&quot;/foo&quot;默认是同一个地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strict routing&lt;/code&gt; 启用严谨路由，默认情况下&quot;/foo&quot;和&quot;/foo/&quot;被解析成同一个路由&lt;/li&gt;
&lt;li&gt;&lt;code&gt;view cache&lt;/code&gt; 启用视图模板编译缓存，产品模式下默认enabled&lt;/li&gt;
&lt;li&gt;&lt;code&gt;view engine&lt;/code&gt; 缺省状态下默认模板引擎&lt;/li&gt;
&lt;li&gt;&lt;code&gt;views&lt;/code&gt; 视图目录路径，默认&quot;process.cwd()+'/views'&quot;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x-powered-by&lt;/code&gt; 启用X-Powered-By: Express HTTP header，默认enabled&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;app.set(name, value)&lt;/h3&gt;

&lt;p&gt;设置指定name的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.set('title', 'My Site');
app.get('title');
// =&amp;gt; &quot;My Site&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;app.get(name)&lt;/h3&gt;

&lt;p&gt;获取对应name的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.get('title');
// =&amp;gt; undefined

app.set('title', 'My Site');
app.get('title');
// =&amp;gt; &quot;My Site&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;app.enable(name)&lt;/h3&gt;

&lt;p&gt;设置name值为true&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.enable('trust proxy');
app.get('trust proxy');
// =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;app.disable(name)&lt;/h3&gt;

&lt;p&gt;设置name值为false&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.disable('trust proxy');
app.get('trust proxy');
// =&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;app.enabled(name)&lt;/h3&gt;

&lt;p&gt;检查name对应的值是否为true&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.enabled('trust proxy');
// =&amp;gt; false

app.enable('trust proxy');
app.enabled('trust proxy');
// =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;app.disabled(name)&lt;/h3&gt;

&lt;p&gt;检查name对应的值是否为false&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.disabled('trust proxy');
// =&amp;gt; true

app.enable('trust proxy');
app.disabled('trust proxy');
// =&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;app.use([path], function)&lt;/h3&gt;

&lt;p&gt;使用给定的中间件function，可选择挂载path，默认&quot;/&quot;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var express = require('express');
var app = express();

// simple logger
app.use(function(req, res, next){
  console.log('%s %s', req.method, req.url);
  next();
});

// respond
app.use(function(req, res, next){
  res.send('Hello World');
});

app.listen(3000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;挂载路径被剥离出来，对于中间件函数来说是不可见的。这么设计是为了让中间件在不用修改任何代码的情况下就可以在任意前缀的路径下执行。&lt;/p&gt;

&lt;p&gt;这里有一个具体的例子，通过express.static()方法使用./public来管理文件服务用例的中间件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// GET /javascripts/jquery.js
// GET /style.css
// GET /favicon.ico
app.use(express.static(__dirname + '/public'));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如你想为自有的静态文件增加前缀'/static'，你可以使用'mounting'功能。挂载的中间件函数不会被调用，除非req.url包含这个前缀，当函数被调用时，前缀是被剥离出去的。当然这只会影响到这个函数，挂载好后随后的中间件还是会通过包含&lt;code&gt;/static&lt;/code&gt;的&lt;code&gt;req.url&lt;/code&gt;查看到。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// GET /static/javascripts/jquery.js
// GET /static/style.css
// GET /static/favicon.ico
app.use('/static', express.static(__dirname + '/public'));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中间件使用app.use()定义的顺序是非常重要的，它们依次被调用，因此这个决定了中间件的优先级。例如，一般来说日志中间件是你要用到的第一个中间件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var logger = require('morgan');

app.use(logger());
app.use(express.static(__dirname + '/public'));
app.use(function(req, res){
  res.send('Hello');
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在假设你想忽略静态文件的请求日志，但又想在logger()定义之后继续使用日志路由，你只需要将static()移动前面就可以了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.use(express.static(__dirname + '/public'));
app.use(logger());
app.use(function(req, res){
  res.send('Hello');
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一个具体的例子是从众多的目录文件服务中，给予&quot;./public&quot;最高的优先级：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.use(express.static(__dirname + '/public'));
app.use(express.static(__dirname + '/files'));
app.use(express.static(__dirname + '/uploads'));
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;app.engine(ext, callback)&lt;/h3&gt;

&lt;p&gt;注册给定的模板引擎的callback默认用来处理扩展名为ext的文件。例如，如果你试图渲染一个&quot;foo.jade&quot;文件，Express将在内部调用以下代码，并缓存require()给后续调用以提高性能。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.engine('jade', require('jade').__express);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引擎没有提供._express渲染方法，或者你想映射一个不一样的扩展名在模板引擎上，你可以用这个方法。例如映射EJS模板引擎来渲染&quot;.html&quot;文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.engine('html', require('ejs').renderFile);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这种情况下，EJS提供.renderFile()方法使用Express定义的参数：(path, options, callback)，但要注意这个方法是在内部给ejs._express取一个别名，如果你使用&quot;.ejs&quot;可以什么都不要做。&lt;/p&gt;

&lt;p&gt;有些模板引擎并不遵循这一规则，consolidate.js库的建立是为了映射所有的node流行模板引擎遵循这一规则，从而使得他们在Express内无缝工作。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var engines = require('consolidate');
app.engine('haml', engines.haml);
app.engine('html', engines.hogan);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;app.param([name], callback)&lt;/h3&gt;

&lt;p&gt;映射路由参数规则。例如当:user存在于一个路由路径中，你需要自动提供req.user给路由映射启动逻辑，或者执行输入参数验证。&lt;/p&gt;

&lt;p&gt;下面的代码说明了如果callback很像中间件，从而支持异常操作，但却增加了一个参数，这里命名为id。然后尝试执行加载用户信息，赋值给req.user，否则传递一个错误到next(err)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.param('user', function(req, res, next, id){
  User.find(id, function(err, user){
    if (err) {
      next(err);
    } else if (user) {
      req.user = user;
      next();
    } else {
      next(new Error('failed to load user'));
    }
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，你可能只传递一个回调函数，在这种情况下你有机会改变app.param()API。例如express-params定义了下面的回调函数，它允许你使用给定的正则表达式限制参数。&lt;/p&gt;

&lt;p&gt;这个例子有点更先进，检查当第二个参数是正则表达式，返回回调函数很像&quot;user&quot;参数例子。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.param(function(name, fn){
  if (fn instanceof RegExp) {
    return function(req, res, next, val){
      var captures;
      if (captures = fn.exec(String(val))) {
        req.params[name] = captures;
        next();
      } else {
        next('route');
      }
    }
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该方法可以被用来有效的验证参数，或者解析提供匹配分组：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.param('id', /^\d+$/);

app.get('/user/:id', function(req, res){
  res.send('user ' + req.params.id);
});

app.param('range', /^(\w+)\.\.(\w+)?$/);

app.get('/range/:range', function(req, res){
  var range = req.params.range;
  res.send('from ' + range[1] + ' to ' + range[2]);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;app.VERB(path, [callback...], callback)&lt;/h3&gt;

&lt;p&gt;Express中App.WEB()方法提供了路由功能，其中VERB是一个HTTP动作，跟app.post()类似。可提供多个回调函数，都是一视同仁，表现跟中间件一样，唯一不一样的是通过调用next(‘route’)来继续其余的路由回调。这个机制可以用来执行路由的前提条件，然后将控制权传递给随后的路由，没有理由进行路由的匹配。&lt;/p&gt;

&lt;p&gt;下面的代码说明了多个简单路由定义的可行性。Express将路径字符串转换成正由表达式，用来在内部匹配到来的请求。在执行这些匹配时查询字符串不考虑，例如&quot;GET /&quot;将匹配以下的路由，如&quot;GET /?name=tobi&quot;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.get('/', function(req, res){
  res.send('hello world');
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正由表达式也可以使用，如果你有非常特殊的限制可能是有用的，例如下面的&quot;GET /commits/71dbb9c&quot;表达式将很好的匹配&quot;GET /commits/71dbb9c..4c084f9&quot;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.get(/^\/commits\/(\w+)(?:\.\.(\w+))?$/, function(req, res){
  var from = req.params[0];
  var to = req.params[1] || 'HEAD';
  res.send('commit range ' + from + '..' + to);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以传递一些回调函数，对于利用中间件加载资源、执行验证等很有用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.get('/user/:id', user.load, function(){
  // ... 
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你有多个共同的中间件路由，可以使用路由api的all。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var middleware = [loadForum, loadThread];

app.route('/forum/:fid/thread/:tid')
.all(loadForum)
.all(loadThread)
.get(function() { //... });
.post(function() { //... });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;两个中间件将用来处理GET和POST请求。&lt;/p&gt;

&lt;h3&gt;app.all(path, [callback...], callback)&lt;/h3&gt;

&lt;p&gt;此方法功能就像app.VERB()方法，但它匹配所有HTTP的动作。
该方法用于映射具体的路径前缀的&quot;global&quot;逻辑或者任意匹配非常有用。例如如果你将下面的路由放在其他路由前面定义，这将导致从这个规则起所有的请求都需要身份验证，并自动加载一个用户。请记住这些回调函数不应该被当作终点，loadUser可以当作一个任务，然后调用next()继续匹配随后的路由。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.all('*', requireAuthentication, loadUser);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等价于：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.all('*', requireAuthentication)
app.all('*', loadUser);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一个很好的例子是白名单&quot;global&quot;功能。下面的例子跟之前很像，但只限制&quot;/api&quot;为前缀的路径：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.all('/api/*', requireAuthentication);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;app.route(path)&lt;/h3&gt;

&lt;p&gt;返回一个路由的实例用来处理可选的中间件HTTP动作。推荐使用app.route()方法用来避免路由重复命名以及由此导致的错误。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var app = express();

app.route('/events')
.all(function(req, res, next) {
  // runs for all HTTP verbs first
  // think of it as route specific middleware!
})
.get(function(req, res, next) {
  res.json(...);
})
.post(function(req, res, next) {
  // maybe add a new event...
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;app.locals&lt;/h3&gt;

&lt;p&gt;应用本地变量提供给所有在这个应用程序内渲染的模板。这是一个非常有用的模板函数，就像应用程序级别数据一样。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.locals.title = 'My App';
app.locals.strftime = require('strftime');
app.locals.email = 'me@myapp.com';
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该app.locals对象是JavaScript对象。添加在它上面的属性被当成应用程序内部的本地变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.locals.title
// =&amp;gt; 'My App'

app.locals.email
// =&amp;gt; 'me@myapp.com'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认情况下Express只有一个应用程序级别的局部变量，那就是settings。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.set('title', 'My App');
// use settings.title in a view
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;app.render(view, [options], callback)&lt;/h3&gt;

&lt;p&gt;使用回调函数返回的渲染字符串渲染视图。这是res.render()的应用程序级别的版本，它们的行为是一样的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.render('email', function(err, html){
  // ...
});

app.render('email', { name: 'Tobi' }, function(err, html){
  // ...
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;app.listen()&lt;/h3&gt;

&lt;p&gt;绑定并监听给定主机和端口的连接，该方法和node的http.Server#listener()方法是一致的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var express = require('express');
var app = express();
app.listen(3000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;express()返回的app实际上是一个JavaScript函数，目的是传递给node的http服务器作为回调处理请求。这使得你可以轻松的为你的应用程序提供HTTP和HTTPS版本相同的代码库，app并不从HTTP或者HTTPS继承，就是一个简单的回调函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var express = require('express');
var https = require('https');
var http = require('http');
var app = express();

http.createServer(app).listen(80);
https.createServer(options, app).listen(443);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该app.listen()方法定义成一个简单方便的方法，如果你想使用HTTPS或者同时使用，使用上面的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.listen = function(){
  var server = http.createServer(this);
  return server.listen.apply(server, arguments);
};
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>node Express 框架搭建</title>
   <link href="http://www.blogways.net/blog/2014/06/06/node-express.html"/>
   <updated>2014-06-06T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/06/06/node-express</id>
   <content type="html">&lt;h2&gt;一、Express安装&lt;/h2&gt;

&lt;p&gt;Express是一个node.js模块，采用npm全局模块。&lt;/p&gt;

&lt;p&gt;npm install -g express&lt;/p&gt;

&lt;h3&gt;二、新建项目&lt;/h3&gt;

&lt;p&gt;创建一个项目express testExpress,会自动生成目录。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   create : testExpress
   create : testExpress/package.json
   create : testExpress/app.js
   create : testExpress/public
   create : testExpress/public/images
   create : testExpress/views
   create : testExpress/views/layout.jade
   create : testExpress/views/index.jade
   create : testExpress/routes
   create : testExpress/routes/index.js
   create : testExpress/routes/user.js
   create : testExpress/public/stylesheets
   create : testExpress/public/stylesheets/style.css
   create : testExpress/public/javascripts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行node app.js （运行程序，默认地址是http://localhost:3000）
如果打开页面出错，可能你没有安装jade模块，那就输入npm install jade进行安装，在我们
日志分析系统中没有用jade模板，用的ejs模板。&lt;/p&gt;

&lt;h3&gt;三、express项目目录文件介绍&lt;/h3&gt;

&lt;p&gt;Express目录介绍：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;目录/文件                                     说明

package.json                            npm依赖配置文件， java Maven中的pom.xml文件
app.js                                  项目的入口文件
routes/                                 用于存放路由文件
public/                                 静态文件
javascript/                             js
stylesheets/                            css
images/                                 图片
views/                                  模板文件, express默认采用jade
node_modules/                           存放npm安装到本地依赖包，依赖包在package.json文件
                                        中声明，使用npm install指令安装
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;申明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;以上目录文件介绍仅对于express框架自动生成目录，框架没有除了package.json文件和 node_modules目录，
没有限定其他文件名称和目录结构，大家在实际开发中可以根据项目需要重新定义目录结构。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;四、运行原理&lt;/h3&gt;

&lt;p&gt;4.1　底层：http模块&lt;/p&gt;

&lt;p&gt;Express框架建立在node.js内置的http模块上。http模块生成服务器的原始代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var http = require(&quot;http&quot;);

var app = http.createServer(function(request, response) {
  response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
  response.end(&quot;Hello world!\n&quot;);
});

app.listen(3000, &quot;localhost&quot;);
console.log(&quot;Server running at http://localhost:3000/&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码的关键是http模块的createServer方法，表示生成一个HTTP服务器实例。该方法接受一个回调函数，该回调函数的参数，分别为代表HTTP请求和HTTP回应的request对象和response对象。&lt;/p&gt;

&lt;p&gt;4.2　对http模块的再包装&lt;/p&gt;

&lt;p&gt;Express框架的核心是对http模块的再包装。上面的代码用Express改写如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var express = require(&quot;express&quot;);
var http = require(&quot;http&quot;);

var app = express();

app.use(function(request, response) {
  response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });
  response.end(&quot;Hello world!\n&quot;);
});

http.createServer(app).listen(3000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比较两段代码，可以看到它们非常接近，唯一的差别是createServer方法的参数，从一个回调函数变成了一个Epress对象的实例。而这个实例使用了use方法，加载了与上一段代码相同的回调函数。&lt;/p&gt;

&lt;p&gt;Express框架等于在http模块之上，加了一个中间层，而use方法则相当于调用中间件。&lt;/p&gt;

&lt;p&gt;4.3　中间件&lt;/p&gt;

&lt;p&gt;简单说，中间件（middleware）就是处理HTTP请求的函数，用来完成各种特定的任务，比如检查用户是否登录、分析数据、以及其他在需要最终将数据发送给用户之前完成的任务。它最大的特点就是，一个中间件处理完，再传递给下一个中间件。&lt;/p&gt;

&lt;p&gt;node.js的内置模块http的createServer方法，可以生成一个服务器实例，该实例允许在运行过程中，调用一系列函数（也就是中间件）。当一个HTTP请求进入服务器，服务器实例会调用第一个中间件，完成后根据设置，决定是否再调用下一个中间件。中间件内部可以使用服务器实例的response对象（ServerResponse，即回调函数的第二个参数），以及一个next回调函数（即第三个参数）。每个中间件都可以对HTTP请求（request对象）做出回应，并且决定是否调用next方法，将request对象再传给下一个中间件。&lt;/p&gt;

&lt;p&gt;一个不进行任何操作、只传递request对象的中间件，大概是下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function uselessMiddleware(req, res, next) { 
    next();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码的next为中间件的回调函数。如果它带有参数，则代表抛出一个错误，参数为错误文本。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function uselessMiddleware(req, res, next) { 
    next('出错了！');
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;抛出错误以后，后面的中间件将不再执行，直到发现一个错误处理函数为止。&lt;/p&gt;

&lt;p&gt;4.4　use方法&lt;/p&gt;

&lt;p&gt;use是express调用中间件的方法，它返回一个函数。下面是一个连续调用两个中间件的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var express = require(&quot;express&quot;);
var http = require(&quot;http&quot;);

var app = express();

app.use(function(request, response, next) {
  console.log(&quot;In comes a &quot; + request.method + &quot; to &quot; + request.url);
  next();
});

app.use(function(request, response) {
  response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });
  response.end(&quot;Hello world!\n&quot;);
});

http.createServer(app).listen(3000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码先调用第一个中间件，在控制台输出一行信息，然后通过next方法，调用第二个中间件，输出HTTP回应。由于第二个中间件没有调用next方法，所以不再request对象就不再向后传递了。&lt;/p&gt;

&lt;p&gt;使用use方法，可以根据请求的网址，返回不同的网页内容。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var express = require(&quot;express&quot;);
var http = require(&quot;http&quot;);

var app = express();

app.use(function(request, response, next) {
  if (request.url == &quot;/&quot;) {
    response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });
    response.end(&quot;Welcome to the homepage!\n&quot;);
  } else {
    next();
  }
});

app.use(function(request, response, next) {
  if (request.url == &quot;/about&quot;) {
    response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });
  } else {
    next();
  }
});

app.use(function(request, response) {
  response.writeHead(404, { &quot;Content-Type&quot;: &quot;text/plain&quot; });
  response.end(&quot;404 error!\n&quot;);
});

http.createServer(app).listen(3000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码通过request.url属性，判断请求的网址，从而返回不同的内容。&lt;/p&gt;

&lt;p&gt;除了在回调函数内部，判断请求的网址，Express也允许将请求的网址写在use方法的第一个参数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.use('/', someMiddleware);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码表示，只对根目录的请求，调用某个中间件。&lt;/p&gt;

&lt;h3&gt;五、Express的方法&lt;/h3&gt;

&lt;p&gt;5.1　all方法和HTTP动词方法&lt;/p&gt;

&lt;p&gt;针对不同的请求，Express提供了use方法的一些别名。比如，上面代码也可以用别名的形式来写。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var express = require(&quot;express&quot;);
var http = require(&quot;http&quot;);
var app = express();

app.all(&quot;*&quot;, function(request, response, next) {
  response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });
  next();
});

app.get(&quot;/&quot;, function(request, response) {
  response.end(&quot;Welcome to the homepage!&quot;);
});

app.get(&quot;/about&quot;, function(request, response) {
  response.end(&quot;Welcome to the about page!&quot;);
});

app.get(&quot;*&quot;, function(request, response) {
  response.end(&quot;404!&quot;);
});

http.createServer(app).listen(3000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码的all方法表示，所有请求都必须通过该中间件，参数中的“*”表示对所有路径有效。get方法则是只有GET动词的HTTP请求通过该中间件，它的第一个参数是请求的路径。由于get方法的回调函数没有调用next方法，所以只要有一个中间件被调用了，后面的中间件就不会再被调用了。&lt;/p&gt;

&lt;p&gt;除了get方法以外，Express还提供post、put、delete方法，即HTTP动词都是Express的方法。&lt;/p&gt;

&lt;p&gt;这些方法的第一个参数，都是请求的路径。除了绝对匹配以外，Express允许模式匹配：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.get(&quot;/hello/:who&quot;, function(req, res) {
  res.end(&quot;Hello, &quot; + req.params.who + &quot;.&quot;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码将匹配“/hello/alice”网址，网址中的alice将被捕获，作为req.params.who属性的值。需要注意的是，捕获后需要对网址进行检查，过滤不安全字符，上面的写法只是为了演示，生产中不应这样直接使用用户提供的值。&lt;/p&gt;

&lt;p&gt;如果在模式参数后面加上问号，表示该参数可选：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.get('/hello/:who?',function(req,res) {
if(req.params.id) {
    res.end(&quot;Hello, &quot; + req.params.who + &quot;.&quot;);
}
else {
    res.send(&quot;Hello, Guest.&quot;);
}
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.2　set方法&lt;/p&gt;

&lt;p&gt;set方法用于指定变量的值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.set(&quot;views&quot;, __dirname + &quot;/views&quot;);
app.set(&quot;view engine&quot;, &quot;jade&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码使用set方法，为系统变量“views”和“view engine”指定值。&lt;/p&gt;

&lt;p&gt;5.3　response对象&lt;/p&gt;

&lt;p&gt;（1）response.redirect方法&lt;/p&gt;

&lt;p&gt;response.redirect方法允许网址的重定向。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;response.redirect(&quot;/hello/anime&quot;);
response.redirect(&quot;http://www.example.com&quot;);
response.redirect(301, &quot;http://www.example.com&quot;); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（2）response.sendFile方法&lt;/p&gt;

&lt;p&gt;response.sendFile方法用于发送文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;response.sendFile(&quot;/path/to/anime.mp4&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（3）response.render方法&lt;/p&gt;

&lt;p&gt;response.render方法用于渲染网页模板。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app.get(&quot;/&quot;, function(request, response) {
  response.render(&quot;index&quot;, { message: &quot;Hello World&quot; });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码使用render方法，将message变量传入index模板，渲染成HTML网页。&lt;/p&gt;

&lt;p&gt;5.4　requst对象&lt;/p&gt;

&lt;p&gt;（1）request.ip&lt;/p&gt;

&lt;p&gt;request.ip属性用于获得HTTP请求的IP地址。&lt;/p&gt;

&lt;p&gt;（2）request.files&lt;/p&gt;

&lt;p&gt;request.files用于获取上传的文件。&lt;/p&gt;

&lt;h3&gt;六、日志系统部分配置&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// should be placed before express.static
app.use(express.compress({
  filter: function (req, res) {
    return /json|text|javascript|css/.test(res.getHeader('Content-Type'))
  },
  level: 9
}))

app.use(express.favicon('public/favicon.ico'))
app.use(express.static(config.root + '/public'))

// don't use logger for test env
if (process.env.NODE_ENV !== 'test') {
  app.use(express.logger('dev'))
}

// set views path, template engine and default layout
  app.engine('html', require('ejs').__express)
app.set('views', config.root + '/app/views')
app.set('view engine', 'html')

app.use(partials());
app.use(pjax());


// cookieParser should be above session
app.use(express.cookieParser())


// bodyParser should be above methodOverride
app.use(express.bodyParser())
app.use(express.methodOverride())

//log4js
log.use(app);

 app.use(function(req, res, next){
    res.on('header', function() {
        if (!req.session) return;
        if (req.session.cookie.expires==null) return;
        req.session.cookie.expires = new Date(Date.now() + 1000*60*60*24*14)
    })
    next()
});

// express/mongo session storage
app.use(express.session({
  secret: 'logAnalyse-pangu',
  cookie: { maxAge: 900000 },  //15 minute
  store: new mongoStore({
    url: config.db,
    collection : 'sessions'
  })
}))



// connect flash for flash messages - should be declared after sessions
app.use(flash())

// adds CSRF support
if (process.env.NODE_ENV !== 'test') {
    app.use(express.csrf())
}

app.use(function(req, res, next){
  //if(req.url != &quot;/faye&quot;)
      res.locals.csrf_token = req.csrfToken();
  next()
})


//menu Plug-in technology    
var menus = [];
require('../app/controllers/menu').loadMenu(config.root+'/app/controllers/menu',
function(m){menus = m;});


//Public Response Information 
app.use(function(req, res, next){         
    if (req.session.user){ 
        res.locals.menus = menus;
        res.locals.current_user = req.session.user;
    }else{ 

       if(req.url != &quot;/login.html&quot; &amp;amp;&amp;amp; req.url != &quot;/auth.html&quot; &amp;amp;&amp;amp; req.url != &quot;/logout&quot; 
       &amp;amp;&amp;amp; req.url != &quot;/register&quot; &amp;amp;&amp;amp; req.url != &quot;/registerAction&quot;){
            if (req.url == &quot;/getInbox.html&quot;){
               ContentType = &quot;text/plain&quot;;
               res.StatusCode =500;
               res.write(&quot;会话超时，请重新登录！&quot;);
               res.end();
               return;
            }
            return res.redirect('/login.html')
       }
    }
    return next();   
});


//Plug-in technology    
plugin(app).require(config.root+'/app/controllers/plugin').load();

// routes should be at the last
app.use(app.router)
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>EventProxy在node的应用</title>
   <link href="http://www.blogways.net/blog/2014/06/05/node-eventproxy.html"/>
   <updated>2014-06-05T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/06/05/node-eventproxy</id>
   <content type="html">&lt;h2&gt;一、EventProxy简介&lt;/h2&gt;

&lt;p&gt;EventProxy作者 田永强，新浪微博@朴灵，前端工程师，曾就职于SAP，现就职于淘宝，花名朴灵，致力于NodeJS和Mobile Web App方面的研发工作。EventProxy 仅仅是一个很轻量的工具，但是能够带来一种事件式编程的思维变化。有以下几个特点：&lt;/p&gt;

&lt;p&gt;1.利用事件机制解耦复杂业务逻辑；&lt;/p&gt;

&lt;p&gt;2.移除被广为诟病的深度callback嵌套问题；&lt;/p&gt;

&lt;p&gt;3.将串行等待变成并行等待，提升多异步协作场景下的执行效率；&lt;/p&gt;

&lt;p&gt;4.友好的Error handling；&lt;/p&gt;

&lt;p&gt;5.无平台依赖，适合前后端，能用于浏览器和Node.js；&lt;/p&gt;

&lt;p&gt;6.兼容CMD，AMD以及CommonJS模块环境。&lt;/p&gt;

&lt;h3&gt;二、安装&lt;/h3&gt;

&lt;p&gt;通过NPM安装即可使用：$ npm install eventproxy&lt;/p&gt;

&lt;p&gt;调用:var EventProxy = require('eventproxy');&lt;/p&gt;

&lt;h3&gt;三、使用&lt;/h3&gt;

&lt;p&gt;这里只简单介绍EventProxy在node环境中的应用，至于前端及其他环境使用见：https://github.com/JacksonTian/eventproxy。&lt;/p&gt;

&lt;p&gt;1.过去异步的I/O操作时，很容易会写成回调函数深度嵌套，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var add= function (v1, v2, v3){
   console.log(v1+v2+v3+'');
};

var value1,value2,value3

clinet.get(&quot;key1&quot;, function (err, data) {
    // do something
     value1 = data

    clinet.get(&quot;key2&quot;, function (err, data) {
        // do something
        value2=data
        clinet.get(&quot;key3&quot;, function (err, data) {
            //do something
             value3 = data
            add(value1, value2, value3);
        });

    });

});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.使用EventProxy后可以更多关心业务，去掉深度嵌套，并且在一些情况下显著提高效率&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; var EventProxy = require('./eventproxy');
 var proxy = new EventProxy();
 var add= function (v1, v2, v3){
   console.log(v1+v2+v3+'');
 };

 proxy.assign(&quot;v1&quot;, &quot;v2&quot;, &quot;v3&quot;, add);
 clinet1.get(&quot;key1&quot;, function (err, data) {
    //do something
    proxy.trigger(&quot;v1&quot;, data);

 });

 clinet2.get(&quot;data&quot;, function (err, data) {
    //do something
    proxy.trigger(&quot;v2&quot;, data);

 });

 clinet3.get(&quot;l10n&quot;, function (err, data) {
    //do something
    proxy.trigger(&quot;v3&quot;, data);

 });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.EventProxy在日志分析系统中的应用&lt;/p&gt;

&lt;p&gt;  以下为日志系统中服务启动加载菜单的程序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var fs = require('fs')，
EventProxy = require('eventproxy').EventProxy;


exports.loadMenu = function(dir,cb){

var proxy = new EventProxy();
  proxy.assign('menus', cb);
fs.readdir(dir, function(err, files) {

    var menusTemp = [];
    if(err) {
        throw new Error(err);
    }

    files.forEach(function(filename) {
        if(filename.substring(filename.length-3) == '.js'){
            var filepath = [ dir, filename ].join('/');
            var tmp = require(filepath);
            for (m in tmp){
                menusTemp.push(tmp[m]);
            }
        }
    });  

    proxy.trigger('menus', menusTemp);
 }); 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中loadMenu是在服务启动是被调用，传入的参数为菜单文件路径、回调函数，程序首先通过
proxy.assign('menus', cb);监听menus，在程序读取完菜单文件后调用 proxy.trigger('menus', menusTemp);触发cb回调函数，参数为menusTemp。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Apache Commons 系列简介 之 Lang</title>
   <link href="http://www.blogways.net/blog/2014/03/10/ApacheCommonsLang.html"/>
   <updated>2014-03-10T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/03/10/ApacheCommonsLang</id>
   <content type="html">&lt;h3&gt;一、概述&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Apache Commons Lang&lt;/code&gt;库提供了标准Java库函数里所没有提供的Java核心类的操作方法。&lt;code&gt;Apache Commons Lang&lt;/code&gt;为java.lang API提供了大量的辅助工具，尤其是在String操作方法，基础数值方法，对象引用，并发行，创建及序列化，系统属性方面。&lt;/p&gt;

&lt;p&gt;Lang3.0及其后续版本使用的包名为&lt;code&gt;org.apache.commons.lang3&lt;/code&gt;，而之前的版本为&lt;code&gt;org.apache.commons.lang&lt;/code&gt;，允许其在被使用的同时作为一个较早的版本。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Apache Commons Lang 3.3 API&lt;/code&gt;包列表：&lt;/p&gt;

&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;org.apache.commons.lang3&lt;/li&gt;
&lt;li&gt;org.apache.commons.lang3.builder&lt;/li&gt;
&lt;li&gt;org.apache.commons.lang3.concurrent&lt;/li&gt;
&lt;li&gt;org.apache.commons.lang3.event&lt;/li&gt;
&lt;li&gt;org.apache.commons.lang3.exception&lt;/li&gt;
&lt;li&gt;org.apache.commons.lang3.math&lt;/li&gt;
&lt;li&gt;org.apache.commons.lang3.mutable&lt;/li&gt;
&lt;li&gt;org.apache.commons.lang3.reflect&lt;/li&gt;
&lt;li&gt;org.apache.commons.lang3.text&lt;/li&gt;
&lt;li&gt;org.apache.commons.lang3.text.translate&lt;/li&gt;
&lt;li&gt;org.apache.commons.lang3.time&lt;/li&gt;
&lt;li&gt;org.apache.commons.lang3.tuple&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3&gt;二、下载&lt;/h3&gt;

&lt;p&gt;官方下载页:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://http://commons.apache.org/proper/commons-lang/download_lang.cgi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;源码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;svn checkout http://svn.apache.org/repos/asf/commons/proper/pool/trunk commons-pool2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Maven工程依赖：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;commons-lang3&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.3&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;三、使用说明&lt;/h3&gt;

&lt;h4&gt;3.1 org.apache.commons.lang3&lt;/h4&gt;

&lt;p&gt;此包提供了高度可重用静态的工具方法，主要是对&lt;code&gt;java.lang&lt;/code&gt;类的一些补充。&lt;/p&gt;

&lt;p&gt;由于此包中方法绝大多数都为静态的，因此&lt;strong&gt;不需要创建实例化相应的对象&lt;/strong&gt;，而是通过类名&lt;strong&gt;直接调用&lt;/strong&gt;需要的方法。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ArrayUtils&lt;/code&gt;是一个对数组进行特殊处理的类。当然 &lt;code&gt;jdk&lt;/code&gt;中的&lt;code&gt;Arrays&lt;/code&gt;是有一些功能的，&lt;code&gt;Array&lt;/code&gt;也提供了一些动态访问 &lt;code&gt;java&lt;/code&gt;数组的方法，这里的&lt;code&gt;ArrayUtils&lt;/code&gt;扩展提供了更多的功能。&lt;/p&gt;

&lt;p&gt;下面是&lt;code&gt;indexOf&lt;/code&gt;方法的具体实现，用以从指定的&lt;code&gt;startIndex&lt;/code&gt;开始，从数组&lt;code&gt;array&lt;/code&gt;中返回第一个值为&lt;code&gt;valueToFind&lt;/code&gt;的下标。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static int indexOf(final double[] array, final double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex &amp;lt; 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i &amp;lt; array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在使用此方法的时候&lt;strong&gt;不应该&lt;/strong&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ArrayUtils au = new ArrayUtils();
au.indexOf(array,valueToFind,startIndex);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;正确的使用方式&lt;/strong&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ArrayUtils.indexOf(array,valueToFind,startIndex);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个比较完整的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package wz.lang3.test;

import org.apache.commons.lang3.ArrayUtils;
public class arrayutilstest 
{
    public static void main(String[] args)
    {
        double[] array = {1.23,2.34,3.45,4.56,5.67,6.78,7.89,8.90};

        int result = ArrayUtils.indexOf(array, 5.67, 3);

        System.out.println(result);
    }
} 
//输出结果：4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下是网络实例：
&lt;strong&gt;&lt;a href=&quot;http://www.blogjava.net/sean/archive/2005/07/30/8775.html&quot; title=&quot;ArrayUtils实例&quot;&gt;ArrayUtils实例&lt;/a&gt;&lt;/strong&gt;！
&lt;strong&gt;&lt;a href=&quot;http://www.blogjava.net/sean/archive/2005/07/30/8776.html&quot; title=&quot;StringUtils实例&quot;&gt;StringUtils实例&lt;/a&gt;&lt;/strong&gt;！
其他的一些类的用途：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AnnotationUtils&lt;/code&gt;用于辅助处理注释实例。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CharSetUtils&lt;/code&gt;用于操作字符集实例。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CharUtils&lt;/code&gt;用于操作字符基本类型及字符类对象。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StringUtils&lt;/code&gt;用于实现对字符串的操作，处理null输入。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://commons.apache.org/proper/commons-lang/javadocs/api-release/index.html&quot; title=&quot;Org.apache.commons.lang3类列表&quot;&gt;其他类&lt;/a&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;h4&gt;3.2 org.apache.commons.lang3.builder&lt;/h4&gt;

&lt;p&gt;辅助实现&lt;code&gt;equals(Object)&lt;/code&gt;，&lt;code&gt;toString()&lt;/code&gt;，&lt;code&gt;hashCode()&lt;/code&gt;, 和 &lt;code&gt;compareTo(Object)&lt;/code&gt;方法，
在这个包里面一共有7个类：&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;CompareToBuilder&lt;/code&gt; : 用于辅助实现&lt;code&gt;Comparable.compareTo(Object)&lt;/code&gt;方法；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EqualsBuilder&lt;/code&gt; : 用于辅助实现&lt;code&gt;Object.equals(Object)&lt;/code&gt;方法；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HashCodeBuilder&lt;/code&gt; : 用于辅助实现&lt;code&gt;Object.hashCode()&lt;/code&gt;方法；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ToStringBuilder&lt;/code&gt; : 用于辅助实现&lt;code&gt;Object.toString()&lt;/code&gt;方法；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReflectionToStringBuilder&lt;/code&gt; : 使用反射机制辅助实现&lt;code&gt;Object.toString()&lt;/code&gt;方法；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ToStringStyle&lt;/code&gt; : 辅助&lt;code&gt;ToStringBuilder&lt;/code&gt;控制输出格式；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StandardToStringStyle&lt;/code&gt; : 辅助&lt;code&gt;ToStringBuilder&lt;/code&gt;控制标准格式。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;在我们的日常编码过程当中，经常会使用到比较两个对象是否相等、比较大小、取hash、获取对象信息等。但是在实现这些方法的具体代码当中，稍微有点不注意就会出现一些BUG，而且有些往往还非常难以发现，因此&lt;code&gt;org.apache.commons.lang3.builder&lt;/code&gt;中提供的这些用于辅助实现上述功能的方法就比较好了，有了这些类，就可以更好、更快、更方便的实现上述方法。&lt;/p&gt;

&lt;p&gt;以下例子来自网络：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//利用反射机制的版本自动化实现需要的功能
//比较两个对象
public int compareTo(Object o) {
    return CompareToBuilder.reflectionCompare(this, o);
}
//判断相等
public boolean equals(Object o) {
    return EqualsBuilder.reflectionEquals(this, o);
}
//取hash
public int hashCode() {
    return HashCodeBuilder.reflectionHashCode(this);
}
//获取基本信息
public String toString() {
    return ReflectionToStringBuilder.toString(this);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详细例子&lt;strong&gt;&lt;a href=&quot;http://www.blogjava.net/sean/archive/2005/07/30/8781.html&quot; title=&quot;org.apache.commons.lang.builder&quot;&gt;请参考&lt;/a&gt;&lt;/strong&gt;！&lt;/p&gt;

&lt;h4&gt;3.3 org.apache.commons.lang3.time&lt;/h4&gt;

&lt;p&gt;用于提供操作时间（Date）和日期（Duration）的方法和类，在这个包里面一共有7个类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DateFormatUtils&lt;/code&gt; ： 提供格式化日期和时间的功能及相关常量，&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DateUtils&lt;/code&gt; ： 在Calendar和Date的基础上提供更方便的访问，&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DurationFormatUtils&lt;/code&gt; ： 提供格式化时间跨度的功能及相关常量，&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FastDateFormat&lt;/code&gt; ： 为java.text.SimpleDateFormat提供一个的线程安全的替代类，&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FastDateParser&lt;/code&gt; ： 为java.text.SimpleDateFormat提供一个的线程安全的替代类，&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FastDatePrinter&lt;/code&gt; ： 为java.text.SimpleDateFormat提供一个的线程安全的替代类，&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StopWatch&lt;/code&gt; ： 提供一套方便的计时器的API。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;这些包除了&lt;code&gt;StopWatch&lt;/code&gt;，其他的因为都是不可变的，所以是&lt;strong&gt;线程安全&lt;/strong&gt;的，此包包含了一些操作时间的基础工具。更&lt;code&gt;Apache Commons Lang&lt;/code&gt;中的其他的大部分类一样，此包中的方法基本均为&lt;code&gt;static&lt;/code&gt;方法，应该&lt;strong&gt;直接使用类名调用&lt;/strong&gt;相应的方法予以实现相应的功能。&lt;/p&gt;

&lt;p&gt;以下例子来自网络：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package sean.study.jakarta.commons.lang;
import java.util.Calendar;
import java.util.Date;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.time.*;
public class DateTimeUsage 
{
    public static void main(String[] args) 
    {
        demoDateUtils();
        demoStopWatch();
    }
    public static void demoDateUtils() 
    {

        System.out.println(StringUtils.center(&quot; demoDateUtils &quot;, 30, &quot;=&quot;));
        Date date = new Date();
        String isoDateTime = DateFormatUtils.ISO_DATETIME_FORMAT.format(date);
        String isoTime = DateFormatUtils.ISO_TIME_NO_T_FORMAT.format(date);
        FastDateFormat fdf = FastDateFormat.getInstance(&quot;yyyy-MM&quot;);
        String customDateTime = fdf.format(date);
        System.out.println(&quot;ISO_DATETIME_FORMAT: &quot; + isoDateTime);
        System.out.println(&quot;ISO_TIME_NO_T_FORMAT: &quot; + isoTime);
        System.out.println(&quot;Custom FastDateFormat: &quot; + customDateTime);
        System.out.println(&quot;Default format: &quot; + date);
        System.out.println(&quot;Round HOUR: &quot; + DateUtils.round(date, Calendar.HOUR));
        System.out.println(&quot;Truncate HOUR: &quot; + DateUtils.truncate(date, Calendar.HOUR));
        System.out.println();
    }
    public static void demoStopWatch() 
    {

        System.out.println(StringUtils.center(&quot; demoStopWatch &quot;, 30, &quot;=&quot;));
        StopWatch sw = new StopWatch();
        sw.start();
        operationA();
        sw.stop();
        System.out.println(&quot;operationA used &quot; + sw.getTime() + &quot; milliseconds.&quot;);
        System.out.println();
    }
    public static void operationA() 
    {
        try {
            Thread.sleep(999);
        }
        catch (InterruptedException e) {
            // do nothing
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;======= demoDateUtils ========
ISO_DATETIME_FORMAT: 2005-08-01T12:41:51
ISO_TIME_NO_T_FORMAT: 12:41:51
Custom FastDateFormat: 2005-08
Default format: Mon Aug 01 12:41:51 CST 2005
Round HOUR: Mon Aug 01 13:00:00 CST 2005
Truncate HOUR: Mon Aug 01 12:00:00 CST 2005
======= demoStopWatch ========
operationA used 1000 milliseconds.
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>Apache Commons 系列简介 之 Pool</title>
   <link href="http://www.blogways.net/blog/2014/01/15/apache-commons-pool.html"/>
   <updated>2014-01-15T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/01/15/apache-commons-pool</id>
   <content type="html">&lt;h3&gt;一、概述&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Apache Commons Pool&lt;/code&gt;库提供了一整套用于实现对象池化的API，以及若干种各具特色的对象池实现。2.0版本，并非是对1.x的简单升级，而是一个完全重写的对象池的实现，显著的提升了性能和可伸缩性，并且包含可靠的实例跟踪和池监控。第二版要求JDK1.6+。&lt;/p&gt;

&lt;h3&gt;二、下载&lt;/h3&gt;

&lt;p&gt;官方下载页:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://commons.apache.org/proper/commons-pool/download_pool.cgi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;源码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;svn checkout http://svn.apache.org/repos/asf/commons/proper/pool/trunk commons-pool2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Maven工程依赖&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;commons-pool2&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;三、使用说明&lt;/h3&gt;

&lt;h4&gt;3.1 创建池化对象&lt;/h4&gt;

&lt;p&gt;创建池化对象很简单，只要实现&lt;code&gt;commons-pool&lt;/code&gt;的&lt;code&gt;PooledObjectFactory&lt;/code&gt;工厂接口就行了。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PooledObjectFactory&lt;/code&gt;是一个池化对象工厂接口，定义了生成对象、激活对象、钝化对象、销毁对象的方法，如下：&lt;/p&gt;

&lt;p&gt;```
public interface PooledObjectFactory&lt;T&gt; {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PooledObject&amp;lt;T&amp;gt; makeObject();
void activateObject(PooledObject&amp;lt;T&amp;gt; obj);
void passivateObject(PooledObject&amp;lt;T&amp;gt; obj);
boolean validateObject(PooledObject&amp;lt;T&amp;gt; obj);
void destroyObject(PooledObject&amp;lt;T&amp;gt; obj);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
&lt;code&gt;``
它创建并管理&lt;/code&gt;PooledObject&lt;code&gt;。&lt;/code&gt;PooledObject`包含了池化的对象实例，以及这些实例的池化属性，比如创建时间、最后使用时间等等。&lt;/p&gt;

&lt;p&gt;如果需要使用&lt;code&gt;Commons-Pool&lt;/code&gt;，那么你就需要提供一个&lt;code&gt;PooledObjectFactory&lt;/code&gt;接口的具体实现。一个比较简单的办法就是，继承&lt;code&gt;BasePooledObjectFactory&lt;/code&gt;这个抽象类。而继承这个抽象类，只需要实现两个方法:&lt;code&gt;create()&lt;/code&gt;和&lt;code&gt;wrap(T obj)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;实现&lt;code&gt;create()&lt;/code&gt;方法很简单，而实现&lt;code&gt;wrap(T obj)&lt;/code&gt;也有捷径，可以使用类&lt;code&gt;DefaultPooledObject&lt;/code&gt;，代码可以参考如下：&lt;/p&gt;

&lt;p&gt;```
@Override
public PooledObject&lt;Foo&gt; wrap(Foo foo) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return new DefaultPooledObject&amp;lt;Foo&amp;gt;(foo);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;p&gt;比如，一个完整的例子：&lt;/p&gt;

&lt;p&gt;```
package test.test;&lt;/p&gt;

&lt;p&gt;import org.apache.commons.pool2.BasePooledObjectFactory;
import org.apache.commons.pool2.PooledObject;
import org.apache.commons.pool2.impl.DefaultPooledObject;&lt;/p&gt;

&lt;p&gt;public class StringBufferFactory extends BasePooledObjectFactory&lt;StringBuffer&gt; {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public StringBuffer create() throws Exception {
    return new StringBuffer();
}

@Override
public PooledObject&amp;lt;StringBuffer&amp;gt; wrap(StringBuffer obj) {
    return new DefaultPooledObject&amp;lt;StringBuffer&amp;gt;(obj);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;p&gt;有时候，单用对池内所有对象一视同仁的对象池，并不能解决问题。例如，有时需要通过key来获取不同的对象，这样，就有可能取出不合用的对象的麻烦。当然，可以通过为每一组参数相同的同类对象建立一个单独的对象池来解决这个问题。但是，如果使用普通的&lt;code&gt;ObjectPool&lt;/code&gt;来实施这个计策的话，因为普通的&lt;code&gt;PooledObjectFactory&lt;/code&gt;只能生产出大批设置完全一致的对象，就需要为每一组参数相同的对象编写一个单独的&lt;code&gt;PooledObjectFactory&lt;/code&gt;，工作量相当可观。这种时候就可以使用&lt;code&gt;BaseKeyedPooledObjectFactory&lt;/code&gt;来替代&lt;code&gt;BasePooledObjectFactory&lt;/code&gt;.这个类，实现的是&lt;code&gt;KeyedPooledObjectFactory&lt;/code&gt;接口，和&lt;code&gt;PooledObjectFactory&lt;/code&gt;接口类似，只是在相关的方法中多了&lt;code&gt;Key&lt;/code&gt;参数,定义如下：&lt;/p&gt;

&lt;p&gt;```
public interface KeyedPoolableObjectFactory&amp;lt;K,V&gt; {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PooledObject&amp;lt;V&amp;gt; makeObject(K key);
void activateObject(K key, PooledObject&amp;lt;V&amp;gt; obj);
void passivateObject(K key, PooledObject&amp;lt;V&amp;gt; obj);
boolean validateObject(K key, PooledObject&amp;lt;V&amp;gt; obj);
void destroyObject(K key, PooledObject&amp;lt;V&amp;gt; obj);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;h4&gt;3.2 创建对象池&lt;/h4&gt;

&lt;p&gt;在&lt;code&gt;org.apache.commons.pool2.impl&lt;/code&gt;中预设了三个可以直接使用的对象池：&lt;code&gt;GenericObjectPool&lt;/code&gt;、&lt;code&gt;GenericKeyedObjectPool&lt;/code&gt;和&lt;code&gt;SoftReferenceObjectPool&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;通常使用&lt;code&gt;GenericObjectPool&lt;/code&gt;来创建对象池，如果是对象池是&lt;code&gt;Keyed&lt;/code&gt;的，那么可以使用&lt;code&gt;GenericKeyedObjectPool&lt;/code&gt;来创建对象池。这两个类都提供了丰富的配置选项。这两个对象池的特点是可以设置对象池中的对象特征，包括LIFO方式、最大空闲数、最小空闲数、是否有效性检查等等。两者的区别如前面所述，后者支持&lt;code&gt;Keyed&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;而&lt;code&gt;SoftReferenceObjectPool&lt;/code&gt;对象池，它利用一个&lt;code&gt;java.util.ArrayList&lt;/code&gt;对象来保存对象池里的对象。不过它并不在对象池里直接保存对象本身，而是保存它们的“软引用”（&lt;code&gt;Soft Reference&lt;/code&gt;）。这种对象池的特色是：可以保存任意多个对象，不会有容量已满的情况发生;在对象池已空的时候，调用它的&lt;code&gt;borrowObject&lt;/code&gt;方法，会自动返回新创建的实例;可以在初始化同时，在池内预先创建一定量的对象;当内存不足的时候，池中的对象可以被Java虚拟机回收。&lt;/p&gt;

&lt;p&gt;举个例子:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
new GenericObjectPool&amp;lt;StringBuffer&amp;gt;(new StringBufferFactory());
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们也可以使用&lt;code&gt;GenericObjectPoolConfig&lt;/code&gt;来对上面创建的对象池进行一些参数配置，创建的Config参数，可以使用&lt;code&gt;setConfig&lt;/code&gt;方法传给对象池，也可以在对象池的构造方法中作为参数传入。&lt;/p&gt;

&lt;p&gt;举个例子：&lt;/p&gt;

&lt;p&gt;```
GenericObjectPoolConfig conf = new GenericObjectPoolConfig();
conf.setMaxTotal(20);
conf.setMaxIdle(10);
...
GenericObjectPool&lt;StringBuffer&gt; pool = new GenericObjectPool&lt;StringBuffer&gt;(new StringBufferFactory(), conf);&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h4&gt;3.3 使用对象池&lt;/h4&gt;

&lt;p&gt;对象池使用起来很方便，简单一点就是使用&lt;code&gt;borrowObject&lt;/code&gt;和&lt;code&gt;returnObject&lt;/code&gt;两个方法，直接给参考代码吧：&lt;/p&gt;

&lt;p&gt;```
StringBuffer buf = null;
try {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;buf = pool.borrowObject();
...         
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;} catch(IOException e) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;throw e; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;} catch(Exception e) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;throw new RuntimeException(&quot;Unable to borrow buffer from pool&quot; + 
      e.toString());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;} finally {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try {
    if(null != buf) {
        pool.returnObject(buf);
    }
} catch(Exception e) {
    // ignored
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Apache Commons 系列简介 之 CLI</title>
   <link href="http://www.blogways.net/blog/2014/01/15/apache-commons-cli.html"/>
   <updated>2014-01-15T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/01/15/apache-commons-cli</id>
   <content type="html">&lt;p&gt;&lt;code&gt;Apache Commons&lt;/code&gt;的主要目的就是，创建和维护一个可重用的java组件库集合。这样Apache社区的开发者，就可以使用相同的基础组件库来开发不同的Apache项目了。&lt;/p&gt;

&lt;p&gt;而&lt;code&gt;Apache Commons&lt;/code&gt;的开发者们，将尽量减少这些组件对其他外部库的影响，来确保这些组件可以很容易地进行部署。另外，这些组件将尽可能地保证接口稳定，以便Apache用户（包括Apache项目）可以实现这些组件，而不必担心未来发生变化。&lt;/p&gt;

&lt;p&gt;本文将介绍Commons系列中的CLI组件库。&lt;/p&gt;

&lt;h3&gt;一、Commons CLI 概述&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Apache Commons CLI&lt;/code&gt; 库提供API，可以帮助程序去解析传递给程序的命令行参数。他也可以打印帮助信息，来说明可以运用于命令行的有效参数。&lt;/p&gt;

&lt;p&gt;CLI库支持不同格式的选项：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;POSIX格式的选项（比如：&lt;code&gt;tar -zxvf foo.tar.gz&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;GNU格式的长参数选项（比如：&lt;code&gt;du --human-readable --max-depth=1&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;Java格式的属性（比如：&lt;code&gt;java -Djava.awt.headless=true -Djava.net.useSystemProxies=true Foo&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;带值的单选项（比如：&lt;code&gt;gcc -O2 foo.c&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;单&lt;code&gt;-&lt;/code&gt;号的长参数选项（比如：&lt;code&gt;ant -projecthelp&lt;/code&gt;）&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;CLI库可以提供的帮助信息，类似如下：&lt;/p&gt;

&lt;p&gt;```
usage: ls
 -A,--almost-all          do not list implied . and ..
 -a,--all                 do not hide entries starting with .
 -B,--ignore-backups      do not list implied entried ending with ~
 -b,--escape              print octal escapes for nongraphic characters&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--block-size &amp;lt;SIZE&amp;gt;   use SIZE-byte blocks
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; -c                       with -lt: sort by, and show, ctime (time of last&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                      modification of file status information) with
                      -l:show ctime and sort by name otherwise: sort
                      by ctime
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; -C                       list entries by columns
```&lt;/p&gt;

&lt;h3&gt;二、Commons CLI 下载&lt;/h3&gt;

&lt;p&gt;截止本文撰写时，CLI的最新发布版本为&lt;code&gt;1.2&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;官方下载地址：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://commons.apache.org/proper/commons-cli/download_cli.cgi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;源码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;svn checkout http://svn.apache.org/repos/asf/commons/proper/cli/trunk/ commons-cli
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Maven工程中添加依赖：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;commons-cli&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;commons-cli&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;三、使用场景&lt;/h3&gt;

&lt;h3&gt;3.1 布尔选项&lt;/h3&gt;

&lt;p&gt;布尔选项是命令行最常见的选项，作为开关使用，不带参数。如果命令行中存在该选项，那么选项值就为&lt;code&gt;true&lt;/code&gt;，否则其值为&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;举例，如果程序需要布尔选项&lt;code&gt;-t&lt;/code&gt;,代码如下：&lt;/p&gt;

&lt;p&gt;```
// create Options object
Options options = new Options();&lt;/p&gt;

&lt;p&gt;// add t option
options.addOption(&quot;t&quot;, false, &quot;display current time&quot;);
```&lt;/p&gt;

&lt;p&gt;如上，必须创建&lt;code&gt;Options&lt;/code&gt;选项，然后为其添加&lt;code&gt;Option&lt;/code&gt;对象。&lt;/p&gt;

&lt;p&gt;上例中，&lt;code&gt;addOption&lt;/code&gt;方法有三个参数：第一个参数类型为&lt;code&gt;String&lt;/code&gt;，给出参数的名字；第二个参数类型为&lt;code&gt;boolean&lt;/code&gt;，用来标记该选项是否需要参数,在上面例子中，布尔选项不需要参数，所以设置为&lt;code&gt;false&lt;/code&gt;；第三个参数是选项的描述信息，该描述信息在打印命令行帮助信息时，会显示出来。&lt;/p&gt;

&lt;p&gt;另外，&lt;code&gt;addOption&lt;/code&gt;还存在一个四个参数的调用方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;addOption(String opt, String longOpt, boolean hasArg, String description)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里，多了一个长选项参数，在后面的例子中，我们可以看到具体的使用。&lt;/p&gt;

&lt;h3&gt;3.2 解析命令行参数&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;CommandLineParser&lt;/code&gt;提供的方法&lt;code&gt;parse&lt;/code&gt;，就是用来解析命令行中的参数。接口&lt;code&gt;CommandLineParser&lt;/code&gt;存在多种实现类，比如&lt;code&gt;BasicParser&lt;/code&gt;、&lt;code&gt;PosixParser&lt;/code&gt;和&lt;code&gt;GnuParser&lt;/code&gt;，可以根据实际需求选择使用.&lt;/p&gt;

&lt;p&gt;其中，&lt;code&gt;PosixParser&lt;/code&gt;与&lt;code&gt;GnuParser&lt;/code&gt;，顾名思义，其区别在于，前者把形如&lt;code&gt;-log&lt;/code&gt;的选项作为三个选项(&lt;code&gt;l&lt;/code&gt;、&lt;code&gt;o&lt;/code&gt;和&lt;code&gt;g&lt;/code&gt;)处理，而后者作为一个选项处理。&lt;/p&gt;

&lt;p&gt;具体代码，参考如下：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
CommandLineParser parser = new GnuParser();
CommandLine cmd = parser.parse( options, args);
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果，我们要检查命令行中&lt;code&gt;t&lt;/code&gt;选项是否被列出，可以使用&lt;code&gt;hasOption&lt;/code&gt;方法。例如：&lt;/p&gt;

&lt;p&gt;```
if(cmd.hasOption(&quot;t&quot;)) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 存在t选项的处理
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
else {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 不存在t选项的处理
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;h3&gt;3.2 带参数选项&lt;/h3&gt;

&lt;p&gt;除了布尔选项外，还有些选项是需要参数的。比如&lt;code&gt;c&lt;/code&gt;选项需要参数，那么可以如下设置：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
// add c option
options.addOption(&quot;c&quot;, true, &quot;country code&quot;);
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;并且，可以通过&lt;code&gt;getOptionValue&lt;/code&gt;方法，获取命令行传入的参数：&lt;/p&gt;

&lt;p&gt;```
// get c option value
String countryCode = cmd.getOptionValue(&quot;c&quot;);&lt;/p&gt;

&lt;p&gt;if(countryCode == null) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// print default date
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
else {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// print date for country specified by countryCode
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;h3&gt;3.3 Ant命令行实例&lt;/h3&gt;

&lt;p&gt;在这里，我们使用一个被普遍使用的java应用程序Ant来解释如果使用CLI库的。&lt;/p&gt;

&lt;h4&gt;3.3.1 先看看Ant的命令帮助&lt;/h4&gt;

&lt;p&gt;```
ant [options] [target [target2 [target3] ...]]
  Options:
  -help                  print this message
  -projecthelp           print project help information
  -version               print the version information and exit
  -quiet                 be extra quiet
  -verbose               be extra verbose
  -debug                 print debugging information
  -emacs                 produce logging information without adornments
  -logfile &lt;file&gt;        use given file for log
  -logger &lt;classname&gt;    the class which is to perform logging
  -listener &lt;classname&gt;  add an instance of class as a project listener
  -buildfile &lt;file&gt;      use given buildfile
  -D&lt;property&gt;=&lt;value&gt;   use value for given property
  -find &lt;file&gt;           search for buildfile towards the root of the&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                     filesystem and use it
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h4&gt;3.3.2 创建布尔选项&lt;/h4&gt;

&lt;p&gt;为了代码清晰，在这里我们使用&lt;code&gt;Option&lt;/code&gt;的构造方法来创建。&lt;/p&gt;

&lt;p&gt;```
Option help = new Option( &quot;help&quot;, &quot;print this message&quot; );
Option projecthelp = new Option( &quot;projecthelp&quot;, &quot;print project help information&quot; );
Option version = new Option( &quot;version&quot;, &quot;print the version information and exit&quot; );
Option quiet = new Option( &quot;quiet&quot;, &quot;be extra quiet&quot; );
Option verbose = new Option( &quot;verbose&quot;, &quot;be extra verbose&quot; );
Option debug = new Option( &quot;debug&quot;, &quot;print debugging information&quot; );
Option emacs = new Option( &quot;emacs&quot;,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                       &quot;produce logging information without adornments&quot; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h4&gt;3.3.3 创建带参数的选项&lt;/h4&gt;

&lt;p&gt;我们使用&lt;code&gt;OptionBuilder&lt;/code&gt;来创建：&lt;/p&gt;

&lt;p&gt;```
Option logfile   = OptionBuilder.withArgName( &quot;file&quot; )&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                            .hasArg()
                            .withDescription(  &quot;use given file for log&quot; )
                            .create( &quot;logfile&quot; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Option logger    = OptionBuilder.withArgName( &quot;classname&quot; )&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                            .hasArg()
                            .withDescription( &quot;the class which it to perform &quot;
                                              + &quot;logging&quot; )
                            .create( &quot;logger&quot; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Option listener  = OptionBuilder.withArgName( &quot;classname&quot; )&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                            .hasArg()
                            .withDescription( &quot;add an instance of class as &quot;
                                              + &quot;a project listener&quot; )
                            .create( &quot;listener&quot;); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Option buildfile = OptionBuilder.withArgName( &quot;file&quot; )&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                            .hasArg()
                            .withDescription(  &quot;use given buildfile&quot; )
                            .create( &quot;buildfile&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Option find      = OptionBuilder.withArgName( &quot;file&quot; )&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                            .hasArg()
                            .withDescription( &quot;search for buildfile towards the &quot;
                                              + &quot;root of the filesystem and use it&quot; )
                            .create( &quot;find&quot; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h4&gt;3.3.4 创建java属性选项&lt;/h4&gt;

&lt;p&gt;```
Option property  = OptionBuilder.withArgName( &quot;property=value&quot; )&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                            .hasArgs(2)
                            .withValueSeparator()
                            .withDescription( &quot;use value for given property&quot; )
                            .create( &quot;D&quot; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h4&gt;3.3.5 创建Options&lt;/h4&gt;

&lt;p&gt;上面已经创建了每个选项，下面我们需要创建&lt;code&gt;Options&lt;/code&gt;，然后继续使用&lt;code&gt;addOption&lt;/code&gt;方法，向其中添加每个选项，代码如下：&lt;/p&gt;

&lt;p&gt;```
Options options = new Options();&lt;/p&gt;

&lt;p&gt;options.addOption( help );
options.addOption( projecthelp );
options.addOption( version );
options.addOption( quiet );
options.addOption( verbose );
options.addOption( debug );
options.addOption( emacs );
options.addOption( logfile );
options.addOption( logger );
options.addOption( listener );
options.addOption( buildfile );
options.addOption( find );
options.addOption( property );
```&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明：可以通过&lt;code&gt;Option&lt;/code&gt;的&lt;code&gt;setRequired&lt;/code&gt;方法来设置，选项是否为必输项，默认不是必输项。 &lt;/strong&gt;&lt;/p&gt;

&lt;h4&gt;3.3.6 解析命令行参数&lt;/h4&gt;

&lt;p&gt;我们需要创建一个&lt;code&gt;CommandLineParser&lt;/code&gt;，并用它根据之前设置的&lt;code&gt;Options&lt;/code&gt;来解析命令行参数，代码如下：&lt;/p&gt;

&lt;p&gt;```
public static void main( String[] args ) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// create the parser
CommandLineParser parser = new GnuParser();
try {
    // parse the command line arguments
    CommandLine line = parser.parse( options, args );
}
catch( ParseException exp ) {
    // oops, something went wrong
    System.err.println( &quot;Parsing failed.  Reason: &quot; + exp.getMessage() );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;h4&gt;3.3.7 获取命令行参数&lt;/h4&gt;

&lt;p&gt;使用&lt;code&gt;hasOption&lt;/code&gt;方法来检查命令行是否传入选项，使用&lt;code&gt;getOptionValue&lt;/code&gt;来获取传入的参数值。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;p&gt;```
// has the buildfile argument been passed?
if( line.hasOption( &quot;buildfile&quot; ) ) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// initialise the member variable
this.buildfile = line.getOptionValue( &quot;buildfile&quot; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;h4&gt;3.3.8 设置程序用例/帮助信息&lt;/h4&gt;

&lt;p&gt;CLI库还可以根据&lt;code&gt;Options&lt;/code&gt;来自动显示程序的用例/帮助信息。代码如下：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
// automatically generate the help statement
HelpFormatter formatter = new HelpFormatter();
formatter.printHelp( &quot;ant&quot;, options, true );
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;执行后生成下面信息：&lt;/p&gt;

&lt;p&gt;```
usage: ant
-D &amp;lt;property=value&gt;     use value for given property
-buildfile &lt;file&gt;       use given buildfile
-debug                  print debugging information
-emacs                  produce logging information without adornments
-file &lt;file&gt;            search for buildfile towards the root of the&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                    filesystem and use it
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-help                   print this message
-listener &lt;classname&gt;   add an instance of class as a project listener
-logger &lt;classname&gt;     the class which it to perform logging
-projecthelp            print project help information
-quiet                  be extra quiet
-verbose                be extra verbose
-version                print the version information and exit
```&lt;/p&gt;

&lt;h3&gt;3.4 再来一个&lt;code&gt;ls&lt;/code&gt;实例&lt;/h3&gt;

&lt;p&gt;下面是帮助信息：&lt;/p&gt;

&lt;p&gt;```
Usage: ls [OPTION]... [FILE]...
List information about the FILEs (the current directory by default).
Sort entries alphabetically if none of -cftuSUX nor --sort.&lt;/p&gt;

&lt;p&gt;-a, --all                  do not hide entries starting with .
-A, --almost-all           do not list implied . and ..
-b, --escape               print octal escapes for nongraphic characters&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--block-size=SIZE      use SIZE-byte blocks
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-B, --ignore-backups       do not list implied entries ending with ~
-c                         with -lt: sort by, and show, ctime (time of last&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                       modification of file status information)
                       with -l: show ctime and sort by name
                       otherwise: sort by ctime
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-C                         list entries by columns
```&lt;/p&gt;

&lt;p&gt;下面是代码：&lt;/p&gt;

&lt;p&gt;```
// create the command line parser
CommandLineParser parser = new GnuParser();&lt;/p&gt;

&lt;p&gt;// create the Options
Options options = new Options();
options.addOption( &quot;a&quot;, &quot;all&quot;, false, &quot;do not hide entries starting with .&quot; );
options.addOption( &quot;A&quot;, &quot;almost-all&quot;, false, &quot;do not list implied . and ..&quot; );
options.addOption( &quot;b&quot;, &quot;escape&quot;, false, &quot;print octal escapes for nongraphic &quot;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                                     + &quot;characters&quot; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;options.addOption( OptionBuilder.withLongOpt( &quot;block-size&quot; )&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                            .withDescription( &quot;use SIZE-byte blocks&quot; )
                            .hasArg()
                            .withArgName(&quot;SIZE&quot;)
                            .create() );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;options.addOption( &quot;B&quot;, &quot;ignore-backups&quot;, false, &quot;do not list implied entried &quot;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                                             + &quot;ending with ~&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;options.addOption( &quot;c&quot;, false, &quot;with -lt: sort by, and show, ctime (time of last &quot;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                           + &quot;modification of file status information) with &quot;
                           + &quot;-l:show ctime and sort by name otherwise: sort &quot;
                           + &quot;by ctime&quot; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;options.addOption( &quot;C&quot;, false, &quot;list entries by columns&quot; );&lt;/p&gt;

&lt;p&gt;String[] args = new String[]{ &quot;--block-size=10&quot; };&lt;/p&gt;

&lt;p&gt;try {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// parse the command line arguments
CommandLine line = parser.parse( options, args );

// validate that block-size has been set
if( line.hasOption( &quot;block-size&quot; ) ) {
    // print the value of block-size
    System.out.println( line.getOptionValue( &quot;block-size&quot; ) );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
catch( ParseException exp ) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;System.out.println( &quot;Unexpected exception:&quot; + exp.getMessage() );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Apache Commons 系列简介 之 BeanUtils</title>
   <link href="http://www.blogways.net/blog/2014/01/15/apache-commons-beanutils.html"/>
   <updated>2014-01-15T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/01/15/apache-commons-beanutils</id>
   <content type="html">&lt;h3&gt;一、概述&lt;/h3&gt;

&lt;p&gt;大部分Java开发人员都会安装JavaBeans的命名规范为属性创建getter和setter方法，我们可以直接通过getXxx和setXxx方法直接进行调用。但是，也有一些场合我们必须动态访问java对象的属性，比如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;为和java对象模型进行交互，而创建的脚本语言（如：&lt;code&gt;Bean Scripting Framework&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;为处理WEB展示或者类似需求，而创建的模板语言(如：&lt;code&gt;JSP&lt;/code&gt;和&lt;code&gt;Velocity&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;为JSP和XSP环境创建自定义tag库(如：&lt;code&gt;Apache Taglibs&lt;/code&gt;、&lt;code&gt;Struts&lt;/code&gt;和&lt;code&gt;Cocoon&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;对一些基于XML配置的资源的处理（如：&lt;code&gt;Ant&lt;/code&gt;构建脚本，web应用部署配置文件，Tomcat的&lt;code&gt;server.xml&lt;/code&gt;文件等等）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Java语言提供了反射(&lt;code&gt;Reflection&lt;/code&gt;)和内省(&lt;code&gt;Introspection&lt;/code&gt;&lt;a href=&quot;Java%E7%A8%8B%E5%BA%8F%E5%8F%AF%E4%BB%A5%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%98%AF%E5%8A%A0%E8%BD%BDClass%EF%BC%8C%E8%8E%B7%E5%8F%96%E5%85%B6%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%8C%E5%B9%B6%E7%94%9F%E6%88%90%E5%85%B6%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BD%93%E3%80%81%E6%88%96%E5%AF%B9%E5%85%B6fields%E8%AE%BE%E5%80%BC%E3%80%81%E6%88%96%E5%94%A4%E8%B5%B7%E5%85%B6methods%E3%80%82%E8%BF%99%E7%A7%8D%E2%80%9C%E9%80%8F%E8%A7%86Class%E2%80%9D%E7%9A%84%E8%83%BD%E5%8A%9B%EF%BC%88`the&quot;&gt;^1&lt;/a&gt;)API（见&lt;code&gt;java.lang.reflect&lt;/code&gt;和&lt;code&gt;java.beans&lt;/code&gt;这两个包说明），但这些API很难理解并加以应用。而BeanUtils库的目的，就是针对这些能力提供了易用的包装。&lt;/p&gt;

&lt;h3&gt;二、下载及源码&lt;/h3&gt;

&lt;p&gt;下载地址：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://commons.apache.org/proper/commons-beanutils/download_beanutils.cgi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;源码获取：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;svn checkout http://svn.apache.org/repos/asf/commons/proper/beanutils/trunk/ commons-beanutils
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Github镜像：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://github.com/apache/commons-beanutils
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Maven依赖：&lt;/p&gt;

&lt;p&gt;```
&lt;dependency&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;groupId&amp;gt;commons-beanutils&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;commons-beanutils&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;1.9.0&amp;lt;/version&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/dependency&gt;
```&lt;/p&gt;

&lt;h3&gt;三、使用说明&lt;/h3&gt;

&lt;p&gt;自从&lt;code&gt;1.7.0&lt;/code&gt;版开始，BeanUtils发布三个jar包，供应用调用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;commons-beanutils.jar&lt;/code&gt; 包含所有功能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;commons-beanutils-core.jar&lt;/code&gt; 包含除&lt;code&gt;Bean Collections&lt;/code&gt;类外的所有功能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;commons-beanutils-bean-collections.jar&lt;/code&gt; 只包含&lt;code&gt;Bean Collections&lt;/code&gt;类&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;应用可以根据需求，选择使用。&lt;/p&gt;

&lt;p&gt;在运行时，&lt;code&gt;commons-beanutils&lt;/code&gt;包依赖&lt;code&gt;commons-logging&lt;/code&gt;包，另外，如果使用了下面几个类，则还需要依赖&lt;code&gt;commons-collections&lt;/code&gt;包：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;org.apache.commons.beanutils.BeanMap&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;org.apache.commons.beanutils.BeanPredicate&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;org.apache.commons.beanutils.BeanPropertyValueChangeClosure&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;org.apache.commons.beanutils.BeanPropertyValueEqualsPredicate&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;org.apache.commons.beanutils.BeanToPropertyValueTransformer&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;3.1 标准JavaBeans&lt;/h4&gt;

&lt;p&gt;在介绍之前，我们先给一个对象的定义，后面的实例将结合这个对象给出。&lt;/p&gt;

&lt;p&gt;```
public class Employee {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public Address getAddress(String type);
public void setAddress(String type, Address address);
public Employee getSubordinate(int index);
public void setSubordinate(int index, Employee subordinate);
public String getFirstName();
public void setFirstName(String firstName);
public String getLastName();
public void setLastName(String lastName);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
```&lt;/p&gt;

&lt;h4&gt;3.1.1 基本属性读写&lt;/h4&gt;

&lt;p&gt;首先，我们介绍&lt;code&gt;PropertyUtils&lt;/code&gt;类，其作用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可以很容易的读取或者设置简单的属性值&lt;/p&gt;

&lt;p&gt;  所谓“简单”的属性，是指：属性只是一个简单的可被读写的值。这个属性的类型，可能是java语言原生类型（如:&lt;code&gt;int&lt;/code&gt;或一个简单对象&lt;code&gt;java.lang.String&lt;/code&gt;等），也可能是一个由程序或者类库定义的复杂的对象&lt;/p&gt;

&lt;p&gt;  对其操作的API有：&lt;/p&gt;

&lt;p&gt;  &lt;code&gt;
  //读操作
  PropertyUtils.getSimpleProperty(Object, String)
  //写操作
  PropertyUtils.setSimpleProperty(Object, String, Object)
 &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;  例如：&lt;/p&gt;

&lt;p&gt;  &lt;code&gt;
  Employee employee = ...;
  String firstName = (String)
     PropertyUtils.getSimpleProperty(employee, &quot;firstName&quot;);
  String lastName = (String)
     PropertyUtils.getSimpleProperty(employee, &quot;lastName&quot;);
  ... manipulate the values ...
  PropertyUtils.setSimpleProperty(employee, &quot;firstName&quot;, firstName);
  PropertyUtils.setSimpleProperty(employee, &quot;lastName&quot;, lastName);
 &lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;针对带序列的属性，支持两种操作方式。&lt;/p&gt;

&lt;p&gt;  所谓“带序列”的属性，是指：一组有序的对象集合，可以通过自然数下标单独访问。或者可以如同数组那样进行读写。如果，属性的类型是&lt;code&gt;java.util.List&lt;/code&gt;也可以。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一种方式：将下标使用方括号括起来，然后跟在属性名后，当做属性名使用。&lt;/p&gt;

&lt;p&gt;  其API为：&lt;/p&gt;

&lt;p&gt;  &lt;code&gt;
  //读操作
  PropertyUtils.getIndexedProperty(Object, String)
  //取操作
  PropertyUtils.setIndexedProperty(Object, String, Object)
 &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;  例如：&lt;/p&gt;

&lt;p&gt;  &lt;code&gt;
  Employee employee = ...;
  int index = ...;
  String name = &quot;subordinate[&quot; + index + &quot;]&quot;;
  Employee subordinate = (Employee)
  PropertyUtils.getIndexedProperty(employee, name);
 &lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;另外一种方式：将下标作为一个单独的参数使用。&lt;/p&gt;

&lt;p&gt;  其API：&lt;/p&gt;

&lt;p&gt;  &lt;code&gt;
  PropertyUtils.getIndexedProperty(Object, String, int)
  PropertyUtils.setIndexedProperty(Object, String, int, Object)
 &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;  例如：&lt;/p&gt;

&lt;p&gt;  &lt;code&gt;
  Employee employee = ...;
  int index = ...;
  Employee subordinate = (Employee)
  PropertyUtils.getIndexedProperty(employee, &quot;subordinate&quot;, index);
 &lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;针对可以Maped的属性，支持两种操作方式，类似上面的带序列属性的读写操作。&lt;/p&gt;

&lt;p&gt;  所谓“可以Maped”的属性值，是指属性类型为&lt;code&gt;java.util.Map&lt;/code&gt;。可以通过String型的键，对其进行读写。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一种方式：将键值用圆括号括起来，跟在属性名后面，当做属性名使用。&lt;/p&gt;

&lt;p&gt;  其API：&lt;/p&gt;

&lt;p&gt;  &lt;code&gt;
  //读操作
  PropertyUtils.getMappedProperty(Object, String)
  //写操作
  PropertyUtils.setMappedProperty(Object, String, Object)
 &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;  例如：&lt;/p&gt;

&lt;p&gt;  &lt;code&gt;
  Employee employee = ...;
  Address address = ...;
  PropertyUtils.setMappedProperty(employee, &quot;address(home)&quot;, address);
 &lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;另外一种方式：将键值作为一个单独的参数使用。&lt;/p&gt;

&lt;p&gt;  其API：&lt;/p&gt;

&lt;p&gt;  &lt;code&gt;
  //读操作
  PropertyUtils.getMappedProperty(Object, String, String)
  //写操作
  PropertyUtils.setMappedProperty(Object, String, String, Object)
 &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;  例如：&lt;/p&gt;

&lt;p&gt;  &lt;code&gt;
  Employee employee = ...;
  Address address = ...;
  PropertyUtils.setMappedProperty(employee, &quot;address&quot;, &quot;home&quot;, address);
 &lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;3.1.2 嵌套属性读写&lt;/h4&gt;

&lt;p&gt;结合上面的例子，如果我们要访问雇员家庭地址中的城市信息，按常规编程方式，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;String city = employee.getAddress(&quot;home&quot;).getCity();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要使用&lt;code&gt;PropertyUtils&lt;/code&gt;来访问类似上面的多层属性，可以通过&lt;code&gt;.&lt;/code&gt;符号将属性名串联起来作为访问路径。使用的API为：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
PropertyUtils.getNestedProperty(Object, String)
PropertyUtils.setNestedProperty(Object, String, Object)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;上面实例的等效代码为：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
String city = (String) PropertyUtils.getNestedProperty(employee, &quot;address(home).city&quot;);
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这里再给出一组更简单的常用的API：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
//读操作
PropertyUtils.getProperty(Object, String)
//写操作
PropertyUtils.setProperty(Object, String, Object)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用举例：&lt;/p&gt;

&lt;p&gt;```
Employee employee = ...;
String city = (String) PropertyUtils.getProperty(employee,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   &quot;subordinate[3].address(home).city&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h4&gt;3.2 动态 Beans&lt;/h4&gt;

&lt;p&gt;上面介绍的&lt;code&gt;PropertyUtils&lt;/code&gt;类，可以轻松地对已经存在的JavaBean的属性进行访问。但是，有些场合，你需要通过动态计算出来的属性集，来确定一个JavaBean，而不必实际编写某个确定的JavaBean。&lt;/p&gt;

&lt;p&gt;为此目的，BeanUtils提供&lt;code&gt;DynaBean&lt;/code&gt;接口和与之相关的&lt;code&gt;DynaClass&lt;/code&gt;接口。&lt;/p&gt;

&lt;p&gt;我们看看代码，如何使用&lt;code&gt;DynaBean&lt;/code&gt;来实现前面&lt;code&gt;Employee&lt;/code&gt;类的功能：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
DynaBean employee = ...; // 这里的代码，要根据你使用的具体的BynaBean实现来定了
String firstName = (String) employee.get(&quot;firstName&quot;);
Address homeAddress = (Address) employee.get(&quot;address&quot;, &quot;home&quot;);
Object subordinate = employee.get(&quot;subordinate&quot;, 2);
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;由于&lt;code&gt;DynaBean&lt;/code&gt;和&lt;code&gt;DynaClass&lt;/code&gt;仅仅是接口，所以可以有不同的实现。可以根据不同的场景，开发不同的实现。下面我们来介绍几个&lt;code&gt;BeanUtils&lt;/code&gt;内置的实现，你也可以根据你的具体需求，来定制自己的实现。&lt;/p&gt;

&lt;h4&gt;3.2.1 &lt;code&gt;BasicDynaBean&lt;/code&gt;和&lt;code&gt;BasicDynaClass&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;我们结合前面的&lt;code&gt;Employee&lt;/code&gt;例子，来介绍&lt;code&gt;BasicDynaBean&lt;/code&gt;和&lt;code&gt;BasicDynaClass&lt;/code&gt;的使用步骤及实例代码如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建属性集&lt;/p&gt;

&lt;p&gt; &lt;code&gt;
 DynaProperty[] props = new DynaProperty[]{
      new DynaProperty(&quot;address&quot;, java.util.Map.class),
      new DynaProperty(&quot;subordinate&quot;, Employee[].class),
      new DynaProperty(&quot;firstName&quot;, String.class),
      new DynaProperty(&quot;lastName&quot;,  String.class)
    };
&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建&lt;code&gt;BasicDynaClass&lt;/code&gt;&lt;/p&gt;

&lt;p&gt; &lt;code&gt;
 BasicDynaClass dynaClass = new BasicDynaClass(&quot;employee&quot;, null, props);
&lt;/code&gt;
 这里&lt;code&gt;BasicDynaClass&lt;/code&gt;构造方法接收的第二个参数是&lt;code&gt;null&lt;/code&gt;，它内部会作为&lt;code&gt;BasicDynaBean.class&lt;/code&gt;来处理。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;获取&lt;code&gt;DynaBean&lt;/code&gt;实例并操作&lt;/p&gt;

&lt;p&gt; &lt;code&gt;
 DynaBean employee = dynaClass.newInstance();
 employee.set(&quot;address&quot;, new HashMap());
 employee.set(&quot;subordinate&quot;, new Employee[0]);
 employee.set(&quot;firstName&quot;, &quot;Fred&quot;);
 employee.set(&quot;lastName&quot;, &quot;Flintstone&quot;);
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt; 这里，&lt;code&gt;dynaClass.newInstance()&lt;/code&gt;的返回值的类型为&lt;code&gt;DynaBean&lt;/code&gt;而不是上文中设置的&lt;code&gt;BasicDynaBean&lt;/code&gt;,这是因为，一般情况下，程序是不关心具体实现，而只需要根据&lt;code&gt;BynaBean&lt;/code&gt;的接口进行访问就行了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;3.2.2 &lt;code&gt;ResultSetDynaClass&lt;/code&gt;（使用&lt;code&gt;DynaBeans&lt;/code&gt;去包装&lt;code&gt;ResultSet&lt;/code&gt;）&lt;/h4&gt;

&lt;p&gt;将一系列有关系的，但自身又不是JavaBean的数据集合，包装起来，是&lt;code&gt;DynaBean&lt;/code&gt;API的一个最普遍的使用方式。这其中一个经典应用就是，使用&lt;code&gt;DynaBean&lt;/code&gt;去包装，用&lt;code&gt;JDBC&lt;/code&gt;执行一个&lt;code&gt;SELECT&lt;/code&gt;语句返还的结果&lt;code&gt;java.sql.ResultSet&lt;/code&gt;对象。&lt;/p&gt;

&lt;p&gt;看下面的例子：&lt;/p&gt;

&lt;p&gt;```
Connection conn = ...;
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; (&quot;select account_id, name from customers&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Iterator rows = (new ResultSetDynaClass(rs)).iterator();
while (rows.hasNext()) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DynaBean row = (DynaBean) rows.next();
System.out.println(&quot;Account number is &quot; +
                    row.get(&quot;account_id&quot;) +
                    &quot; and name is &quot; + row.get(&quot;name&quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
rs.close();
stmt.close();
```&lt;/p&gt;

&lt;h4&gt;3.2.3 &lt;code&gt;RowSetDynaClass&lt;/code&gt;(将离线的&lt;code&gt;ResultSet&lt;/code&gt;包装成&lt;code&gt;DynaBeans&lt;/code&gt;)&lt;/h4&gt;

&lt;p&gt;尽管使用&lt;code&gt;ResultSetDynaClass&lt;/code&gt;很方便，但是它要求查询的结果集在数据整个处理过程中一直保持&lt;code&gt;open&lt;/code&gt;状态。然而，有时我们需要先将结果集关闭后，再去处理查询结果的内容。不过这种方式的缺点是，我们需要足够的内存存储查询结果，以及存储过程中所需的性能损耗。如果，你能接受这点，那就可以使用&lt;code&gt;RowSetDynaClass&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;看下面的例子：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
Connection conn = ...;  // 从连接池获取连接
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(&quot;SELECT ...&quot;);
RowSetDynaClass rsdc = new RowSetDynaClass(rs);
rs.close();
stmt.close();
...;                    // 将连接放回连接池
List rows = rsdc.getRows();
...;                    // 处理记录
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;RowSetDynaClass&lt;/code&gt;有个额外的好处，由于&lt;code&gt;RowSetDynaClass&lt;/code&gt;实现了&lt;code&gt;java.io.Serializable&lt;/code&gt;，所以可以很容易的序列化和反序列化。这样，使用&lt;code&gt;RowSetDynaClass&lt;/code&gt;就可以很容易地将SQL语句查询结果传输给远程的java端应用。&lt;/p&gt;

&lt;h4&gt;3.2.4 &lt;code&gt;WrapDynaBean&lt;/code&gt;和&lt;code&gt;WrapDynaClass&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;如果，你习惯使用&lt;code&gt;DynaBeans&lt;/code&gt;去通过&lt;code&gt;set&lt;/code&gt;和&lt;code&gt;get&lt;/code&gt;方法去对&lt;code&gt;DynaBeans&lt;/code&gt;进行存取属性。而标准的JavaBean肯定不具备这样的方法。没关系，你可以使用&lt;code&gt;WrapDynaBean&lt;/code&gt;让现有的标准JavaBean也可以变得这样更易访问。&lt;/p&gt;

&lt;p&gt;看例子：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
MyBean bean = ...;
DynaBean wrapper = new WrapDynaBean(bean);
String firstName = wrapper.get(&quot;firstName&quot;);
&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;3.2.5 &lt;code&gt;Lazy DynaBeans&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;包含有下面几个类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;LazyDynaBean 一个“懒”动态Bean&lt;/li&gt;
&lt;li&gt;LazyDynaMap 一个轻量级的可以转换为Map的DynaBean。&lt;/li&gt;
&lt;li&gt;LazyDynaList 一个可以存放&lt;code&gt;DynaBean&lt;/code&gt;、&lt;code&gt;java.util.Map&lt;/code&gt;或者&lt;code&gt;POJO&lt;/code&gt;的&quot;懒&quot;列表&lt;/li&gt;
&lt;li&gt;LazyDynaClass &lt;code&gt;MutableDynaClass&lt;/code&gt;接口的一个实现&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;code&gt;Lazy DynaBeans&lt;/code&gt;具备下面的特性：
* 可以通过&lt;code&gt;set(name, value)&lt;/code&gt;方法自动添加属性
* &lt;code&gt;List&lt;/code&gt;或&lt;code&gt;Array&lt;/code&gt;的序列不够时，可以自动增长
* 自动实例化，在调用&lt;code&gt;setter/getter&lt;/code&gt;方法中，会根据上下文进行实例化，创建对应的&lt;code&gt;Bean&lt;/code&gt;、&lt;code&gt;List&lt;/code&gt;或者&lt;code&gt;Map&lt;/code&gt;等实例。&lt;/p&gt;

&lt;p&gt;简单举例如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;LazyDynaBean&lt;/code&gt;&lt;/p&gt;

&lt;p&gt; ```
 DynaBean dynaBean = new LazyDynaBean();&lt;/p&gt;

&lt;p&gt; dynaBean.set(&quot;foo&quot;, &quot;bar&quot;);                   // simple&lt;/p&gt;

&lt;p&gt; dynaBean.set(&quot;customer&quot;, &quot;title&quot;, &quot;Mr&quot;);      // mapped
 dynaBean.set(&quot;customer&quot;, &quot;surname&quot;, &quot;Smith&quot;); // mapped&lt;/p&gt;

&lt;p&gt; dynaBean.set(&quot;address&quot;, 0, addressLine1);     // indexed
 dynaBean.set(&quot;address&quot;, 1, addressLine2);     // indexed
 dynaBean.set(&quot;address&quot;, 2, addressLine3);     // indexed
 ```&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;LazyDynaMap&lt;/code&gt;&lt;/p&gt;

&lt;p&gt; 如果你想将动态Bean转换为Map，可以这样：&lt;/p&gt;

&lt;p&gt; ```
 DynaBean dynaBean = new LazyDynaMap();        // create DynaBean&lt;/p&gt;

&lt;p&gt; dynaBean.set(&quot;foo&quot;, &quot;bar&quot;);                   // simple
 dynaBean.set(&quot;customer&quot;, &quot;title&quot;, &quot;Mr&quot;);      // mapped
 dynaBean.set(&quot;address&quot;, 0, addressLine1);     // indexed&lt;/p&gt;

&lt;p&gt; Map myMap = dynaBean.getMap()                 // retrieve the Map
 ```&lt;/p&gt;

&lt;p&gt; 如果你想将Map转换为动态Bean，可以这样：&lt;/p&gt;

&lt;p&gt; &lt;code&gt;
 Map myMap = ....                             // exisitng Map
 DynaBean dynaBean = new LazyDynaMap(myMap);  // wrap Map in DynaBean
 dynaBean.set(&quot;foo&quot;, &quot;bar&quot;);                  // set properties
&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;LazyDynaList&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;你可以将任意一个&lt;code&gt;java.util.Map[]&lt;/code&gt;数值放到&lt;code&gt;LazyDynaList&lt;/code&gt;里面去：&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; &lt;code&gt;
 TreeMap[] myArray = .... // your Map[]
 List lazyList = new LazyDynaList(myArray);
&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;get(index)&lt;/code&gt;方法将自动增长list的序列：&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; &lt;code&gt;
 DynaBean newElement = (DynaBean)lazyList.get(lazyList.size());
 newElement.put(&quot;someProperty&quot;, &quot;someValue&quot;);
&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;操作结束后，可以再转换为map:&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; &lt;code&gt;
 TreeMap[] myArray = (TreeMap[])lazyList.toArray());
&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;你也可以创建空的列表，指定其中元素的类，&lt;code&gt;LazyDynaList&lt;/code&gt;可以根据指定的类自动填充元素：&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; ```
 List lazyList = new LazyDynaList(TreeMap.class);
 List lazyList = new LazyDynaList(MyPojo.class);
 List lazyList = new LazyDynaList(MyDynaBean.class);&lt;/p&gt;

&lt;p&gt; DynaClass dynaClass = new LazyDynaMap(new HashMap());
 List lazyList = new LazyDynaList(dynaClass);&lt;/p&gt;

&lt;p&gt; DynaClass dynaClass = (new WrapDynaBean(myPojo)).getDynaClass();
 List lazyList = new LazyDynaList(dynaClass);&lt;/p&gt;

&lt;p&gt; DynaClass dynaClass = new BasicDynaClass(properties);
 List lazyList = new LazyDynaList(dynaClass);
 ```&lt;/p&gt;

&lt;p&gt; 上面之所以使用&lt;code&gt;DynaClass&lt;/code&gt;来替代普通的&lt;code&gt;Class&lt;/code&gt;，是因为有些DynaBean的实现没有默认的空参数的构造方法，而&lt;code&gt;DynaClass&lt;/code&gt;提供了&lt;code&gt;DynaClass.newInstance()&lt;/code&gt;方法。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当然，也可以使用&lt;code&gt;setElementType(Class)&lt;/code&gt;或者&lt;code&gt;setElementDynaClass(DynaClass)&lt;/code&gt;方法来设置元素类型，然后使用普通的&lt;code&gt;java.util.List&lt;/code&gt;接口提供的方法(比如:&lt;code&gt;set/add/addAll&lt;/code&gt;)来填充元素:&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; ```
 // Create a new LazyDynaList (100 element capacity)
 LazyDynaList lazyList = new LazyDynaList(100);&lt;/p&gt;

&lt;p&gt; // Either Set the element type...
 lazyList.setElementType(TreeMap.class);&lt;/p&gt;

&lt;p&gt; // ...or the element DynaClass...
 lazyList.setElementDynaClass(new MyCustomDynaClass());&lt;/p&gt;

&lt;p&gt; // Populate from a collection
 lazyList.addAll(myCollection);
 ```&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;LazyDynaClass&lt;/code&gt;&lt;/p&gt;

&lt;p&gt; &lt;code&gt;LazyDynaClass&lt;/code&gt;继承于&lt;code&gt;BasicDynaClass&lt;/code&gt;,实现了&lt;code&gt;MutableDynaClass&lt;/code&gt;接口。我们在使用&lt;code&gt;LazyDynaBean&lt;/code&gt;时，有时不需要关系其内部结构，这样就不需要操作&lt;code&gt;DynaClass&lt;/code&gt;，但有时，我们需要强制其内部成员结构，这样就需要设置&lt;code&gt;DynaClass&lt;/code&gt;。做这种强制内部结构的操作，有两种方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我们可以先创建&lt;code&gt;LazyDynaClass&lt;/code&gt;，设置结构，然后再生成&lt;code&gt;LazyDynaBean&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; ```
 MutableDynaClass dynaClass = new LazyDynaClass();    // create DynaClass&lt;/p&gt;

&lt;p&gt; dynaClass.add(&quot;amount&quot;, java.lang.Integer.class);    // add property
 dynaClass.add(&quot;orders&quot;, OrderBean[].class);          // add indexed property
 dynaClass.add(&quot;orders&quot;, java.util.TreeMapp.class);   // add mapped property&lt;/p&gt;

&lt;p&gt; DynaBean dynaBean = new LazyDynaBean(dynaClass);     // Create DynaBean with associated DynaClass
 ```&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我们也可以先生成&lt;code&gt;LazyDynaBean&lt;/code&gt;,再获取&lt;code&gt;DynaClass&lt;/code&gt;设置结构：&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; ```
 DynaBean dynaBean = new LazyDynaBean();              // Create LazyDynaBean
 MutableDynaClass dynaClass =
           (MutableDynaClass)dynaBean.getDynaClass();  // get DynaClass&lt;/p&gt;

&lt;p&gt; dynaClass.add(&quot;amount&quot;, java.lang.Integer.class);    // add property
 dynaClass.add(&quot;myBeans&quot;, myPackage.MyBean[].class);  // add 'array' indexed property
 dynaClass.add(&quot;myMap&quot;, java.util.TreeMapp.class);    // add mapped property
 ```&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;3.3 数据类型转换&lt;/h4&gt;

&lt;p&gt;BeanUtils包提供了一系列API和设计模式来解决数据类型转换问题。&lt;/p&gt;

&lt;p&gt;看下面的例子：&lt;/p&gt;

&lt;p&gt;```
HttpServletRequest request = ...;
MyBean bean = ...;&lt;/p&gt;

&lt;p&gt;BeanUtils.populate(bean, request.getParameterMap());
```&lt;/p&gt;

&lt;p&gt;&lt;code&gt;BeanUtils&lt;/code&gt;是依赖&lt;code&gt;ConvertUtils&lt;/code&gt;提供的方法进行数据转换的，&lt;code&gt;ConvertUtils&lt;/code&gt;不推荐直接使用，因为以后的版本中可能会被废弃。&lt;/p&gt;

&lt;p&gt;你也可以定制自己的转换器，方法很简单，两个步骤：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;实现&lt;code&gt;Converter&lt;/code&gt;接口，在其中的&lt;code&gt;convert&lt;/code&gt;方法中实现你的转换规则&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;ConvertUtils.register()&lt;/code&gt;方法注册你自己的转换器&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;举一个简单的例子：&lt;/p&gt;

&lt;p&gt;```
public class Person{&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private Date birthday; 
public Date getBirthday() {  
    return birthday;  
}  
public void setBirthday(Date birthday) {  
    this.birthday = birthday;  
}  

...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;//
DateConverter dc = new DateConverter();
dc.setPattern(&quot;yyyy-mm-dd&quot;);
ConvertUtils.register(dc, java.util.Date.class);&lt;/p&gt;

&lt;p&gt;//
Person person = new Person();
String bd = &quot;2014-01-15&quot;;
BeanUtils.setProperty(person, &quot;birthday&quot;, bd);
```&lt;/p&gt;

&lt;p&gt;在上面的例子中，如果不定制转换器，那么生日的属性设置会报错。&lt;/p&gt;

&lt;h4&gt;3.4 集合&lt;/h4&gt;

&lt;p&gt;与&lt;code&gt;Apache Commons Collections&lt;/code&gt;包配合，去实现一些对集合的操作。比如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;根据集合中bean的某个属性值，对集合中得bean进行排序&lt;/p&gt;

&lt;p&gt;  看代码：&lt;/p&gt;

&lt;p&gt;  &lt;code&gt;
  Collections.sort(peopleCollection, new BeanComparator(&quot;firstName&quot;));
 &lt;/code&gt;
  上面代码，会根据bean中&lt;code&gt;firstName&lt;/code&gt;属性对集合&lt;code&gt;peopleCollection&lt;/code&gt;进行排序。&lt;/p&gt;

&lt;p&gt;  &lt;code&gt;
  Collections.sort(peopleCollection, new BeanComparator(&quot;firstName&quot;, new ReverseComparator(new ComparableComparator())));
 &lt;/code&gt;
  上面代码是做逆序。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改集合中Bean的某属性值&lt;/p&gt;

&lt;p&gt;  看代码：&lt;/p&gt;

&lt;p&gt;  ```
  // create the closure
  BeanPropertyValueChangeClosure closure =
       new BeanPropertyValueChangeClosure( &quot;activeEmployee&quot;, Boolean.TRUE );&lt;/p&gt;

&lt;p&gt;  // update the Collection
  CollectionUtils.forAllDo( peopleCollection, closure );
  &lt;code&gt;``
  上面代码，会将集合&lt;/code&gt;peopleCollection&lt;code&gt;内所有bean的属性&lt;/code&gt;activeEmployee&lt;code&gt;都设置为&lt;/code&gt;Boolean.TRUE`.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过Bean中某属性值是否相等来对集合进行过滤&lt;/p&gt;

&lt;p&gt;  看代码：&lt;/p&gt;

&lt;p&gt;  ```
  // create the predicate
  BeanPropertyValueEqualsPredicate predicate =
       new BeanPropertyValueEqualsPredicate( &quot;activeEmployee&quot;, Boolean.FALSE );&lt;/p&gt;

&lt;p&gt;  // filter the Collection
  CollectionUtils.filter( peopleCollection, predicate );
  &lt;code&gt;``
  上面代码，会将集合&lt;/code&gt;peopleCollection&lt;code&gt;中属性&lt;/code&gt;activeEmployee`不为false的bean都删除。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过Bean的属性路径来获取数据&lt;/p&gt;

&lt;p&gt;  看代码：&lt;/p&gt;

&lt;p&gt;  ```
  // create the transformer
  BeanToPropertyValueTransformer transformer = new BeanToPropertyValueTransformer( &quot;person.address.city&quot; );&lt;/p&gt;

&lt;p&gt;  // transform the Collection
  Collection peoplesCities = CollectionUtils.collect( peopleCollection, transformer );
  &lt;code&gt;``
  上面代码，会将集合&lt;/code&gt;peopleCollection&lt;code&gt;中所有bean的&lt;/code&gt;person.address.city&lt;code&gt;属性值都收集到集合&lt;/code&gt;peoplesCities`中去。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Nginx配置及应用场景之lua</title>
   <link href="http://www.blogways.net/blog/2013/10/23/nginx-4.html"/>
   <updated>2013-10-23T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/10/23/nginx-4</id>
   <content type="html">&lt;h2&gt;一、说明&lt;/h2&gt;

&lt;p&gt;这里不对lua语言本身及其编译器运行环境等做介绍，以下所有介绍前提对lua相关有所了解。&lt;/p&gt;

&lt;h2&gt;二、ngx_lua介绍&lt;/h2&gt;

&lt;h3&gt;原理&lt;/h3&gt;

&lt;p&gt;ngx_lua将Lua嵌入Nginx，可以让Nginx执行Lua脚本，并且高并发、非阻塞的处理各种请求。Lua内建协程，这样就可以很好的将异步回调转换成顺序调用的形式。ngx_lua在Lua中进行的IO操作都会委托给Nginx的事件模型，从而实现非阻塞调用。开发者可以采用串行的方式编写程序，ngx_lua会自动的在进行阻塞的IO操作时中断，保存上下文；然后将IO操作委托给Nginx事件处理机制，在IO操作完成后，ngx_lua会恢复上下文，程序继续执行，这些操作都是对用户程序透明的。&lt;/p&gt;

&lt;p&gt;每个NginxWorker进程持有一个Lua解释器或者LuaJIT实例，被这个Worker处理的所有请求共享这个实例。每个请求的Context会被Lua轻量级的协程分割，从而保证各个请求是独立的。&lt;/p&gt;

&lt;p&gt;ngx_lua采用“one-coroutine-per-request”的处理模型，对于每个用户请求，ngx_lua会唤醒一个协程用于执行用户代码处理请求，当请求处理完成这个协程会被销毁。每个协程都有一个独立的全局环境（变量空间），继承于全局共享的、只读的“comman data”。所以，被用户代码注入全局空间的任何变量都不会影响其他请求的处理，并且这些变量在请求处理完成后会被释放，这样就保证所有的用户代码都运行在一个“sandbox”（沙箱），这个沙箱与请求具有相同的生命周期。&lt;/p&gt;

&lt;p&gt;得益于Lua协程的支持，ngx_lua在处理10000个并发请求时只需要很少的内存。根据测试，ngx_lua处理每个请求只需要2KB的内存，如果使用LuaJIT则会更少。所以ngx_lua非常适合用于实现可扩展的、高并发的服务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;协程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;协程类似一种多线程，与多线程的区别有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;协程并非os线程，所以创建、切换开销比线程相对要小。&lt;/li&gt;
&lt;li&gt;协程与线程一样有自己的栈、局部变量等，但是协程的栈是在用户进程空间模拟的，所以创建、切换开销很小。&lt;/li&gt;
&lt;li&gt;多线程程序是多个线程并发执行，也就是说在一瞬间有多个控制流在执行。而协程强调的是一种多个协程间协作的关系，只有当一个协程主动放弃执行权，另一个协程才能获得执行权，所以在某一瞬间，多个协程间只有一个在运行。&lt;/li&gt;
&lt;li&gt;由于多个协程时只有一个在运行，所以对于临界区的访问不需要加锁，而多线程的情况则必须加锁。&lt;/li&gt;
&lt;li&gt;多线程程序由于有多个控制流，所以程序的行为不可控，而多个协程的执行是由开发者定义的所以是可控的。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Nginx的每个Worker进程都是在epoll或kqueue这样的事件模型之上，封装成协程，每个请求都有一个协程进行处理。这正好与Lua内建协程的模型是一致的，所以即使ngx_lua需要执行Lua，相对C有一定的开销，但依然能保证高并发能力。&lt;/p&gt;

&lt;h2&gt;二、ngx_lua安装&lt;/h2&gt;

&lt;p&gt;Nginx中安装ngx_lua需要安装LuaJIT，ngx_devel_kit，ngx_lua等安装文件，我们这里用的OpenResty，内部已经集成ngx_lua，无需再安装任何模块。&lt;/p&gt;

&lt;h2&gt;三、ngx_lua用法&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;嵌套lua脚本&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location /lua {
set $test &quot;hello, world&quot;;
content_by_lua '
    ngx.header.content_type = &quot;text/plain&quot;;
    ngx.say(ngx.var.test);
';
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$ curl 'http://134.32.28.134:8888/lua'，输出 hello, world。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;include lua文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Nginx中include lua的脚本文件方式，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; location /mytest {    
      content_by_lua_file conf/alcache.lua;       
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中在alcache.lua中编写lua脚本即可。&lt;/p&gt;

&lt;h2&gt;四、实际运用中通过lua结合分布式缓存对session的处理&lt;/h2&gt;

&lt;p&gt;这里redis与memcache的支持不是调用Nginx自带redis与memcache模块，都是调用OpenResty内部集成的第三方模块&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;nginx.conf部分配置&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location /login {    
    content_by_lua_file conf/alcache.lua;       
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;alcache.lua配置&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;local key = tostring(ngx.var.arg_username)
local val = tostring(ngx.var.arg_password)
local passLogin = tostring(ngx.var.arg_passLoginFlag)
local flags = tostring(ngx.var.arg_flags or 0)
local exptime = tostring(ngx.var.arg_exptime or 0)
local sessionId  = tostring(ngx.var.cookie_JSESSIONID)

ngx.say(&quot;sessionId:&quot;,sessionId)
ngx.say(&quot;key:&quot;,key)
ngx.say(&quot;val:&quot;,val)

if (key == nil and val == nil)  then return end
--if (passLogin == nil or sessionId == nil)  then return end

local memcached = require(&quot;resty.memcached&quot;)
--local redis = require(&quot;resty.redis&quot;) 
local cache,err = memcached:new()
--local cache,err = redis.new()

if not cache then
        ngx.say(&quot;failed to instantiate cache: &quot;,err)
        return
end


cache:set_timeout(1000)

local ok,err = cache:connect(&quot;134.32.28.134&quot;,11211)
--local ok,err = cache:connect(&quot;134.32.28.134&quot;,6379)
if not ok then
        ngx.say(&quot;failed to connect: &quot;,err)
        return
end


local res,flags,err = cache:get(key)
if err then
        ngx.say(&quot;failed to get &quot;,key,&quot; : &quot;,err)
        return
end
if res and tostring(res) ~= sessionId then
        cache:delete(key)
        cache:set(key,sessionId,exptime,flags)
else
                cache:set(key,sessionId,exptime,flags)
end


local ok, err = cache:close()  
                if not ok then  
            ngx.say(&quot;failed to close:&quot;, err)  
        return  
end

local url = ngx.var.uri  
local res = ngx.location.capture(&quot;/proxy&quot;)  
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>Nginx配置及应用场景之高级配置</title>
   <link href="http://www.blogways.net/blog/2013/10/22/nginx-3.html"/>
   <updated>2013-10-22T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/10/22/nginx-3</id>
   <content type="html">&lt;h2&gt;一、Nginx反向代理&lt;/h2&gt;

&lt;p&gt;反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器；并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。&lt;/p&gt;

&lt;p&gt;通常的代理服务器，只用于代理内部网络对Internet的连接请求，客户机必须指定代理服务器,并将本来要直接发送到Web服务器上的http请求发送到代理服务器中。当一个代理服务器能够代理外部网络上的主机，访问内部网络时，这种代理服务的方式称为反向代理服务。&lt;/p&gt;

&lt;p&gt;一个通过HttpProxy模块实现反向代理的简单配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    server {
        listen   8888;
        server_name  134.32.28.134;

        location / {
            proxy_pass http://134.32.28.134:8090;
            proxy_redirect off;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此配置实现在ie中输入http://134.32.28.134:8888即会调转到134.32.28.134:8090中&lt;/p&gt;

&lt;p&gt;Upstream模块配置实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    upstream appserver { 
         server 134.32.28.134:8090;
    }   
    server {
        listen   8888;
        server_name  134.32.28.134;

        location / {
            proxy_pass http://appserver;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HttpRewrite模块配置实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    server {
        listen   8888;
        server_name  134.32.28.134;
        rewrite  http://134.32.28.134:8090/ permanent;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;二、Nginx负载均衡&lt;/h2&gt;

&lt;p&gt;Nginx本身提供轮询（round robin）、用户IP哈希（ip_hash）和指定权重三种方式负载均衡策略，
另外也出现第三方负载均衡模块fair和url_hash，默认情况下，Nginx以轮询作为负载均衡策略。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;轮询与指定权重策略&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;简单配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    upstream appserver { 
       server 134.32.28.134:8090 weight=5;
       server 134.32.28.134:8091 weight=2;
    } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;weight是设置权重，用于后端服务器性能不均的情况。
轮询策略的缺点是某一时段内的一连串访问可能都是由同一个用户A发起的，那么第一次A的请求可能是 8090，而下一次是 8091，然后是 8090、8091…… 在大多数应用场景中，这样并不高效，并且如果后台服务器没有实现对session的共享，会导致session没有共享的。当然，也正因如此，Nginx 为你提供了一个按照IP来hash的方式，这样每个客户端的访问请求都会被甩给同一个后端服务器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IP哈希策略&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    upstream appserver { 
           ip_hash;
           server 134.32.28.134:8090;
           server 134.32.28.134:8091;
    } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种策略中，用于进行hash运算的key是客户端的IP地址。这样的方式保证一个客户端每次请求都将到达同一个后台主机。当然，如果所hash到的后台服务器当前不可用，则请求会被转移到其他服务器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;down机、重试策略及备份&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当某个一个服务器暂时性的宕机（down）时，你可以使用“down”来标示出来，并且这样被标示的 、服务器就不会接受请求去处理。如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    upstream appserver { 
       server 134.32.28.134:8090;
       server 134.32.28.134:8091 down;
    } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以为每个 backend 指定最大的重试次数，和重试时间间隔。所使用的关键字是 max_fails 和 fail_timeout。如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    upstream appserver { 
       server 134.32.28.134:8090;
       server 134.32.28.134:8091 max_fails=3 fail_timeout=30s;
    } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用“backup”关键字。当所有的非备机（non-backup）都宕机（down）或者繁忙（busy）的时候，就只使用由 backup 标注的备机。backup不能和ip_hash关键字一起使用。举例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    upstream appserver { 
       server 134.32.28.134:8090;
       server 134.32.28.134:8091;
       server 134.32.28.134:8092 backup;
    } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;fair（Nginx需安装第三方模块，OpenResty已经集成）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;fair按后端服务器的响应时间来分配请求，响应时间短的优先分配，配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    upstream appserver { 
           server 134.32.28.134:8090;
           server 134.32.28.134:8091;
           fair;
    } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;url_hash（Nginx需安装第三方模块）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;url_hash按访问URL的hash结果来分配请求，使每个URL定向到同一个后端服务器，后端服务器为缓存时比较适用。另外，在upstream中加入hash语句后，server语句不能写入weight等其他参数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    upstream appserver { 
           server 134.32.28.134:8090;
           server 134.32.28.134:8091;
           hash  $request_uri;
           hash_method  crc32;
    } 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;三、Nginx静态缓存&lt;/h2&gt;

&lt;p&gt;Nginx过Proxy Cache可以使其对静态资源进行缓存。其原理就是把静态资源按照一定的规则存在本地硬盘，并且会在内存中缓存常用的资源，从而加快静态资源的响应。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;http段设置&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;proxy_connect_timeout 600;  #nginx跟后端服务器连接超时时间(代理连接超时)
proxy_read_timeout    600;  #连接成功后，后端服务器响应时间(代理接收超时)
proxy_send_timeout    600;  #后端服务器数据回传时间(代理发送超时)
proxy_buffer_size     32k;  #设置代理服务器（nginx）保存用户头信息的缓冲区大小
proxy_buffers         4 32k;#proxy_buffers缓冲区，网页平均在32k以下的话，这样设置
proxy_busy_buffers_size  64k;           #高负荷下缓冲大小（proxy_buffers*2）
proxy_temp_file_write_size  64k;       #设定缓存文件夹大小，大于这个值，将从upstream服务器传
proxy_temp_path /home/spdev/nginx/openresty/local/nginx/proxy_temp;
proxy_cache_path /home/spdev/nginx/openresty/local/nginx/cache levels=1:2 
keys_zone=cache_one:200m inactive=1d max_size=30g;
#levels设置目录层次,keys_zone设置缓存名字和共享内存大小 
#inactive在指定时间内没人访问则被删除在这里是1天,max_size最大缓存空间
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;server段设置&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; location ~* \.(gif|jpg|png|htm|html|css|js|flv|ico|swf)$ {

     proxy_pass http://appserver;  #动态不缓存  
     proxy_redirect off;
     proxy_set_header Host $host;
     proxy_cache cache_one;
     proxy_cache_valid 200 302 1h;  #哪些状态缓存多长时间
     proxy_cache_valid 301 1d;
     proxy_cache_valid any 1m;      #其他的缓存多长时间   
     expires 30d;   #置失期时间，为30天
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;四、IP并发限制、带宽限制&lt;/h2&gt;

&lt;p&gt;nginx可以通过HttpLimitReqModul和HttpLimitZoneModule配置来限制ip在同一时间段的访问次数来防cc攻击。
HttpLimitReqModul用来限制连单位时间内连接数的模块，使用limit_req_zone和limit_req指令配合使用来达到限制。
一旦并发连接超过指定数量，就会返回503错误。HttpLimitConnModul用来限制单个ip的并发连接数，使用limit_zone和limit_conn指令这两个模块的区别前一个是对一段时间内的连接数限制，后者是对同一时刻的连接数限制。&lt;/p&gt;

&lt;h3&gt;设置HttpLimitReqModul限制某一段时间内同一ip访问数&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;http段设置&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #限制同一ip每秒访问20次
    limit_req_zone $binary_remote_addr zone=allips:10m rate=20r/s;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里定义一个名为allips的limit_req_zone用来存储session，大小是10M内存，以$binary_remote_addr 为key,限制平均每秒的请求为20个，1M能存储16000个状态，rate的值必须为整数，如果限制两秒钟一个请求，可以设置成30r/m。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;server段设置&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    limit_req zone=allips burst=5 nodelay;
    #brust的意思就是，如果第1秒、2,3,4秒请求为19个，第5秒的请求为25个是被允许的。
    #但是如果你第1秒就25个请求后面的5个请求就会被限制，返回503错误。
    #nodelay，如果不设置该选项，严格使用平均速率限制请求数，
    #也就是说如果你设置rate=120r/m,相当于每秒只允许处理2个请求
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;设置HttpLimitZoneModule 限制并发连接数&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;http段设置&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #ip限制并发数
    limit_conn_zone  $binary_remote_addr zone=addr:10m;

    #服务器限制并发总数
    limit_conn_zone $server_name zone=perserver:10m;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;server段设置&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #连接数限制
    limit_conn addr 10;  

    limit_conn perserver 50000;

    #连接限速
    limit_rate 500k;   

    #限制ip
    allow 132.35.75.0/24;
    #deny all;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中allow、deny是HTTP Access模块对应的指令，以下需注意：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1、deny 一定要加一个ip，否则直接跳转到403,不往下执行了;如果403默认页是
   同一域名下，会造成死循环访问；

2、allow的ip段从允许访问的段位从小到大排列,如127.0.0.0/24 下面才能是
   10.10.0.0/16
   24表示子网掩码:255.255.255.0
   16表示子网掩码:255.255.0.0
   8表示子网掩码:255.0.0.0；

3、deny all;结尾 表示除了上面allow的其他都禁止
   如：
         deny 192.168.1.1;
         allow 127.0.0.0/24;
         allo w 192.168.0.0/16;
         allow 10.10.0.0/16;
         deny all;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;五、第三方合并静态文件模块的使用&lt;/h2&gt;

&lt;p&gt;这里介绍的是淘宝开发的nginx_concat_module针对nginx的文件合并模块，主要用于合并前端代码减少http请求数。对于此模块的安装前面已经有过说明，这里不再详细解说。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;nginx_concat_module模块配置&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # nginx_concat_module 主开关
    concat on;

    # 最大合并文件数
    concat_max_files 10;

    # 只允许同类型文件合并
    concat_unique on;

    # 允许合并的文件类型，多个以逗号分隔。如：application/x-javascript, text/css
    concat_types text/html;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;举例如：&lt;/p&gt;

&lt;p&gt;http://主机地址/test/??1.css,2.css,3.css…10.css，这里会将1.css，2.css...10.css 是个css文件合并为一个文件从而只需一次请求。&lt;/p&gt;

&lt;h2&gt;六、实际应用中配置实例&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;nginx.conf部分配置&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    include  common.conf;
    include  proxy_cache.conf;
    #设定负载均衡的服务器列表
    upstream appserver { 
           server 134.32.28.134:8090 weight=5;
           server 134.32.28.134:8091 weight=2;
    } 

    include limit_common.conf;
    # server虚拟主机配置                                                  
    server {
        listen       8888;
        server_name  134.32.28.134;


        #设置网页的默认编码格式
        #charset utf8;      

            #根据访问域名生成对应的访问日志
        access_log  logs/host.access.log  main;     

        lua_code_cache on;                      



        location / {                
            proxy_pass http://appserver;                                
            include user_agent.conf;
            include limit_info.conf;
        }

        location /mytest {    
            content_by_lua_file conf/alcache.lua;       
        }

        location /proxy {    
                include user_agent.conf;                                        
            include limit_info.conf;
            proxy_pass http://appserver$uri;    
        }


        #静态文件缓存
        location ~* \.(gif|jpg|png|htm|html|css|js|flv|ico|swf)$ {

             #防盗链
                 #valid_referers none blocked 134.32.28.134;
                     #if ($invalid_referer) {
                            #return 403;
                     #}

             proxy_pass http://appserver;
             proxy_redirect off;
             proxy_set_header Host $host;
             proxy_cache cache_one;
             proxy_cache_valid 200 302 1h;
             proxy_cache_valid 301 1d;
             proxy_cache_valid any 1m;
             expires 30d;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此处nginx.conf中include了limit_common.conf、user_agent.conf、limit_info.conf与proxy_cache.conf，其中user_agent.conf中配置了客户端信息判断及文件合并等信息，limit_common.conf配置了ip限制相关公用信息，limit_info.conf配置了实际server中限制要求，proxy_cache.conf中配置了静态缓存相关信息，其中静态文件缓存部分为server运用中的配置。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;user_agent.conf配置&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#客户端判断
#if ($http_user_agent ~* &quot;MSIE&quot;) { proxy_pass http://appserver; }
if ($http_user_agent ~* &quot;Nokia&quot;) { rewrite . /404.html break; }
if ($http_user_agent ~* &quot;Mobile&quot;) { rewrite . /404.html break; }
if ($http_user_agent ~* &quot;SAMSUNG&quot;) { rewrite . /404.html break; }
if ($http_user_agent ~* &quot;SonyEricsson&quot;) { rewrite . /404.html break; }
if ($http_user_agent ~* &quot;MOT&quot;) { rewrite . /404.html break; }
if ($http_user_agent ~* &quot;BlackBerry&quot;) { rewrite . /404.html break; }
if ($http_user_agent ~* &quot;LG&quot;) { rewrite . /404.html break; }
if ($http_user_agent ~* &quot;HTC&quot;) { rewrite . /404.html break; }
if ($http_user_agent ~* &quot;J2ME&quot;) { rewrite . /404.html break; }
if ($http_user_agent ~* &quot;Opera Mini&quot;) { rewrite . /404.html break; }
if ($http_user_agent ~* &quot;ipad&quot;) { proxy_pass http://appserver; }
if ($http_user_agent ~* &quot;iphone&quot;) { proxy_pass http://appserver; }
if ($http_user_agent ~* &quot;android&quot;) { proxy_pass http://appserver; }

#只允许访问get、head、post方法
if ($request_method !~* ^(GET|HEAD|POST)$ ) {
        return 403;
}

#js、css文件合并
concat on;
#concat_max_files 10;
#只允许同类型文件合并
#concat_unique on;
#允许合并的文件类型，多个以逗号分隔。如：application/x-javascript, text/css
#concat_types text/html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;limit_common.conf配置&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#限制同一ip每秒访问20次
limit_req_zone $binary_remote_addr zone=allips:10m rate=20r/s;
#ip限制并发数
limit_conn_zone  $binary_remote_addr zone=addr:10m;

#服务器限制并发总数
limit_conn_zone $server_name zone=perserver:10m;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;limit_info.conf配置&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#brust的意思就是，如果第1秒、2,3,4秒请求为19个，第5秒的请求为25个是被允许的。
#但是如果你第1秒就25个请求后面的5个请求就会被限制，返回503错误。
#nodelay，如果不设置该选项，严格使用平均速率限制请求数，
#也就是说如果你设置rate=120r/m,相当于每秒只允许处理2个请求

limit_req zone=allips burst=5 nodelay;

#连接数限制
limit_conn addr 10;  

limit_conn perserver 50000;

#连接限速
limit_rate 500k;   

#限制ip
allow 132.35.75.0/24;
#deny all;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;proxy_cache.conf配置&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;proxy_connect_timeout 5;
proxy_read_timeout 60;
proxy_send_timeout 5;
proxy_buffer_size 16k;
proxy_buffers 4 64k;
proxy_busy_buffers_size 128k;
proxy_temp_file_write_size 128k;
proxy_temp_path /home/spdev/nginx/openresty/local/nginx/proxy_temp;
proxy_cache_path /home/spdev/nginx/openresty/local/nginx/cache levels=1:2 
keys_zone=cache_one:200m inactive=1d max_size=30g;
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>Nginx配置及应用场景之基本配置</title>
   <link href="http://www.blogways.net/blog/2013/10/21/nginx-2.html"/>
   <updated>2013-10-21T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/10/21/nginx-2</id>
   <content type="html">&lt;h3&gt;一、nginx.conf配置说明&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;主模块常用指令&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;daemon&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 含义：设置是否以守护进程模式运行
 语法：daemon on|off
 缺省：on
 示例：daemon off
 注意：生产环境（production mode）中不要使用daemon指令，这些选项仅
 用于开发测试（development mode）。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;debug_points&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 含义：断点调试
 语法：debug_points [stop|abort]
 缺省：none
 示例：debug_points stop;
 注意：在Nginx内有一些assert断言，这些断言允许Nginx，配合调试器中断程序运行、
 停止或创建core文件。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;master_process&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 含义：设置是否启用主进程
 语法：master_process on|off
 缺省：on
 示例：master_process off;
 注意：
 不要在生产环境（production mode）中使用master_process指令，
 这些选项仅用于开发测试（development mode）。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;error_log&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 含义：指定错误日志文件
 语法：error_log file [debug|info|notice|warn|error|crit]
 缺省：${prefix}/logs/error.log
 示例：
 error_log /data/nginx/logs/error.log debug
 注意：   
 该命令并非只有在测试（或称为开发）模式下才可以使用，而是在编译时添加了--with-debug参数时，
 则可以使用error_log指令的额外参数，即：
 error_log file [debug_core|debug_alloc|debug_mutex|debug_event|
 debug_http|debug_imap];
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;include&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;含义：指定所要包含的Nginx配置文件

语法：include &amp;lt;file|*&amp;gt;
缺省：none
示例：include vhosts/*.conf 或 include /home/michael/nginx/conf/nginx-main.conf
注意：
（1）include命令可以指定包含一个文件，比如第二个示例。也可以指定包含一个目录下的所有文件，
    比如第一个示例。    
（2）指定的文件路径的基路径，由编译选项--prefix决定，如果编译时没有指定，
    则默认的路径是/usr/local/nginx。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;pid&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 含义：指定存储进程ID（即PID）的文件。
 语法：pid &amp;lt;file&amp;gt;
 缺省：compile-time option Example
 示例：pid /var/log/nginx.pid;
 注意：可以使用命令kill -HUP cat /var/log/nginx.pid\ 对Nginx进行进程ID文件的重新加载。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;user&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 含义：指定可以使用Nginx的用户   
 语法：user &amp;lt;user&amp;gt; [group]    
 缺省：nobody nobody（第一个nobody是user，第二个nobody是group）    
 示例：user spd spdev;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;worker_processes&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 含义：指定worker进程数
 语法：worker_processes &amp;lt;number&amp;gt;  
 缺省：1      
 示例：worker_processes 4;    
 注意：最大用户连接数=worker进程数×worker连接数，
      即max_clients=worker_processes*worker_connections。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;worker_cpu_affinity&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 含义：为worker进程绑定CPU。        
 语法：worker_cpu_affinity cpumask [cpumask...]       
 缺省：none
 示例：
 （1）如果有4个CPU，并且指定4个worker进程，则：
     worker_processes 4;
     worker_cpu_affinity 0001 0010 0100 1000;
 （2）如果有4个CPU，并且指定2个worker进程，则：
     worker_processes 2;
     worker_cpu_affinity 0101 1010;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 注意：只有Linux平台上才可以使用该指令。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;worker_rlimit_nofile&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;含义：worker进程的file descriptor可以打开的最大文件数，最好与与ulimit -n的值保持一致。
语法：worker_rlimit_nofile &amp;lt;number&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;事件模块(events)常用指令&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;use&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;语法：use [kqueue | rtsig | epoll | /dev/poll | select | poll | eventport];
注意：如果在./configure的时候指定了不止一种事件模型，那么可以设置其中一个，告诉Nginx使用
哪种事件模型。默认情况下，Nginx会在./configure时找出最适合系统的事件模型。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;worker_connections&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;语法：worker_connection &amp;lt;number&amp;gt;;
最大连接数的计算公式如下： 
max_clients = worker_processes * worker_connections;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt; accept_mutex&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;含义：设置是否使用连接互斥锁进行顺序的accept()系统调用。
语法：accept_mutex &amp;lt;on|off&amp;gt;;
缺省：on
示例：accept_mutex off;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;accept_mutex_delay&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;含义：设置获得互斥锁的最少延迟时间。  
语法：accpet_mutex_delay &amp;lt;number of millisecs&amp;gt;       
缺省：500ms      
示例：accpet_mutex_delay 1000ms;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;debug_connection&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;含义：设置指定的clients产生debug日志。     
语法：debug_connection [ip|CIDR];    
缺省：none       
示例：debug_connection 172.16.44.96; 
一段较完整的事件模块代码如下：   
error_log /data/nginx/log/error.log;
events {    
    debug_connection172.16.44.96;   
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;HTTP模块常用指令&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;alias&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;含义：指定location使用的路径，与root类似，但不改变文件的跟路径，仅适用文件系统的路径。
语法：alias &amp;lt;file-path | directory-path&amp;gt;     
缺省：N/A        
作用域：http.server.location    
示例：       
location /i/ {
    alias /home/michael/web/i/;     
}       
则请求 /i/logo.png 则返回 /home/michael/web/i/logo.png。 
注意：   
（1）替换路径时，可以使用变量。  
（2）alias无法在正则的location中使用。如果有这种需求，则必须使用rewrite和root。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;client_body_in_file_only&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;含义：指定是否将用户请求体存储到一个文件里。  
语法：client_body_in_file_only &amp;lt;on | off&amp;gt;    
缺省：off    
作用域：http.server.location        
示例：client_body_in_file_only on;   
注意：   
（1）该指令为on时，用户的请求体会被存储到一个文件中，但是请求结束后，该文件也不会被删除；
（2）该指令一般在调试的时候使用。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;client_body_buffer_size&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;含义：指定用户请求体所使用的buffer的最大值
语法：client_body_buffer_size &amp;lt;size&amp;gt; 
缺省：两个page的大小，一般为8k或16k    
作用域：http.server.location    
示例：client_body_buffer_size 512k;  
注意：如果用户请求体超过了buffer的大小，则将全部内容或部分内容存储到一个临时文件中。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;client_body_temp_path&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;含义：设置存储用户请求体的文件的目录路径
语法：client_body_temp_path &amp;lt;directory path&amp;gt; [level1 | level2 | level3]      
作用域：http.server.location        
示例：client_body_temp_path /spool/nginx/client_temp 1 2;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;client_body_timeout&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;含义：设置用户请求体的超时时间。
语法：client_body_timeout &amp;lt;time&amp;gt; 
作用域：http.server.location        
示例：client_body_timeout 120s;  
注意：只有请求体需要被1次以上读取时，该超时时间才会被设置。且如果这个时间后用户什么都没发，
nginx会返回requests time out 408.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;client_header_buffer_size&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;含义：设置用户请求头所使用的buffer大小  
语法：client_header_buffer_size &amp;lt;size&amp;gt;       
缺省：1k     
作用域：http.server     
示例：client_header_buffer_size 2k;  
注意：
（1）对绝大多数请求来说，1k足以满足请求头所需的buffer；      
（2）对于携带有较大cookie或来自于wap用户的请求头来说，1k的buffer一般不够，这时可以使用指令
    large_client_header_buffers。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;client_header_timeout&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;含义：设置用户请求头的超时时间。
语法：client_header_timeout &amp;lt;time&amp;gt;       
缺省：1m     
作用域：http.server.location        
示例：client_header_timeout 3m;      
注意：只有请求头需要被1次以上读取时，该超时时间才会被设置。且如果这个时间后用户什么都没发，
     nginx会返回requests time out 408.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;client_max_body_size&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;含义：设置所能接收的最大请求体的大小
语法：client_max_body_size &amp;lt;size&amp;gt;        
缺省：1m 
作用域：http.server.location    
示例：client_max_body_size 2m;       
注意：根据请求头中的Content-Length来判断请求体大小是否允许。如果大于设定值，则返回
“ Request Entity Too Large”(413)错误。不过要注意的是，浏览器一般并不对这个错误进行特殊显示。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;send_timeout&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;含义：指定响应客户端的超时时间,单位：秒，默认值为60
语法：send_timeout &amp;lt;time&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;keepalive_timeout&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;含义：保持连接时间，单位:秒,超过该时间，服务器会关闭连接
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;tcp_nopush&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;含义：用于控制TCP链接是否推送，默认值是on
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;tcp_nodelay&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;含义：用于控制TCP链接是否延迟，默认值是on,将tcp_nopush和tcp_nodelay两个
     指令设置为on用于防止网络阻塞  
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;HTTP模块Location相关指令&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;基本语法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;语法：location [= | ~ | ~* | ^~] &amp;lt;/uri/&amp;gt; {...}   
缺省：N/A
作用域：server
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;匹配规则&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 四种匹配方式
   = 精确匹配   
   ~ 大小写敏感正则匹配
   ~* 大小写不敏感正则匹配    
   ^~ 前缀匹配

2. location匹配指令的执行顺序  
   首先：= 精确匹配；   
   其次：^~ 前缀匹配；      
   再次：~* 和 ~ 正则匹配，顺序依据出现顺序；
   最后：如果出现正则匹配成功，则采用该正则匹配；如果无可匹配正则，
   则采用前缀匹配结果。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        location  = / { # 只匹配&quot;/&quot;.}
        location  / {# 匹配任何请求，因为所有请求都是以&quot;/&quot;开始
                 # 但是更长字符匹配或者正则表达式匹配会优先匹配
                    }

        location ^~ /images/ {
                # 匹配任何以 /images/ 开始的请求，并停止匹配
                  其它location
            }

         location ~* \.(gif|jpg|jpeg)$ {
          # 匹配以 gif, jpg, or jpeg结尾的请求. 
          # 但是所有 /images/ 目录的请求将由上面localtion处理.  
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;压缩（gzip）模块相关指令&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;gzip(GNU-ZIP)是一种压缩技术。经过gzip压缩后页面大小可以变为原来的30%甚至更小，这样，
用户浏览页面的时候速度会块得多。gzip的压缩页面需要浏览器和服务器双方都支持，实际上就
是服务器端压缩，传到浏览器后浏览器解压并解析。浏览器那里不需要我们担心，因为目前的巨
大多数浏览器都支持解析gzip过的页面。Nginx的压缩输出有一组gzip压缩指令来实现。相关指
令位于http{….}两个大括号之间。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;gzip on&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;该指令用于开启或关闭gzip模块(on/off)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;gzip_min_length 1k
    设置允许压缩的页面最小字节数，页面字节数从header头得content-length中进行获取。
    默认值是0，不管页面多大都压缩。建议设置成大于1k的字节数，小于1k可能会越压越大。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;gzip_buffers 4 16k
    设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。4 16k代表以16k为单位，
    安装原始数据大小以16k为单位的4倍申请内存。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;gzip_http_version 1.1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;识别http的协议版本(1.0/1.1)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;gzip_comp_level 2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gzip压缩比，1压缩比最小处理速度最快，9压缩比最大但处理速度最慢(传输快但比较消耗cpu)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;gzip_types text/plain application/x-javascript text/css application/xml&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;匹配mime类型进行压缩，无论是否指定,”text/html”类型总是会被压缩的。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;gzip_vary on&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;和http头有关系，加个vary头，给代理服务器用的，有的浏览器支持压缩，有的不支持，
所以避免浪费不支持的也压缩，所以根据客户端的HTTP头来判断，是否需要压缩
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;gzip_disable &quot;MSIE [1-6].&quot;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;指定版本浏览器不压缩 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;二、实际应用中配置实例&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;nginx.conf部分配置&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    #user  nobody;
    worker_processes  48;
    worker_rlimit_nofile 1024;                                  
    error_log  logs/error.log  notice;
    #pid        logs/nginx.pid;
    events {
        use epoll;
        worker_connections  1024;
    }

    # HTTP服务配置
    http {

        include  common.conf;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此处nginx.conf中include了common.conf，其中common.conf中配置了http模块中公用信息&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;common.conf部分配置&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    include       mime.types;
    default_type  application/octet-stream;     
    log_format  main  '|$remote_addr|- |$http_cookie| - |$remote_user| [$time_local]| '
                      '&quot;$request&quot; |$status| $body_bytes_sent| &quot;$http_referer&quot;| '
                      '|&quot;$http_user_agent&quot;| |&quot;$http_x_forwarded_for&quot;|';
    #access_log  off
    access_log  logs/access.log  main buffer=32K;   
    server_tokens off;
    client_max_body_size  20m;                                                          
    client_header_buffer_size    32K;                                                   
    large_client_header_buffers  4 32K;                                                 
    sendfile        on;                                                                 
    tcp_nopush     on;                                                                  
    tcp_nodelay     on;                                 
    client_header_timeout  30;                                                          
    client_body_timeout    30;                                                          
    send_timeout          30;
    keepalive_timeout  65;                                                              
    # HttpGzip模块配置
    include  gzip.conf;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此处common.conf中include了gzip.conf，其中gzip.conf中配置了HttpGzip模块中公用信息&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;其中gzip.conf部分配置&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # HttpGzip模块配置，这个模块支持在线实时压缩输出数据流
    gzip  on;
    gzip_min_length  1k;
    gzip_proxied     any;
    gzip_buffers     4    16k;
    gzip_http_version    1.1;
    gzip_comp_level    1;
    gzip_types   text/plain application/x-javascript text/css application/xml;
    gzip_vary    on;
    gzip_disable &quot;MSIE [1-6]\.&quot;;  
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>Nginx服务器介绍及扩展</title>
   <link href="http://www.blogways.net/blog/2013/10/18/nginx-1.html"/>
   <updated>2013-10-18T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/10/18/nginx-1</id>
   <content type="html">&lt;h2&gt;一、概述&lt;/h2&gt;

&lt;h3&gt;架构&lt;/h3&gt;

&lt;p&gt;nginx在启动后，在unix系统中会以daemon的方式在后台运行，后台进程包含一个master进程和多个worker进程。我们也可以手动地关掉后台模式，让nginx在前台运行，nginx是以多进程的方式来工作的，当然nginx也是支持多线程的方式的，只是我们主流的方式还是多进程的方式。&lt;/p&gt;

&lt;p&gt;nginx在启动后，会有一个master进程和多个worker进程。master进程主要用来管理worker进程，包含：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。而基本的网络事件，则是放在worker进程中来处理了。多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。worker进程的个数是可以设置的，一般我们会设置与机器cpu核数一致，这里面的原因与nginx的进程模型以及事件处理模型是分不开的。nginx的进程模型，可以由下图来表示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chapter-2-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;基本概念&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;connection&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在nginx中connection就是对tcp连接的封装，其中包括连接的socket，读事件，写事件。利用nginx封装的connection，我们可以很方便的使用nginx来处理与连接相关的事情，比如，建立连接，发送与接受数据等。而nginx中的http请求的处理就是建立在connection之上的，所以nginx不仅可以作为一个web服务器，也可以作为邮件服务器。当然，利用nginx提供的connection，我们可以与任何后端服务打交道。&lt;/p&gt;

&lt;p&gt;在nginx中，每个进程会有一个连接数的最大上限，这个上限与系统对fd的限制不一样。在操作系统中，通过ulimit -n，我们可以得到一个进程所能够打开的fd的最大数，即nofile，因为每个socket连接会占用掉一个fd，所以这也会限制我们进程的最大连接数，当然也会直接影响到我们程序所能支持的最大并发数，当fd用完后，再创建socket时，就会失败。不过，这里我要说的nginx对连接数的限制，与nofile没有直接关系，可以大于nofile，也可以小于nofile。nginx通过设置worker_connectons来设置每个进程可使用的连接最大值。nginx在实现时，是通过一个连接池来管理的，每个worker进程都有一个独立的连接池，连接池的大小是worker_connections。这里的连接池里面保存的其实不是真实的连接，它只是一个worker_connections大小的一个ngx_connection_t结构的数组。并且，nginx会通过一个链表free_connections来保存所有的空闲ngx_connection_t，每次获取一个连接时，就从空闲连接链表中获取一个，用完后，再放回空闲连接链表里面。&lt;/p&gt;

&lt;p&gt;一个nginx能建立的最大连接数，应该是worker_connections * worker_processes。这里说的是最大连接数，对于HTTP请求本地资源来说，能够支持的最大并发数量是worker_connections * worker_processes，而如果是HTTP作为反向代理来说，最大并发数量应该是worker_connections * worker_processes/2。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;request&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;request具体到nginx中的数据结构是ngx_http_request_t。ngx_http_request_t是对一个http请求的封装。以下为nginx一个http请求的生命周期图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chapter-2-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;Nginx指令&lt;/h3&gt;

&lt;p&gt;nginx的配置系统由一个主配置文件和其他一些辅助的配置文件构成。这些配置文件均是纯文本文件，全部位于nginx安装目录下的conf目录下。配置文件中以#开始的行，或者是前面有若干空格或者TAB，然后再跟#的行，都被认为是注释，也就是只对编辑查看文件的用户有意义，程序在读取这些注释行的时候，其实际的内容是被忽略的。在nginx.conf中，包含若干配置项。每个配置项由配置指令和指令参数2个部分构成。指令参数也就是配置指令对应的配置值。&lt;/p&gt;

&lt;p&gt;配置指令是一个字符串，可以用单引号或者双引号括起来，也可以不括。但是如果配置指令包含空格，一定要引起来。指令的参数使用一个或者多个空格或者TAB字符与指令分开。指令的参数有一个或者多个TOKEN串组成。TOKEN串之间由空格或者TAB键分隔。TOKEN串分为简单字符串或者是复合配置块。复合配置块即是由大括号括起来的一堆内容。一个复合配置块中可能包含若干其他的配置指令。&lt;/p&gt;

&lt;p&gt;如果一个配置指令的参数全部由简单字符串构成，也就是不包含复合配置块，那么我们就说这个配置指令是一个简单配置项，否则称之为复杂配置项。例如下面这个是一个简单配置项：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error_page   500 502 503 504  /50x.html;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于简单配置，配置项的结尾使用分号结束。对于复杂配置项，包含多个TOKEN串的，一般都是简单TOKEN串放在前面，复合配置块一般位于最后，而且其结尾，并不需要再添加分号。例如下面这个复杂配置项&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location / {
    root   /home/jizhao/nginx-book/build/html;
    index  index.html index.htm;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Nginx模块概述&lt;/h3&gt;

&lt;p&gt;nginx的内部结构是由核心部分和一系列的功能模块所组成。这样划分是为了使得每个模块的功能相对简单，便于开发，同时也便于对系统进行功能扩展。nginx将各功能模块组织成一条链，当有请求到达的时候，请求依次经过这条链上的部分或者全部模块，进行处理。每个模块实现特定的功能。例如，实现对请求解压缩的模块，实现SSI的模块，实现与上游服务器进行通讯的模块。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;模块分类&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;nginx的模块根据其功能基本上可以分为以下几种类型：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;event module&lt;/strong&gt;: 搭建了独立于操作系统的事件处理机制的框架，及提供了各具体事件的处理。包括ngx_events_module， ngx_event_core_module和ngx_epoll_module等。nginx具体使用何种事件处理模块，这依赖于具体的操作系统和编译选项。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;phase handler&lt;/strong&gt;: 此类型的模块也被直接称为handler模块。主要负责处理客户端请求并产生待响应内容，比如ngx_http_static_module模块，负责客户端的静态页面请求处理并将对应的磁盘文件准备为响应内容输出。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;output filter&lt;/strong&gt;: 也称为filter模块，主要是负责对输出的内容进行处理，可以对输出进行修改。例如，可以实现对输出的所有html页面增加预定义的footbar一类的工作，或者对输出的图片的URL进行替换之类的工作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;upstream&lt;/strong&gt;: upstream模块实现反向代理的功能，将真正的请求转发到后端服务器上，并从后端服务器上读取响应，发回客户端。upstream模块是一种特殊的handler，只不过响应内容不是真正有自己产生的，而是从后端服务器上读取的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;load-balancer&lt;/strong&gt;: 负载均衡模块，实现特定的算法，在众多的后端服务器中，选择一个服务器出来作为某个请求的转发服务器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;handler模块&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Handler模块就是接受来自客户端的请求并产生输出的模块，目前第三方开发模块最可能开发的就是三种类型的模块，即handler，filter和load-balancer。&lt;/p&gt;

&lt;h2&gt;二、OpenResty介绍及安装&lt;/h2&gt;

&lt;h3&gt;OpenResty介绍&lt;/h3&gt;

&lt;p&gt;OpenResty （也称为 ngx_openresty）是一个全功能的 Web 应用服务器，它打包了标准的 Nginx 核心，很多的常用的第三方模块，以及它们的大多数依赖项。OpenResty
通过汇聚各种设计精良的 Nginx 模块。从而将 Nginx 有效的变成一个强大的 Web 应用服务器,这样, Web 开发人员可以使用 Lua 脚本语言调动 Nginx 支持的各种C以及Lua 模块。
OpenResty 的目标是让你的Web服务直接跑在 Nginx 服务内部,充分利用 Nginx 的非阻塞 I/O 模型,不仅仅对 HTTP 客户端请求,甚至于对远程后端诸如MySQL,PostgreSQL,
Memcache 以及 ~Redis 等都进行一致的高性能响应。&lt;/p&gt;

&lt;h3&gt;OpenResty安装&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;1、下载OpenResty http://openresty.org/download/ngx_openresty-1.4.2.8.tar.gz

2、解压openresty   gunzip -c ngx_openresty-1.4.2.8.tar.gz | tar xvf -

3、./configure \
  --prefix=/home/spdev/nginx/openresty/local \
  --sbin-path=/home/spdev/nginx/openresty/sbin \
  --user=spdev\
  --group=spd\
  --with-debug \
  --with-http_dav_module \
  --with-http_ssl_module \
  --with-http_stub_status_module \
  --with-http_addition_module \
  --with-http_flv_module \
  --without-http_memcached_module \
  --without-http_redis2_module \
  --without-http_redis_module  \
  --without-lua_redis_parser  \
  --without-mail_pop3_module \
  --without-mail_imap_module \
  --without-mail_smtp_module \

  make
  make install

 其中--with是自定义安装需要模块，--without是不安装默认安装的模块。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;第三方模块安装&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;1、服务器新建目录如：/home/spdev/nginx/tb_module

2、下载第三方模块，如淘宝合并js模块
（svn checkout http://code.taobao.org/svn/nginx_concat_module/trunk/ 
 $NGINX_CONCAT_MODULE）。

3、./configure 中增加参数，--add-module=$NGINX_CONCAT_MODULE

./configure \
  --prefix=/home/spdev/nginx/openresty/local \
  --sbin-path=/home/spdev/nginx/openresty/sbin \
  --user=spdev\
  --group=spd\
  --with-debug \
  --with-http_dav_module \
  --with-http_ssl_module \
  --with-http_stub_status_module \
  --with-http_addition_module \
  --with-http_flv_module \
  --without-http_memcached_module \
  --without-http_redis2_module \
  --without-http_redis_module  \
  --without-lua_redis_parser  \
  --without-mail_pop3_module \
  --without-mail_imap_module \
  --without-mail_smtp_module \
  --add-module=/home/spdev/nginx/tb_module/$NGINX_CONCAT_MODULE \

4、make make install
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;三、Nginx简单命令&lt;/h3&gt;

&lt;p&gt;Nginx默认配置文件nginx.conf位于nginx安装目录conf目录下，执行命令需切换至对应目录。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nginx    启动Nginx
nginx -c &amp;lt;/path/to/config&amp;gt;  Nginx 指定一个配置文件，来代替缺省的。
nginx -t 不运行，仅仅测试配置文件语法的正确性。
nginx -v 显示 nginx 的版本。
nginx -V 显示 nginx 的版本，编译器版本和配置参数。 
nginx -s reload 更改了配置后无需重启Nginx，平滑重启。
nginx -s stop  停止Nginx
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>Sencha Touch 实例分析（自定义列表）</title>
   <link href="http://www.blogways.net/blog/2013/09/21/senchatouch-5.html"/>
   <updated>2013-09-21T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/09/21/senchatouch-5</id>
   <content type="html">&lt;h2&gt;自定义列表分析&lt;/h2&gt;

&lt;h4&gt;这是一个应用分类软件的截图&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/st-7.png&quot; alt=&quot;应用程序下载页面截图&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;看看 ST 里面如何来设计这个界面&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/st-8.png&quot; alt=&quot;ST 视图设计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;简单来划分，这个视图分为三块，最外面的 TabPanel（id: tp），面板上面的 TitleBar（id: tb）以及下面主要数据展示的 List（id: ll），下面来看看每个模块的代码：&lt;/p&gt;

&lt;h4&gt;TabPanel（id: tp）&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;Ext.define('myapp.view.MyList', {
    extend: 'Ext.TabPanel',
    xtype: 'mylist',
    config: {
        tabBarPosition: 'bottom',
        items: [{
            title: '首页',
            iconCls: 'home'
        },
        {
            title: '分类',
            iconCls: 'info'
        },
        {
            title: '达人',
            iconCls: 'locate'
        },
        {
            title: '排行',
            iconCls: 'user'
        },
        {
            title: '管理',
            iconCls: 'settings'
        }]
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;TitleBar（id: tb）&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;{
    xtype: 'titlebar',
    docked: 'top',
    items: [
        {
            xtype: 'label',
            html: '应用分类'
        },
        {
            iconCls: 'search',
            ui: 'plain',
            align: 'right'
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;List（id: ll）&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;{
    xtype: 'list',
    store: 'MyListStore',
    itemTpl: ['&amp;lt;div class=&quot;mylist&quot;&amp;gt;', 
                    '&amp;lt;div class=&quot;mylist-1&quot;&amp;gt;&amp;lt;image src=&quot;{img}&quot;/&amp;gt;&amp;lt;/div&amp;gt;', 
                    '&amp;lt;div class=&quot;mylist-2&quot;&amp;gt;&amp;lt;div class=&quot;mylist-2-1&quot;&amp;gt;{title}&amp;lt;/div&amp;gt;', 
                    '&amp;lt;div class=&quot;mylist-2-2&quot;&amp;gt;{subtitle}&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;',
                    '&amp;lt;div class=&quot;mylist-3&quot;&amp;gt;{download}&amp;lt;/div&amp;gt;', 
              '&amp;lt;/div&amp;gt;'].join(''),
    flex: 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;既然是 list 肯定是有数据源的，这个示例中定义的数据源名是 MyListStore，看下其如何实现的，为了简便起见 model 我没有单独写，跟 store 合到一起了。&lt;/p&gt;

&lt;h4&gt;myapp.store.MyListStore&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;Ext.define('myapp.store.MyListStore', {
    extend: 'Ext.data.Store',
    config: {
        // model: 'myapp.model.MyListModel',
        fields: ['title', 'subtitle', 'img', 'download'],
        data: [
           { title: '游戏', subtitle: '体育、战略、休闲', img: 'resources/icons/Icon.png', download: '22889'},
           { title: '电子书', subtitle: '小说、笑话、资料', img: 'resources/icons/Icon.png', download: '18621'},
           { title: '影音播放', subtitle: 'Adobe Flash 播放器', img: 'resources/icons/Icon.png', download: '2088'},
           { title: '交通导航', subtitle: 'Google 地图，高级地图', img: 'resources/icons/Icon.png', download: '685'},
           { title: '生活娱乐', subtitle: '大众点评，我查查', img: 'resources/icons/Icon.png', download: '9184'}
       ]
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看下最后的效果图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/st-9.png&quot; alt=&quot;ST 自定义列表效果图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后看下合并后整个视图的代码&lt;/p&gt;

&lt;h4&gt;myapp.view.MyList&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;Ext.define('myapp.view.MyList', {
    extend: 'Ext.TabPanel',
    xtype: 'mylist',
    requires: [
        'Ext.Label',
        'Ext.dataview.List'
    ],
    config: {
        tabBarPosition: 'bottom',
        items: [{
            title: '首页',
            iconCls: 'home',
            layout: 'vbox',
            items: [{
                xtype: 'titlebar',
                docked: 'top',
                items: [
                    {
                        xtype: 'label',
                        html: '应用分类'
                    },
                    {
                        iconCls: 'search',
                        ui: 'plain',
                        align: 'right'
                    }
                ]
            }, {
                xtype: 'list',
                store: 'MyListStore',
                itemTpl: ['&amp;lt;div class=&quot;mylist&quot;&amp;gt;', 
                                '&amp;lt;div class=&quot;mylist-1&quot;&amp;gt;&amp;lt;image src=&quot;{img}&quot;/&amp;gt;&amp;lt;/div&amp;gt;', 
                                '&amp;lt;div class=&quot;mylist-2&quot;&amp;gt;&amp;lt;div class=&quot;mylist-2-1&quot;&amp;gt;{title}&amp;lt;/div&amp;gt;', 
                                '&amp;lt;div class=&quot;mylist-2-2&quot;&amp;gt;{subtitle}&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;',
                                '&amp;lt;div class=&quot;mylist-3&quot;&amp;gt;{download}&amp;lt;/div&amp;gt;', 
                          '&amp;lt;/div&amp;gt;'].join(''),
                flex: 1
            }]
        },
        {
            title: '分类',
            iconCls: 'info'
        },
        {
            title: '达人',
            iconCls: 'locate'
        },
        {
            title: '排行',
            iconCls: 'user'
        },
        {
            title: '管理',
            iconCls: 'settings'
        }]
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自定义列表样式&lt;/p&gt;

&lt;h4&gt;main.css&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;.mylist {
    height: 60px;
}

.mylist-1 {
    display: inline-block;
    float: left;
}

.mylist-2 {
    margin-top: 10px;
    padding-left: 10px;
    display: inline-block;
}

.mylist-2-1 {
    font-size: 1.2em;
}

.mylist-2-2 {
    margin-top: 5px;
    font-size: 0.6em;
}

.mylist-3 {
    display: inline-block;
    float: right;
    padding-top: 20px;
    padding-right: 5px;
    font-size: 0.6em;
}

.x-list .x-list-item .x-list-item-body, .x-list .x-list-item.x-list-item-tpl .x-innerhtml {
    padding: 5px 5px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个示例的选择相对比较简洁，大家有时候会看到更加复杂的列表，或者自己在开发的时候需要展示的数据更多，样式要求更复杂，其实原理都是一样的，通过定义 itemTpl 节点元素来实现自定义的列表项展示。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Sencha Touch 实例分析（功能导航）</title>
   <link href="http://www.blogways.net/blog/2013/09/20/senchatouch-4.html"/>
   <updated>2013-09-20T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/09/20/senchatouch-4</id>
   <content type="html">&lt;h2&gt;功能导航页面分析&lt;/h2&gt;

&lt;p&gt;本次分析的是支付宝的一个功能导航页面&lt;/p&gt;

&lt;h4&gt;下面是支付宝导航页面截图&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/st-4.png&quot; alt=&quot;支付宝功能导航页面&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;我们来看看在 ST 里面如何设计实现整个页面的部局&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/st-5.png&quot; alt=&quot;支付宝功能导航页面设计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;整个页面主要是一个 TabPanel（id: tp），里面包含了一个 Container（id: con1）和一个 Carousel（id: car），car 里面包含了一个 Container（id:con2）。&lt;/p&gt;

&lt;h4&gt;下面来看看每个模块如何实现：&lt;/h4&gt;

&lt;h5&gt;TabPanel（id: tp）&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;Ext.define('myapp.view.Paypal', {
    extend: 'Ext.TabPanel',
    xtype: 'paypal',
    requires: [],
    config: {
        tabBarPosition: 'bottom',
        items: [{
            title: '支付宝',
            iconCls: 'home'
        },
        {
            title: '帐单',
            iconCls: 'info'
        },
        {
            title: '我的帐单',
            iconCls: 'locate'
        },
        {
            title: '安全',
            iconCls: 'user'
        }]
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;Container（id: con1）&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;{
    xtype: 'container',
    padding: '15px 5px 5px 10px',
    style: 'background-color: #5E99CC',
    html: ['&amp;lt;div class=&quot;title&quot;&amp;gt;&amp;lt;div class=&quot;title-1&quot;&amp;gt;', 
            '&amp;lt;image src=&quot;resources/icons/Icon.png&quot;/&amp;gt;&amp;lt;/div&amp;gt;', 
            '&amp;lt;div class=&quot;title-2&quot;&amp;gt;&amp;lt;div class=&quot;title-2-1&quot;&amp;gt;4.10 元&amp;lt;/div&amp;gt;', 
            '&amp;lt;div class=&quot;title-2-2&quot;&amp;gt;备注说明&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;'].join('')
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;Carousel（id: car）&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;{
    xtype: 'carousel',
    flex: 1,
    layout: 'fit',
    defaults: {
        styleHtmlContent: true
    },
    items: [
        {
            html : 'Item 1'
        },
        {
            html : 'Item 2'
        },
        {
            html : ['&amp;lt;div class=&quot;nav&quot;&amp;gt;&amp;lt;ul&amp;gt;', 
                        '&amp;lt;li&amp;gt;&amp;lt;image src=&quot;resources/icons/Icon.png&quot;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;a&amp;gt;转帐&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;',
                        '&amp;lt;li&amp;gt;&amp;lt;image src=&quot;resources/icons/Icon.png&quot;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;a&amp;gt;信用卡还款&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;',
                        '&amp;lt;li&amp;gt;&amp;lt;image src=&quot;resources/icons/Icon.png&quot;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;a&amp;gt;手机充值&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;',
                        '&amp;lt;li&amp;gt;&amp;lt;image src=&quot;resources/icons/Icon.png&quot;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;a&amp;gt;水电煤&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;',
                        '&amp;lt;li&amp;gt;&amp;lt;image src=&quot;resources/icons/Icon.png&quot;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;a&amp;gt;扫码&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;',
                        '&amp;lt;li&amp;gt;&amp;lt;image src=&quot;resources/icons/Icon.png&quot;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;a&amp;gt;iReader&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;',
                        '&amp;lt;li&amp;gt;&amp;lt;image src=&quot;resources/icons/Icon.png&quot;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;a&amp;gt;更多&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;',
                    '&amp;lt;/ul&amp;gt;&amp;lt;/div&amp;gt;'].join('')
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;看下总体的效果图&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/st-6.png&quot; alt=&quot;ST 模仿效果图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当然我并没有完全按原样的界面去做，毕竟图片跟样式不是我们这节的重点，这个完全是按简化版来设计的，也没有添加任何事件，给大家一个参考，在实际运用的时候大家可以把两部分分成两个单独的文件来开发，通过 xtype 再结合起来。另外当中的九宫图也是比较经典的部分，我是通过 html 的无序列表来实现的，我们知道很多经典的菜单都是通过 ul+css 来实现的，这个地方也不例外，无序列表配合 css 用来实现导航功能还是蛮强大的，当然也可以通 div 来实现九宫格，样式理解起来可能更容易一些，或者直接使用 ST 的 toolbar 来实现也是可以的，这三种方式都是可以动态添加创建的，这个地方不作讨论，如果有需要的话以后来写下这三种动态实现方式。&lt;/p&gt;

&lt;h4&gt;下面来看下完整的代码&lt;/h4&gt;

&lt;p&gt;view&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ext.define('myapp.view.Paypal', {
    extend: 'Ext.TabPanel',
    xtype: 'paypal',
    requires: [],
    config: {
        tabBarPosition: 'bottom',
        items: [{
            title: '支付宝',
            iconCls: 'home',
            layout: 'vbox',
            items: [{
                xtype: 'container',
                padding: '15px 5px 5px 10px',
                style: 'background-color: #5E99CC',
                html: ['&amp;lt;div class=&quot;title&quot;&amp;gt;&amp;lt;div class=&quot;title-1&quot;&amp;gt;', 
                        '&amp;lt;image src=&quot;resources/icons/Icon.png&quot;/&amp;gt;&amp;lt;/div&amp;gt;', 
                        '&amp;lt;div class=&quot;title-2&quot;&amp;gt;&amp;lt;div class=&quot;title-2-1&quot;&amp;gt;4.10 元&amp;lt;/div&amp;gt;', 
                        '&amp;lt;div class=&quot;title-2-2&quot;&amp;gt;备注说明&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;'].join('')
            }, {
                xtype: 'carousel',
                flex: 1,
                layout: 'fit',
                defaults: {
                    styleHtmlContent: true
                },
                items: [
                    {
                        html : 'Item 1'
                    },
                    {
                        html : 'Item 2'
                    },
                    {
                        html : ['&amp;lt;div class=&quot;nav&quot;&amp;gt;&amp;lt;ul&amp;gt;', 
                                    '&amp;lt;li&amp;gt;&amp;lt;image src=&quot;resources/icons/Icon.png&quot;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;a&amp;gt;转帐&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;',
                                    '&amp;lt;li&amp;gt;&amp;lt;image src=&quot;resources/icons/Icon.png&quot;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;a&amp;gt;信用卡还款&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;',
                                    '&amp;lt;li&amp;gt;&amp;lt;image src=&quot;resources/icons/Icon.png&quot;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;a&amp;gt;手机充值&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;',
                                    '&amp;lt;li&amp;gt;&amp;lt;image src=&quot;resources/icons/Icon.png&quot;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;a&amp;gt;水电煤&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;',
                                    '&amp;lt;li&amp;gt;&amp;lt;image src=&quot;resources/icons/Icon.png&quot;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;a&amp;gt;扫码&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;',
                                    '&amp;lt;li&amp;gt;&amp;lt;image src=&quot;resources/icons/Icon.png&quot;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;a&amp;gt;iReader&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;',
                                    '&amp;lt;li&amp;gt;&amp;lt;image src=&quot;resources/icons/Icon.png&quot;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;a&amp;gt;更多&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;',
                                '&amp;lt;/ul&amp;gt;&amp;lt;/div&amp;gt;'].join('')
                    }
                ]
            }]
        },
        {
            title: '帐单',
            iconCls: 'info'
        },
        {
            title: '我的帐单',
            iconCls: 'locate'
        },
        {
            title: '安全',
            iconCls: 'user'
        }]
    }
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;css&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.title {
}

.title-1 {
    float: left;
    display: inline-block;
}

.title-2 {
    display: inline-block;
    margin: 5px;
    padding-top: 5px;
}

.title-2-1 {
    font-size: 1.2em;
}

.title-2-2 {
    font-size: 0.6em;
}

.nav {
    margin: 0;
    padding: 0;
    font-size: 0.6em;
}

.nav {
    margin: 0px;
    padding: 0px;
}

.nav ul {
    margin: 0px;
    padding: 0px;
}

.nav ul li {
    width: 33%;
    height: 80px;
    float: left;
    display: inline;
    text-align: center;
}

.nav ul li img {
    width: 48px;
    height: 48px;
}

.nav ul li a {
    display: block;
    text-decoration: none;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;方便起见，我把代码合到一个 view 文件里面，如果你还不知道怎么看的话，见意回头看看基础概念，别急于求成。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>构建基于 Sencha Touch MVC 的 web 应用</title>
   <link href="http://www.blogways.net/blog/2013/09/20/senchatouch-3.html"/>
   <updated>2013-09-20T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/09/20/senchatouch-3</id>
   <content type="html">&lt;h2&gt;构建基于 Sencha Touch MVC 的 web 应用&lt;/h2&gt;

&lt;h3&gt;MVC 程序结构解析&lt;/h3&gt;

&lt;p&gt;就算以前有 EXT 的编程经验，刚接触 ST MVC 的时候，你可能会被一个个文件夹跟一堆堆的 js 搞得头昏脑涨，建一个视图需要几个文件，每个文件该如何创建，相互之间如何调用。所以开始实践之前有必要来了解下 MVC 的整个程序结构。&lt;/p&gt;

&lt;p&gt;一个应用程序其实就是Models，Views，Controllers，Stores和Profiles的集合，只不过附加了一些特殊的元素，例如程序的图标或者加载图片等等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/st-3.png&quot; alt=&quot;ST 应用程序架构&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Model：在应用程序中代表了一个对象类型，简单理解便是数据模型。
View：利用Sencha Touch内部组件，负责向用户显示数据，简单解释便是视图。
Controller：处理应用程序的交互，监听事件并作出响应，简单理解就是控制器。
Store：负责将数据加载到我们的应用程序当中。
Profile：为的是在尽可能多的通用代码下，为手机和平板电脑定制UI。简单理解就是配置文件，如果是手机应该加载怎样的UI，平板电脑则加载什么样的UI。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常我们在Sencha Touch的应用程序中都会这样编写application：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ext.application({
    name: 'MyApp',
    models: ['User', 'Product', 'nested.Order'],
    views: ['OrderList', 'OrderDetail', 'Main'],
    controllers: ['Orders'],
    launch: function() {
        Ext.create('MyApp.view.Main');
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么我们就对以上代码进行简单分析：&lt;/p&gt;

&lt;p&gt;name：便是我们定义的命名空间，我们的所有代码都在该空间下编写，类似Java中的顶级包名。在上面的代码中，我们我们知道，在view文件夹下有Main.js文件，就等价于该文件的存在路径为MyApp.view.Main。&lt;/p&gt;

&lt;p&gt;我们通过models,views和controllers来加载相应目录下的文件。&lt;/p&gt;

&lt;p&gt;Controllers&lt;/p&gt;

&lt;p&gt;controller是程序的中心，它把程序的各部分有机的结合在一起，并统一运行控制，使我们的程序正常运行。比如，view中存放的仅仅是页面布局等代码，关于页面逻辑处理的代码几乎都存放在controller中了，实现逻辑代码的统一管理。&lt;/p&gt;

&lt;p&gt;A simple example&lt;/p&gt;

&lt;p&gt;接下来的例子展示给我们如何快速的定义控制器。在这里我们使用两个比较常用的控制器配置项：refs和control。通过refs，我们可以轻松的在一个页面中找到任何的组件。在本例中，我们将匹配xtype为formpanel的组件，并将第一个匹配的作为loginForm，并在doLogin函数之后使用该属性。&lt;/p&gt;

&lt;p&gt;第二件事情便是建立起一个control配置项。就像refs，它使用一个组件查询器来找到所有的formpanel。看看下面具体的代码再说吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ext.define('MyApp.controller.Sessions', {
    extend: 'Ext.app.Controller', 
    config: {
        refs: {
            loginForm: 'formpanel'
        },
        control: {
            'formpanel button': {
                tap: 'doLogin'
            }
        }
    },

    doLogin: function() {
        var form = this.getLoginForm(),
            values = form.getValues(); 
        MyApp.authenticate(values);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;doLogin函数本身是很简单的，因为在定义一个loginForm的refs的时候，控制器会自动为我们生成一个getLoginForm的函数，返回我们需要的那个formpanel。简单理解上面代码的作用便是：refs是我们声明的组件的引用，control中是我们对这些组件需要监听的事件以及触发的函数。refs是指向，control是控制。&lt;/p&gt;

&lt;p&gt;Stores&lt;/p&gt;

&lt;p&gt;Stores是Sencha Touch中特别重要的部分，并且大多数的窗体都会绑定数据的。简单来说，store其实就像是model的数据实体。例如List和DataView这些组件，渲染的都是store中的model的实体。因为model的实体被添加或者从store中移除时，都会触发这些组件所绑定的数据监听，达到更新或者其他操作的目的。&lt;/p&gt;

&lt;p&gt;Device Profiles&lt;/p&gt;

&lt;p&gt;我们知道，Sencha Touch程序会运行在不同设备上，这些设备有着不同的功能或者屏幕分辨率。例如一个用户界面可能比较适合于平板电脑，但是在手机中就显得不是那么合适了，反之亦然。然而我们在编写应用程序的时候，并不想为每一设备都单独写一个程序，那样太麻烦了，我们更倾向于写好的程序，本身能够在手机或者平板电脑中运行并根据设备进行不同的加载，显示不同的UI风格，这是我们便要用好profile文件了。profile文件只是简单的告诉程序，如何针对不同的设备进行不同的加载，我们通常在程序开始的时候便声明它：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ext.application({
    name: 'MyApp',
    profiles: ['Phone', 'Tablet'],
    //as before
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦我们像上面这段代码一样，声明了我们的profile文件，那么程序在加载的过程当中，就会去加载我们app/profile目录下的相应JS文件了。我们可以看看下面这段代码是如何定义一个平板电脑的配置文件的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ext.define('MyApp.profile.Tablet', {
    extend: 'Ext.app.Profile',
    config: {
        controllers: ['Groups'],
        views: ['GroupAdmin'],
        models: ['MyApp.model.Group']
    }, 
    isActive: function() {
        return Ext.os.is.Tablet;
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只要Sencha Touch认为我们的应用程序是运行在平板电脑上的时候，isActive函数便会返回true。其实这个判断并不是很准确的，因为目前的平板电脑和手机并没有很明显的界限，所有Sencha Touch在进行判断的时候，只识别ipad，对于其他的平板电脑都会返回false的，也就是说除了ipad，其他的都看做是手机。不过你也可在isActive函数中进行细化，来实现你需要的功能。
我们在编写代码的时候，一定要注意，只能有一个true从profile文件中返回，否则的话程序只会识别第一个返回的true，其他的将不会被识别或者被忽略。这时我们应用程序会被设定在当前的配置文件下，并且可以被随时查看。&lt;/p&gt;

&lt;p&gt;如果检测到我们当前的配置文件，定义了额外的models，views，controllers或者stores，这些都会被自动加载的。但是名字可不是随便写的，这些都是有一定关联的，看下面的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;views: ['GroupAdmin'] will load app/view/tablet/GroupAdmin.js
controllers: ['Groups'] will load app/controller/tablet/Groups.js
models: ['MyApp.model.Group'] will load app/model/Group.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有完整的名字的话，该文件必须存放在相应目录下的tablet子目录下，例如所有的视图文件都必须存放在app/view/tablet目录下，但是如果指定了完整的路径的话，只要该文件存在于该路径下就OK了。&lt;/p&gt;

&lt;p&gt;大多数情况下，我们只会在profile中定义一些额外的视图或者控制器，共享我们应用程序的数据。&lt;/p&gt;

&lt;p&gt;Launch Process&lt;/p&gt;

&lt;p&gt;我们可以为每一个应用程序定义一个launch函数，负责应用程序的加载，同时这里也是我们设定应用程序启动逻辑，创建主视图的最好位置。除了在该位置之外，我们还有两个地方可以设定我们程序的启动逻辑。首先是每一个控制器中，我们可以定义一个init函数，该函数会在launch函数之前被调用。另一个便是，如果我们使用了设备配置文件，那么每一个profile中都能定义launch函数，该函数会在控制器的init之后，launch之前被调用。&lt;/p&gt;

&lt;p&gt;例如我们为设备定义了不同的profile文件，phone和tablet，并在一个平板电脑中运行我们的应用程序，那么启动顺序如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.控制器的init函数被调用。
2.Profile中的launch函数会被调用。
3.应用程序的launch函数会被调用。
4.控制器中的launch函数会被调用。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们使用Profile文件的时候，通常会把启动的逻辑顺序放在Profile的launch中，因为我们会根据不同设备，建立不同的视图启动顺序。&lt;/p&gt;

&lt;h2&gt;管理 MVC 的依赖项&lt;/h2&gt;

&lt;p&gt;ST2应用程序用来定义依赖项的地方主要有两个，application本身和应用程序内部类。本指南将给出一些关于应用程序如何放置和在哪里放置依赖项的建议。&lt;/p&gt;

&lt;h4&gt;应用程序依赖项&lt;/h4&gt;

&lt;p&gt;当你创建一个MVC应用程序时，Ext.application会提供一个直观的方式来设置应用程序会用到的数据模型、视图、控制器、数据存储器和配置文件等，如下例所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ext.application({
    name: 'MyApp',
    views: ['Login'],
    models: ['User'],
    controllers: ['Users'],
    stores: ['Products'],
    profiles: ['Phone', 'Tablet']
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这5个配置项是用来加载应用程序常用文件（数据模型、视图、控制器、存储器、配置文件）的快捷方式。如上的配置意味着应用程序会自动加载下列文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app/view/Login.js
app/model/User.js
app/controller/Users.js
app/store/Products.js
app/profile/Phone.js
app/profile/Tablet.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就加载文件而言，上面的例子跟下面的定义是等价的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ext.require([
    'MyApp.view.Login',
    'MyApp.model.User',
    'MyApp.controller.Users',
    'MyApp.store.Products',
    'MyApp.profile.Phone',
    'MyApp.profile.Tablet'
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在你需要加载更多的类文件情况下，这种配置方式就会更有用，它能避免你为每一个文件都拼写又臭又长的完整类名。除了把依赖文件加载进来之外，这几个配置还会做更多的事情：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;profiles 
配置文件 – 实例化每一个Profle并判断哪一个当前可用。当前可用的那个profile中所有依赖项也将被加载

controllers
控制器 – 加载完成后实例化每一个控制器

stores
存储器 – 实例化每一个存储器，没有指定id的存储器会被指定一个默认id
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这意味着，如果你要享受MVC带给你的便利，那么载你定义应用程序依赖项的时候，最好使用配置选项这种方式。&lt;/p&gt;

&lt;h4&gt;配置文件指定的依赖项&lt;/h4&gt;

&lt;p&gt;当你使用设备配置的时候，可能会有一些类是仅在特定设备上使用的。例如，平板电脑版本的应用程序可能包含比手机版本更多的功能，这当然意味着要加载更多的类。每个Profile都可以在内部定义额外的依赖项。&lt;/p&gt;

&lt;p&gt;Ext.define('MyApp.profile.Tablet', {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extend: 'Ext.app.Profile',
config: {
    views: ['SpecialView'],
    controllers: ['Main'],
    models: ['MyApp.model.SuperUser']
},
isActive: function() {
    return Ext.os.is.Tablet;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;然后每个profile中定义的依赖项都会被加载，不管这个profile是否active，不过尽管都被加载，但应用程序不会去做类似实例化非active状态profile指定的控制器这样的无用功。&lt;/p&gt;

&lt;p&gt;这听起来有点不合常规，为什么要下载那些不会用到的类文件呢？这么做的原因是产生一个可以在任何设备上运行的通用程序版本，然后检测哪一个profile应该被使用，接着从这个profile启动应用程序。与之相对的选择是为每个profile创建一个应用版本，然后启动一个微型加载器来检测哪个profile该被选择，然后去下载该profile需要的代码文件。&lt;/p&gt;

&lt;p&gt;的确这种通用架构的程序会在每个设备上都下载一些根本用不到的代码文件，不过对于绝大多数应用程序来说，你多下载的这点文件影响实在是微乎其微。而对于比较庞大的应用程序来说，这个问题可能更值得注意，所以我们可能在2.0的后续版本对它进行处理。&lt;/p&gt;

&lt;h4&gt;级联依赖&lt;/h4&gt;

&lt;p&gt;大一些应用通常会把数据模型、视图、控制器分别存储在不同子文件夹下，这样可以让整个项目看起来更清晰明了一些。对于视图来说尤其如此，大型应用拥有上百个独立的视图类并非天方夜谭，因此分文件夹存储几乎不可避免。&lt;/p&gt;

&lt;p&gt;指定子文件夹中的依赖项只需要使用“.”来分割文件夹路径即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ext.application({
    name: 'MyApp',
    controllers: ['Users', 'nested.MyController'],
    views: ['products.Show', 'products.Edit', 'user.Login']
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上例中将会加载下列5个文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app/controller/Users.js
app/controller/nested/MyController.js
app/view/products/Show.js
app/view/products/Edit.js
app/view/user/Login.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以混合使用两种方式来定义每个数据模型、视图、控制器、配置文件和存储器：快捷路径方式（符合mvc推荐原则的类只写最后的类名即可）和完整路径方式（自定义路径的类则写完整路径加类名）。&lt;/p&gt;

&lt;h4&gt;外部依赖项&lt;/h4&gt;

&lt;p&gt;我们可以通过指定想要加载的完整类名方式来定义应用程序之外的类作为依赖项。这种情况最常见的用途就是在多个应用之间共享认证逻辑。我们可能会有好几个应用程序都要到同一个用户数据库进行验证并实现登录，这时我们当然希望它们能够共享用户登录的代码。比较容易的方式就是在应用程序文件夹之外创建一个单独的文件夹然后把其中的内容作为依赖项添加到应用程序中去。&lt;/p&gt;

&lt;p&gt;我们假定共享的登录代码包含一个login控制器，一个用户model和一个login表单视图。我们要在应用程序中把它们全部用上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ext.Loader.setPath({
    'Auth': 'Auth'
});

Ext.application({
    views: ['Auth.view.LoginForm', 'Welcome'],
    controllers: ['Auth.controller.Sessions', 'Main'],
    models: ['Auth.model.User']
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述代码将加载以下的文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Auth/view/LoginForm.js
Auth/controller/Sessions.js
Auth/model/User.js
app/view/Welcome.js
app/controller/Main.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面三个文件加载自应用程序外部，后两个则来自应用程序内部。同样我们可以混合调用内外部依赖项。&lt;/p&gt;

&lt;p&gt;想要启用外部依赖项加载，我们只需告诉Loader到哪里可以找到这些文件即可，Ext.Loader.setPath就是干这个的。上例中我们告诉Loader所有以Auth命名空间中的文件都可以到Auth这个文件夹中找到。这样我们就能把应用程序文件夹之外的通用验证代码都拽进来了，其他的事情由ST框架来处理。&lt;/p&gt;

&lt;p&gt;依赖项应该放在哪里&lt;/p&gt;

&lt;p&gt;决定在哪里声明依赖项的一个基本原则就是保证你的类文件完整的内部包含。例如，你有一个视图A包含了几个其他的视图，你就应该在这个A视图内部声明它的依赖项，而不是在application中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ext.define('MyApp.view.Main', {
    extend: 'Ext.Container',
    requires: [
        'MyApp.view.Navigation',
        'MyApp.view.MainList'
    ],
    config: {
        items: [
            {
                xtype: 'navigation'
            },
            {
                xtype: 'mainlist'
            }
        ]
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;App.js中这么写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ext.application({
    views: ['Main']
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这才是依赖项的最佳声明方式。两个原因：1、确保app.js干净；2、让你知道主程序依赖MyApp.view.Main就已经足够。不好的方式就是下面这样把视图都罗列在app.js里：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ext.application({
    views: ['Main', 'Navigation', 'MainList']
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;换种方式来描述这个问题，app.js只需要包含最顶级的视图即可。你在应用程序内部通过Ext.create('MyApp.view.SomeView')来创建的视图就可以视作顶级视图。其他那些仅仅被作为某些视图内部子视图的（比如例子中的MyApp.view.Navigation和MyApp.view.MainList）就不应该出现在app.js里面。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Sencha Touch 体验</title>
   <link href="http://www.blogways.net/blog/2013/09/18/senchatouch-2.html"/>
   <updated>2013-09-18T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/09/18/senchatouch-2</id>
   <content type="html">&lt;h2&gt;Sencha Touch 体验&lt;/h2&gt;

&lt;h3&gt;下载&amp;amp;&amp;amp;安装&lt;/h3&gt;

&lt;p&gt;Sencha Touch 2 SDK ：
http://www.sencha.com/products/touch/&lt;/p&gt;

&lt;p&gt;SDK Tool：
http://www.sencha.com/products/sdk-tools/download&lt;/p&gt;

&lt;p&gt;解压 SDK 后是不能直接打开帮助文档的，需要部署到 web 服务器，通过 WebKit 的浏览器（chrome或者safari等）才能查看自带的帮助文档以及 Demo。&lt;/p&gt;

&lt;p&gt;安装好 SDK Tool，在命令窗口输入 sencha 可以查询到 st cmd 相关信息。&lt;/p&gt;

&lt;h3&gt;创建第一个 Sencha Touch 应用&lt;/h3&gt;

&lt;p&gt;命令行格式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sencha generate app 应用的命名空间 app路径
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;E:\program\download\Html5\sencha\touch-2.2.1&amp;gt;sencha generate app myapp ../myapp
Sencha Cmd v3.1.2.342
[INF]
[INF] init-plugin:
[INF]
[INF] -before-generate-workspace:
[INF]
[INF] cmd-root-plugin.init-properties:
[INF]
[INF] init-properties:
[INF]
[INF] init-sencha-command:
[INF]
[INF] init:
[INF]
[INF] generate-workspace-impl:
[INF]      [echo] generating into E:\program\download\Html5\sencha\touch-2.2.1\..\myapp from D:\program\Sencha\Cmd\3.1.2.342/templates/workspace
[INF]     [mkdir] Created dir: E:\program\download\Html5\sencha\myapp\packages
[INF]
[INF] cmd-root-plugin.copy-framework-to-workspace-impl:
[INF] [propertyfile] Updating property file: E:\program\download\Html5\sencha\myapp\.sencha\workspace\sencha.cfg
[INF]
[INF] copy-framework-to-workspace-impl:
[INF]      [copy] Copying 1862 files to E:\program\download\Html5\sencha\myapp\touch
[INF]      [copy] Copied 218 empty directories to 3 empty directories under E:\program\download\Html5\sencha\myapp\touch
[INF]      [copy] Copying 1 file to E:\program\download\Html5\sencha\myapp\touch
[INF]      [copy] Copying 1 file to E:\program\download\Html5\sencha\myapp\touch
[INF] [propertyfile] Updating property file: E:\program\download\Html5\sencha\myapp\.sencha\workspace\sencha.cfg
[INF]
[INF] copy-framework-to-workspace:
[INF]
[INF] generate-workspace:
[INF]
[INF] -after-generate-workspace:
[INF]
[INF] init-plugin:
[INF]
[INF] cmd-root-plugin.init-properties:
[INF]
[INF] init-properties:
[INF]
[INF] init-sencha-command:
[INF]
[INF] init:
[INF]
[INF] before-upgrade:
[INF]
[INF] generate-app-impl:
[INF]
[INF] generate-starter-app:
[INF]     [mkdir] Created dir: E:\program\download\Html5\sencha\myapp\app\profile
[INF]
[INF] copy-sdk:
[INF]      [copy] Copying 1 file to E:\program\download\Html5\sencha\myapp\resources\css
[INF]      [copy] Copying 4 files to E:\program\download\Html5\sencha\myapp\resources\sass\stylesheets
[INF] [x-property-file] Updating property file: E:\program\download\Html5\sencha\myapp\.sencha\app\sencha.cfg
[INF]
[INF] after-upgrade:
[INF]
[INF] generate-app:
[INF]
[INF] -after-generate-app:
[INF] [x-property-file] Updating property file: E:\program\download\Html5\sencha\myapp\.sencha\app\sencha.cfg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将产生的 myapp 项目部署到 web 服务器，通过 chrome 浏览器查看应用是否创建成功。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/st-1.png&quot; alt=&quot;第一个 Sencha Touch 应用&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;项目结构分析&lt;/h3&gt;

&lt;p&gt;将生成的项目使用 IDE 打开&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/st-2.png&quot; alt=&quot;Sencha Touch 项目结构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;app - 目录，MVC 相关程序文件，下一章会做详细介绍
app.js - 应用的 js 入口文件
app.json - 应用配置文件，ST 采用动态加载 js 以及 css 文件机制，在 html 文件里面只需要加载 &lt;code&gt;touch/microloader/development.js&lt;/code&gt; js 文件就可以了，其他的都配在这个文件里面
index.html - 应用入口 index 文件
packager.json - 打包原生程序的配置文件
resources - 目录，项目资源文件
touch - Sencha Touch SDK的副本&lt;/p&gt;

&lt;h3&gt;编译打包&lt;/h3&gt;

&lt;p&gt;这个时候的项目虽然都能正常运行，但项目明显太大了，因为整个 ST sdk 的东西都包含在里面，而且目录也很多，通过打包将代码都打到一个文件夹里面，去除不必要的项目文件，形成最简洁的项目文件。&lt;/p&gt;

&lt;p&gt;命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sencha app build package
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入项目根目录下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;E:\program\download\Html5\sencha\myapp&amp;gt;sencha app build package
[INF] Saving certificate as D:\Program Files\Sencha\cmd\Sencha\Cmd\repo\pkgs\cer
t.json
[INF] Saving private key as D:\Program Files\Sencha\cmd\Sencha\Cmd\repo\.sencha\
repo\private-key.json
Sencha Cmd v3.1.2.342
[INF]
[INF] init-plugin:
[INF]
[INF] cmd-root-plugin.init-properties:
[INF]
[INF] init-properties:
[INF]
[INF] init-sencha-command:
[INF]
[INF] init:
[INF]
[INF] app-build-impl:
[INF]
[INF] -before-init-local:
[INF]
[INF] -init-local:
[INF]
[INF] -after-init-local:
[INF]
[INF] init-local:
[INF]
[INF] find-cmd:
[INF]
[INF] -before-init:
[INF]
[INF] -init:
[INF] Initializing Sencha Cmd ant environment
[INF] Adding antlib taskdef for com/sencha/command/compass/ant/antlib.xml
[INF] [x-load-properties] Loading optional properties file E:\program\download\H
tml5\sencha\myapp\.sencha\app\package.properties
[INF] [x-load-properties] Loading required properties file E:\program\download\H
tml5\sencha\myapp\.sencha\app\build.properties
[INF]
[INF] -after-init:
[INF]
[INF] -before-init-default:
[INF]
[INF] -init-default:
[INF]
[INF] -after-init-default:
[INF]
[INF] init:
[INF]
[INF] -before-build:
[INF]
[INF] sass:
[INF]
[INF] -before-sass:
[INF]
[INF] -sass:
[INF] executing compass using system installed ruby runtime
Error loading gem paths on load path in gem_prelude
can't modify frozen string
&amp;lt;internal:gem_prelude&amp;gt;:69:in `force_encoding'
&amp;lt;internal:gem_prelude&amp;gt;:69:in `set_home'
&amp;lt;internal:gem_prelude&amp;gt;:38:in `dir'
&amp;lt;internal:gem_prelude&amp;gt;:76:in `set_paths'
&amp;lt;internal:gem_prelude&amp;gt;:47:in `path'
&amp;lt;internal:gem_prelude&amp;gt;:286:in `push_all_highest_version_gems_on_load_path'
&amp;lt;internal:gem_prelude&amp;gt;:355:in `&amp;lt;compiled&amp;gt;'
   remove ../css/app.css
   create ../css/app.css
[INF]
[INF] -after-sass:
[INF]
[INF] page:
[INF]
[INF] -before-page:
[INF]
[INF] -page:
[INF] building application
[INF] Deploying your application to E:\program\download\Html5\sencha\myapp\build
\myapp\package
[INF] Copied E:\program\download\Html5\sencha\myapp\app.js to E:\program\downloa
d\Html5\sencha\myapp\build\myapp\package\app.js
[INF] Copied E:\program\download\Html5\sencha\myapp\resources\css\app.css to E:\
program\download\Html5\sencha\myapp\build\myapp\package\resources\css\app.css
[WRN] File or folder E:\program\download\Html5\sencha\myapp\resources\images not
 found
[INF] Copied E:\program\download\Html5\sencha\myapp\resources\icons
[INF] Copied E:\program\download\Html5\sencha\myapp\resources\startup
[INF] Resolving your application dependencies (file:///E:/program/download/Html5
/sencha/myapp/index.html)
[INF] Compiling app.js and dependencies
[INF] Loading classpath entry E:\program\download\Html5\sencha\myapp\touch\src
[INF] Loading classpath entry E:\program\download\Html5\sencha\myapp\app.js
[INF] Loading classpath entry E:\program\download\Html5\sencha\myapp\app
[INF] Concatenating output to file E:\program\download\Html5\sencha\myapp\build\
myapp\package\app.js
[INF] Completed compilation.
[INF] Processed remote file touch/sencha-touch.js
[INF] Processed local file app.js
[INF] Minified app.js
[INF] Generated app.json
[INF] Embedded microloader into index.html
[INF] Successfully deployed your application to E:\program\download\Html5\sencha
\myapp\build\myapp\package
[INF]
[INF] -after-page:
[INF]
[INF] run:
[INF]
[INF] -build:
[INF]
[INF] -after-build:
[INF]
[INF] build:
[INF]
[INF] app-build:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行有报错，貌似也没什么多大的影响，查看根目录下 build 文件里面会生成打包后的项目文件。&lt;/p&gt;

&lt;p&gt;注意，这个地方的打包并不是说将 web 应用打包成终端的 native 应用，ST 的 cmd 虽然提供打包功能，但打出来的包问题太多，目前并不推荐使用，打包本地应用在后面章节再做介绍，如果实在想看效果的话，网上有几个在线打包工具可以试下。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Sencha Touch 框架简介</title>
   <link href="http://www.blogways.net/blog/2013/09/17/senchatouch-1.html"/>
   <updated>2013-09-17T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/09/17/senchatouch-1</id>
   <content type="html">&lt;h2&gt;Sencha Touch 框架简介&lt;/h2&gt;

&lt;p&gt;Sencha Touch（下称ST） 框架是第一个基于 HTML5 的 Mobile App 框架，是 Ext 整合 JQTouch 和 Raphael 而推出的适用于最前沿 Touch Web 的框架，完全基于 HTML5+CSS3 的最新标准，全面兼容 Android 、 Apple IOS 和 BlackBerry 等设备。ST 继承了 Ext 的界面风格，可以让你的 Web App 看起来更像 Native App，其丰富的界面组件、强大的数据管理以及跨浏览器兼容的矢量图将 ST 打造成 Mobile 跨平台开发利器，易扩展，足够应付绝大部分开发需求。&lt;/p&gt;

&lt;p&gt;由于苹果对 Flash 的封杀，使得 Flash 无法进入 IOS 的平台，虽然 Flash 对 Android 系统支持得也不错，但对开发者来说还是有些遗憾，Flash 引以为豪的跨平台特性被中止，随着 Webkit 在移动设备上的流行，越来越多的人开始看好 Html5，后来居上的 ST 得到快速的发展。&lt;/p&gt;

&lt;h3&gt;下面是官方列出的几大特性：&lt;/h3&gt;

&lt;h4&gt;1、基于最新的 web 标准——HTML5，CSS3，JavaScript&lt;/h4&gt;

&lt;p&gt;整个库压缩和 gzip 后大约 120KB，通过禁用一些组件还会使它更小。&lt;/p&gt;

&lt;h4&gt;2、支持目前世界上最好的移动设备&lt;/h4&gt;

&lt;p&gt;Sencha Touch 目前支持 Apple iOS，Android 和 BlackBerry 等目前 3G 市场上最流行的移动设备，它为不同的设备定制了不同的主题，用户可以通过使用这些主题使 web 应用在移动设备上的展现更华丽。&lt;/p&gt;

&lt;h4&gt;3、增强的触摸事件&lt;/h4&gt;

&lt;p&gt;除了 touchstart，touchend 等标准事件基础外，Sencha Touch 增加了一组自定义触摸事件，如 tap、double tap、swipe、tap and hold、pinch、rotate 等。&lt;/p&gt;

&lt;h4&gt;4、数据集成&lt;/h4&gt;

&lt;p&gt;Sencha Touch 提供了强大的数据包，通过 Ajax、JSONP、YQL 等方式用户可以很容易的从各种各样的数据源拿到数据并绑定到组件模板，写入本地离线存储。&lt;/p&gt;

&lt;h3&gt;ST 功能模块介绍：&lt;/h3&gt;

&lt;h4&gt;1、用户界面组件，容器和布局组件&lt;/h4&gt;

&lt;p&gt;Sencha Touch 提供了丰富的用户界面组件，包括常用的按钮，单选框，复选框，文本框，日期选择控件，表格，列表等等，通过运用 Sencha Touch 定制的样式和主题，这些控件在移动设备上看起来和本地应用的 UI 组件没有什么区别。在容器和布局方面，Sencha Touch 也可以和 Adobe 的 Flex 相媲美，不仅提供了基础的 HBoxLayout，VBoxLayout 还提供了 DockLayout，CardLayout，FieldLayout 等更适合开发支持触屏设备的 Mobile web 应用的组件，关于每个组件详细的内容可以参考参考资源中列出的 Sencha Touch 的 API 文档。&lt;/p&gt;

&lt;h4&gt;2、WebKit/CSS3 样式技巧增强&lt;/h4&gt;

&lt;p&gt;Sencha Touch 充分运用了 CSS3 的新特性使基于 webKit 浏览器运行的 Sencha Touch 应用更炫更酷。它支持并增强了对 Animations（动画），Transitions（转换效果），Gradients（渐变），shadows（阴影效果），Font Face（用户自定义字库），Marquee（文字移动效果），Multiple Backgrounds（多背景），RGBA（高清色彩显示通道）等样式效果的展示。&lt;/p&gt;

&lt;h4&gt;3、数据包&lt;/h4&gt;

&lt;p&gt;Sencha Touch 的一个最大特性就是提供了功能强大的数据包。在 Ext.data 包中提供了丰富的 API 实现对 AJAX，JSONP，YQL 等数据访问方式的支持，并提供了 API 供用户更简单方便的操作和展现 JSON 数据， XML 数据等。用户还可以扩展基础接口实现对更复杂数据的操作和访问。Ext.data 数据包中最基础的是 Ext.data.Model，它就像 Java 的 Object 类一样是定义所有对象的基础类，代表应用程序中的数据类型：用户，产品，销售等任何东西。&lt;/p&gt;

&lt;h4&gt;4、数据验证和数据关联&lt;/h4&gt;

&lt;p&gt;Sencha Touch 提供了五种基本的数据验证方式，用户可以将验证方式的定义直接和对象的定义绑定，就像定义数据库表的列约束一样方便和简洁。这五种验证方式是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Presence：验证数据不能为空值。
Length：验证数据的长度，可以定义最大长度和最小长度。
Format：Format验证数据的格式是否符合预定义的格式，比如定义某个时间属性的格式是“yyyy-mm-dd”，那么“20110324”这样的值就被认为是不合法的。
Inclusion：验证数据是否属于某个预定义的范围，该范围可以是一个闭合区间，也可以是一些可能值的集合。
Exclusion：验证数据是否不属于某个预定义的范围。 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;ST 的缺点：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;1、相比较而言入门门槛较高，有些习惯了 jquery 开发的人不太习惯 st 的编程方式；
2、框架类库文件体积大；
3、执行效率低；
4、有些组件响应有延时；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总之，ST 开发简单、兼容性好、支持标准化，提供丰富的界面组件以及强大的数据操作 API，是目前 Mobile Web 开发最成熟的框架，虽然存在一些缺点，相信随着版本的升级会越来越好！&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>关于express用到的日志库debug的知识点滴</title>
   <link href="http://www.blogways.net/blog/2013/08/24/debug-in-express.html"/>
   <updated>2013-08-24T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/08/24/debug-in-express</id>
   <content type="html">&lt;p&gt;使用过&lt;code&gt;connect&lt;/code&gt;或者&lt;code&gt;express&lt;/code&gt;的同学必须要知道&lt;code&gt;debug&lt;/code&gt;。这三个的主要作者都是同一个人。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;debug&lt;/code&gt;模块使用起来很方便，可以分为下面三步：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;在程序中引入&lt;code&gt;debug&lt;/code&gt;时，需要配置一个日志名字空间。&lt;/strong&gt;如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; var debug = require('debug')('namespace')
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;代码中使用&lt;code&gt;debug&lt;/code&gt;打印日志。&lt;/strong&gt;
 debug的内核是使用&lt;code&gt;console.error&lt;/code&gt;来打印日志的。所以，&lt;code&gt;console&lt;/code&gt;支持的通配符&lt;code&gt;debug&lt;/code&gt;都可以使用，比如&lt;code&gt;'%s'&lt;/code&gt;、&lt;code&gt;'%j'&lt;/code&gt;等等。打印&lt;code&gt;json&lt;/code&gt;数据就可以使用通配符&lt;code&gt;%j&lt;/code&gt;，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; debug(&quot;obj:%j&quot;, {name:'test'})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 但是，使用通配符&lt;code&gt;%j&lt;/code&gt;打印出来的&lt;code&gt;json&lt;/code&gt;格式不太漂亮，看不出缩进。如果为了方便阅读，也可以使用&lt;code&gt;nodeJS&lt;/code&gt;的自带模块&lt;code&gt;util&lt;/code&gt;，举例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; util = require('util')
 debug(&quot;object:%s&quot;, util.inspect(obj))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 这种方式打印出来的&lt;code&gt;json&lt;/code&gt;对象，其格式缩进有度，很容易查看。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;配置环境变量&lt;code&gt;DEBUG&lt;/code&gt;.&lt;/strong&gt;如果仅做了上面两步，运行时默认是没有日志的，必须配置环境变量&lt;code&gt;DEBUG&lt;/code&gt;.比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; export DEBUG=connect*,express*
 export DEBUG=*,-send,-connect:dispatcher
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 需要简单说明一下，多个日志名字空间可以使用&lt;code&gt;,&lt;/code&gt;号或空格分隔，也支持使用&lt;code&gt;*&lt;/code&gt;号来进行通配。日志名字空间前加&lt;code&gt;-&lt;/code&gt;号，标记不打印该类型日志。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;上面内容是不是很简单，那就试试吧！&lt;/h3&gt;
</content>
 </entry>
 
 <entry>
   <title>MongoDB 应用架构之路</title>
   <link href="http://www.blogways.net/blog/2013/07/22/mongodb.html"/>
   <updated>2013-07-22T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/07/22/mongodb</id>
   <content type="html">&lt;h2&gt;MongoDB 应用架构之路&lt;/h2&gt;

&lt;p&gt;随着大数据时代的到来，传统的关系型数据库已经无法满足不同的存储需求，短短几年的时间NoSQL大行其道，大有后来居上之势。NoSQL根据不同的数据库类型又可以分为：文件存储、键值存储、列存储、图数据库、RTF存储等。本文我们一起来探索下基于文件存储最流行的NoSQL-MongoDB在实际架构中的应用。&lt;/p&gt;

&lt;p&gt;MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库中功能最丰富、最像关系数据库的。他支持的数据库结构非常松散，是类似json的bjson格式，可以存储比较复杂的数据类型。Mongo完全遵循javascript语法，语法比较灵活，支持的查询功能非常强大，几乎可以实现关系数据单表查询的绝大部分功能，并且支持对表建立索引。&lt;/p&gt;

&lt;h3&gt;安装部署&lt;/h3&gt;

&lt;h4&gt;下载&lt;/h4&gt;

&lt;p&gt;根据自己的操作系统从官网下载对应的MongoDB版本（32bit/64bit），32位的最大只能存放2G的数据，64位的则没有限制。下载后解压到安装目录。&lt;/p&gt;

&lt;h4&gt;启动&lt;/h4&gt;

&lt;p&gt;到bin目录下执行&lt;code&gt;mongod --dbpath=..\db&lt;/code&gt;，其中dbpath参数为指定创建数据库文件的目录，该目录一定要存在，否则无法启动，如果嫌每次都输入参数太麻烦的话可以在bin目录下创建一个mongodb.config文件，将参数写到文件里面，下次启动的时候就可以直接执行&lt;code&gt;mongod --config mongodb.config&lt;/code&gt;就可以了。&lt;/p&gt;

&lt;p&gt;在浏览器中输入&lt;code&gt;http://localhost:28017/&lt;/code&gt;可以查看mongodb的管理信息。&lt;/p&gt;

&lt;h4&gt;基本数据操作&lt;/h4&gt;

&lt;p&gt;在bin目录下执行mongo打开mongodb的客户端，默认连接的是test数据库。注意操作都是js的语法，可以根据自己的习惯来写。&lt;/p&gt;

&lt;h5&gt;insert操作&lt;/h5&gt;

&lt;p&gt;db.user.insert({name:'Jack',age:30})&lt;/p&gt;

&lt;h5&gt;select操作&lt;/h5&gt;

&lt;p&gt;db.user.find({name:'Jack'})&lt;/p&gt;

&lt;h5&gt;update操作&lt;/h5&gt;

&lt;p&gt;db.user.update({name:'Jack'},{name:'Jack',age:20})&lt;/p&gt;

&lt;h5&gt;remove操作&lt;/h5&gt;

&lt;p&gt;db.user.remove({name:'Jack')}&lt;/p&gt;

&lt;p&gt;这些都是最基本的操作，千万别以为就操作就这么简单，要知道js的语法是非常灵活的，要不然怎么实现关系型数据库的单表的大部分功能，但灵活的代价就是语句写起来比较复杂，高级的增删改查、索引、聚合、分类统计、MapReduce、游标等功能就不逐一介绍了，需要大家自己去多实践。&lt;/p&gt;

&lt;p&gt;本文主要介绍MongoDB在应用架构中很重要的两个特性：主从复制、分片技术。&lt;/p&gt;

&lt;h2&gt;架构应用&lt;/h2&gt;

&lt;p&gt;既然是做应用数据库，我们肯定不希望把鸡蛋全放到一个篮子里面，单点部署是不应该被采用的，要知道如果碰到数据库宕机或者硬盘问题数据被永久破坏影响可想而知。幸好MongoDB可以做到读写分离、双机热备份和集群部署。下面来具体看下如何操作。&lt;/p&gt;

&lt;h4&gt;一、主从复制&lt;/h4&gt;

&lt;h5&gt;1、模型图&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/images/nosql-1.png&quot; alt=&quot;主从复制模型&quot; /&gt;&lt;/p&gt;

&lt;h5&gt;2、从上面的模型中我们可以分析出这种架构有如下好处：&lt;/h5&gt;

&lt;p&gt;1) 数据备份；&lt;/p&gt;

&lt;p&gt;2) 数据恢复；&lt;/p&gt;

&lt;p&gt;3) 读写分离；&lt;/p&gt;

&lt;h5&gt;3、实践&lt;/h5&gt;

&lt;p&gt;1) 我们把前面下载的安装文件再拷贝两份到其他的目录，模拟多服务器情况；&lt;/p&gt;

&lt;p&gt;2) 启动一个作为主服务的mongodb，启动主服务器命令&lt;code&gt;mongod --config mongodb.config --master&lt;/code&gt;，原来单启服务加了一个master参数，其他都没有变化，包括端口；&lt;/p&gt;

&lt;p&gt;3) 启动另外一个mongodb服务作为从服务器，可以启多个，注意同一台机器需要换个端口，启动从服务器命令&lt;code&gt;mongod --config mongodb.config --port=8888 --slave --source=127.0.0.1:27017&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;4) 下面可以在两个数据库随便做点操作，我们可以看到数据在两个服务器上是同步更新的；&lt;/p&gt;

&lt;h5&gt;4、读写分离&lt;/h5&gt;

&lt;p&gt;这种手段在大一点的架构中都有实现，在mongodb中其实很简单，在默认的情况下，从属数据库不支持数据的读取，但是没关系，在驱动中给我们提供了一个叫做“slaveOkay&quot;来让我们可以显示的读取从属数据库来减轻主数据库的性能压力，这里就不演示了。&lt;/p&gt;

&lt;h4&gt;二、副本集&lt;/h4&gt;

&lt;h5&gt;1、这个也是很牛的主从集群，不过跟上面的主从集群还是有点区别：&lt;/h5&gt;

&lt;p&gt;1) 该集群没有特定的主数据库；&lt;/p&gt;

&lt;p&gt;2) 如果主数据库宕机了，集群中会推选出一个从属数据库作为主数据库顶上，这就具备了自动故障恢复功能；&lt;/p&gt;

&lt;h5&gt;2、实践&lt;/h5&gt;

&lt;p&gt;下面的操作模拟三个mongodb的服务器，为了方便描述，这边起三个名字A（端口2222）、B（端口3333）、C（端口4444），其中设计A为集群主服务器、B为从服务器，C为仲裁服务器，所有操作都是在当前安装路径bin目录下执行的，开始操作如下：&lt;/p&gt;

&lt;p&gt;1) 建立A服务器，&lt;code&gt;mongod --config mongodb.config --port 2222 --replSet ailk/127.0.0.1:3333&lt;/code&gt;，replSet参数表示让服务器知道还有其他的数据库，指定端口3333的B服务器为下一个数据库；&lt;/p&gt;

&lt;p&gt;2) 建立B服务器，&lt;code&gt;mongod --config mongodb.config --port 3333 --replSet ailk/127.0.0.1:2222&lt;/code&gt;，解释同上；&lt;/p&gt;

&lt;p&gt;3) 工作还没有完成，这个时候看下启动日志发现不停的在报&lt;code&gt;replSet can't get local.system.replSet ...&lt;/code&gt;的错误，我们需要初始化一下“副本集”，随便连一个服务器，进入admin集合。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;D:\Program Files\mongodb-win32-x86_64-2.4.5\bin&amp;gt;mongo 127.0.0.1:2222/admin
MongoDB shell version: 2.4.5
connecting to: 127.0.0.1:2222/admin
&amp;gt; db.runCommand({replSetInitiate:{
... _id:'ailk',
... members:[
... {
... _id:1,
... host:'127.0.0.1:2222'
... },
... {
... _id:2,
... host:'127.0.0.1:3333'
... }
... ]}})
{
        &quot;info&quot; : &quot;Config now saved locally.  Should come online in about a minute.&quot;,
        &quot;ok&quot; : 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时候再看日志已经可以发现主从服务器都已经自动创建好了；&lt;/p&gt;

&lt;p&gt;4) 创建仲裁服务器 C，&lt;code&gt;mongod --config mongodb.config --port 4444 --replSet ailk/127.0.0.1:2222&lt;/code&gt;，在A admin集合中执行rs.addArb()追加即可。这里面需要说明下，仲裁服务器只参与投票选举。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; rs.addArb('127.0.0.1:4444')
{ &quot;ok&quot; : 1 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5) 现在我们使用rs.status()来看下集群服务器的状态&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ailk:PRIMARY&amp;gt; rs.status()
{
        &quot;set&quot; : &quot;ailk&quot;,
        &quot;date&quot; : ISODate(&quot;2013-07-23T08:29:54Z&quot;),
        &quot;myState&quot; : 1,
        &quot;members&quot; : [
                {
                        &quot;_id&quot; : 1,
                        &quot;name&quot; : &quot;127.0.0.1:2222&quot;,
                        &quot;health&quot; : 1,
                        &quot;state&quot; : 1,
                        &quot;stateStr&quot; : &quot;PRIMARY&quot;,
                        &quot;uptime&quot; : 1360,
                        &quot;optime&quot; : Timestamp(1374568146, 1),
                        &quot;optimeDate&quot; : ISODate(&quot;2013-07-23T08:29:06Z&quot;),
                        &quot;self&quot; : true
                },
                {
                        &quot;_id&quot; : 2,
                        &quot;name&quot; : &quot;127.0.0.1:3333&quot;,
                        &quot;health&quot; : 1,
                        &quot;state&quot; : 2,
                        &quot;stateStr&quot; : &quot;SECONDARY&quot;,
                        &quot;uptime&quot; : 189,
                        &quot;optime&quot; : Timestamp(1374568146, 1),
                        &quot;optimeDate&quot; : ISODate(&quot;2013-07-23T08:29:06Z&quot;),
                        &quot;lastHeartbeat&quot; : ISODate(&quot;2013-07-23T08:29:53Z&quot;),
                        &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2013-07-23T08:29:52Z&quot;),
                        &quot;pingMs&quot; : 0,
                        &quot;syncingTo&quot; : &quot;127.0.0.1:2222&quot;
                },
                {
                        &quot;_id&quot; : 3,
                        &quot;name&quot; : &quot;127.0.0.1:4444&quot;,
                        &quot;health&quot; : 1,
                        &quot;state&quot; : 7,
                        &quot;stateStr&quot; : &quot;ARBITER&quot;,
                        &quot;uptime&quot; : 48,
                        &quot;lastHeartbeat&quot; : ISODate(&quot;2013-07-23T08:29:54Z&quot;),
                        &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2013-07-23T08:29:53Z&quot;),
                        &quot;pingMs&quot; : 0
                }
        ],
        &quot;ok&quot; : 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看下stateStr节点就可以看出谁是主服务器、谁是从服务器、谁是仲裁服务器。&lt;/p&gt;

&lt;p&gt;6) 最后来看下自动故障恢复功能，我们把主服务器 A 停掉，进入 B admin 集合执行 rs.status()，可以发现 B 服务器现在变成了主服务器了。&lt;/p&gt;

&lt;h3&gt;三、分片&lt;/h3&gt;

&lt;p&gt;有时候数据量比较大的时候我们需要把数据进行拆分，再把拆分后的数据分摊到每一个片上，这个地方有个“片键”的概念，也就是说拆分集合的依据是什么，按照什么键值进行拆分集合？&lt;/p&gt;

&lt;h4&gt;1、 模型图&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/nosql-2.png&quot; alt=&quot;分片服务器模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;说明下：&lt;/p&gt;

&lt;p&gt;mongos：就是一个路由服务器，它会根据管理员设置的“片键”将数据分摊到自己管理的mongod集群，数据和片的对应关系以及相应的配置信息保存在&quot;config服务器&quot;上；&lt;/p&gt;

&lt;p&gt;mongod：就是一个普通的数据库实例。&lt;/p&gt;

&lt;h4&gt;2、 实践&lt;/h4&gt;

&lt;p&gt;根据上图可以看出来，这里需要用到4个mongodb的服务器，mogos服务器、config服务器、两个mogod单服务器；&lt;/p&gt;

&lt;p&gt;1) 开启config服务器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongod --config mongodb.config --port 2222
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2) 开启mongos服务器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongos --port 3333 --configdb=127.0.0.1:2222
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3) 启动mogod服务器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongod --config mongodb.config --port 4444
mongod --config mongodb.config --port 5555
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4) mogos服务器配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;E:\mongodb-win32-x86_64-2.4.5\bin&amp;gt;mongo 127.0.0.1:3333/admin
MongoDB shell version: 2.4.5
connecting to: 127.0.0.1:3333/admin
mongos&amp;gt; db.runCommand({addshard : &quot;localhost:4444&quot;, allowLocal : true})
{ &quot;shardAdded&quot; : &quot;shard0000&quot;, &quot;ok&quot; : 1 }
mongos&amp;gt; db.runCommand({addshard : &quot;localhost:5555&quot;, allowLocal : true})
{ &quot;shardAdded&quot; : &quot;shard0001&quot;, &quot;ok&quot; : 1 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候已经为mongos服务器成功添加了两个mogod节点。&lt;/p&gt;

&lt;p&gt;5) 开启数据库分片功能，指定集合中分片的片键&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongos&amp;gt; db.runCommand({enablesharding:'test'})
{ &quot;ok&quot; : 1 }
mongos&amp;gt; db.runCommand({shardcollection:'test.person',key:{name:1}})
{ &quot;collectionsharded&quot; : &quot;test.person&quot;, &quot;ok&quot; : 1 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6) 测试分片效果，插入10w条记录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongos&amp;gt; use  test
switched to db test
mongos&amp;gt; for(var i = 0; i &amp;lt; 100000; i++) {
... db.person.insert({name:'jacky'+i,age:i})
... }
mongos&amp;gt; db.printShardingStatus()
--- Sharding Status ---
  sharding version: {
        &quot;_id&quot; : 1,
        &quot;version&quot; : 3,
        &quot;minCompatibleVersion&quot; : 3,
        &quot;currentVersion&quot; : 4,
        &quot;clusterId&quot; : ObjectId(&quot;51ee5bc0cdc1e6433d02a9a6&quot;)
}
  shards:
        {  &quot;_id&quot; : &quot;shard0000&quot;,  &quot;host&quot; : &quot;localhost:4444&quot; }
        {  &quot;_id&quot; : &quot;shard0001&quot;,  &quot;host&quot; : &quot;localhost:5555&quot; }
  databases:
        {  &quot;_id&quot; : &quot;admin&quot;,  &quot;partitioned&quot; : false,  &quot;primary&quot; : &quot;config&quot; }
        {  &quot;_id&quot; : &quot;test&quot;,  &quot;partitioned&quot; : true,  &quot;primary&quot; : &quot;shard0000&quot; }
                test.person
                        shard key: { &quot;name&quot; : 1 }
                        chunks:
                                shard0000       2
                                shard0001       1
                        { &quot;name&quot; : { &quot;$minKey&quot; : 1 } } --&amp;gt;&amp;gt; { &quot;name&quot; : &quot;jacky0&quot; } on : shard0000 Timestamp(2, 1)
                        { &quot;name&quot; : &quot;jacky0&quot; } --&amp;gt;&amp;gt; { &quot;name&quot; : &quot;jacky9999&quot; } on : shard0000 Timestamp(1, 3)
                        { &quot;name&quot; : &quot;jacky9999&quot; } --&amp;gt;&amp;gt; { &quot;name&quot; : { &quot;$maxKey&quot; : 1 } } on : shard0001 Timestamp(2, 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出shards已经是两个分片了，另外默认集合被分成了三段：无穷小-&gt;jacky0；jacky0-jacky9999；jacky9999-无穷大。但这个结果并不理想，因为他是按字母来排序的，也就是2库只分到了11条记录，绝大部分被分到了一库，不过分片的原理就是这样，具体的应用还是根据实际的需求来规划数据分键。&lt;/p&gt;

&lt;h3&gt;总结&lt;/h3&gt;

&lt;p&gt;大概也讲了不少了，NoSQL的强大也可见一斑，相比较以往关系型数据库而言NoSQL确实有很多优势，存储灵活、操作简单、性能高、易扩展等，但不是不要以为就可以完全替换关系型数据库，毕竟二者的应用场景不一样，没有最好的，只有最合适的。&lt;/p&gt;

&lt;p&gt;另外MongoDB也是有自身的缺点的，下面大概说下他几个主要的缺点：&lt;/p&gt;

&lt;h4&gt;1） mongodb占用存储空间大。&lt;/h4&gt;

&lt;p&gt;这主要是由三个因素决定的。第一，mongodb的空间预分配方式，这样会让mongodb最多浪费不超过2G+2G文件大小的空间。第二，mongodb的字段名占用，即使是相同的字段，mongodb也会在每一个文档中都存储，这里会浪费极大的空间。第三，mongodb删除数据并不会释放空间，而只是将空间记录为删除状态以便重用。&lt;/p&gt;

&lt;h4&gt;2） mongodb没有事务模式&lt;/h4&gt;

&lt;p&gt;所以事务要求严格的系统慎用。&lt;/p&gt;

&lt;h4&gt;3） mongodb没有join&lt;/h4&gt;

&lt;p&gt;毕竟数据都是有关联的，虽然也能通过一定的方式变向的实现一些简单的连接功能，但对于业务复杂的场景也不适合。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>hp-ux下编译64位Lua</title>
   <link href="http://www.blogways.net/blog/2013/07/18/hp-ux-lua-64.html"/>
   <updated>2013-07-18T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/07/18/hp-ux-lua-64</id>
   <content type="html">&lt;p&gt;在之前的一篇&lt;a href=&quot;../../06/20/aix-64-lua.html&quot;&gt;文章&lt;/a&gt;中，我们介绍了IBM AIX下编译64为Lua代码。在这里，我们介绍如何在HP-UX下编译64为Lua源码。&lt;/p&gt;

&lt;p&gt;目前，官方默认支持的编译平台是&lt;code&gt;aix ansi bsd freebsd generic linux macosx mingw posix solaris&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;没关系，我们来修改官方的&lt;code&gt;Makefile&lt;/code&gt;文件，让他支持&lt;code&gt;hp-ux&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;修改一：增加支持的平台代码 &lt;code&gt;hp&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;源码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PLATS= aix ansi bsd freebsd generic linux macosx mingw posix solaris
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PLATS= aix ansi bsd freebsd generic linux macosx mingw posix solaris hp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改二：增加编译命令&lt;/p&gt;

&lt;p&gt;在源码中增加：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hp:
    $(MAKE) all CC=&quot;aCC -AC99 +DD64 -z +Z +DSblended&quot; CFLAGS=&quot;-O -DLUA_USE_POSIX -DLUA_USE_DLOPEN&quot; MYLIBS=&quot;-ldl&quot; MYLDFLAGS=&quot;-Wl,+s -Wl,+n&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Ok啦，可以编译了！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;编译吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make hp
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>jBPM5 vs Actitivi</title>
   <link href="http://www.blogways.net/blog/2013/07/16/activiti-jbpm-compare.html"/>
   <updated>2013-07-16T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/07/16/activiti-jbpm-compare</id>
   <content type="html">&lt;h2&gt;jBPM5 vs Actitivi&lt;/h2&gt;

&lt;p&gt;jBPM是目前市场上主流开源工作引擎之一，在创建者Tom Baeyens离开JBoss后，jBPM的下一个版本jBPM5完全放弃了jBPM4的基础代码，基于Drools Flow重头来过，目前官网已经推出了jBPM6的beta版本；Tom Baeyens加入Alfresco后很快推出了新的基于jBPM4的开源工作流系统Activiti。由此可以推测JBoss内部对jBPM未来版本的架构实现产生了严重的意见分歧。本文试着对二者做一些比较。&lt;/p&gt;

&lt;p&gt;在比较之前先看下两者的安装部署过程：&lt;/p&gt;

&lt;h3&gt;jBPM5安装及开发环境配置&lt;/h3&gt;

&lt;p&gt;1、安装JBPM之前，要求本机已安装了&lt;code&gt;JDk1.5+&lt;/code&gt;版本和&lt;code&gt;ANT1.7+&lt;/code&gt;版本。&lt;/p&gt;

&lt;p&gt;2、JDK和ANT都安装完毕之后，到&lt;code&gt;http://sourceforge.net/projects/jbpm/files/&lt;/code&gt;下载JBPM-installer,下载完之后，解压到安装目录，jbpm-installer文件夹里有个install.html，里面有英文版的安装教程，可以作为参考。&lt;/p&gt;

&lt;p&gt;3、在CMD下进入刚才的\jbpm-installer目录，运行&lt;code&gt;ant install.demo&lt;/code&gt;，该命令会执行下面一系列的操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;下载JBoss AS
下载Eclipse
安装Drools Guvnor 到JBoss AS
安装Oryx Designer 到JBoss AS
安装jBPM Console 到JBoss AS
安装jBPM Eclipse 插件
安装Drools Eclipse 插件
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：这边下载的东西比较多，有好几百兆，如果本地网络不怎么好或者有些东西机上已经有了的话就可以单独下载需要的&lt;/p&gt;

&lt;p&gt;例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ant install.jBPM.runtime
ant install.guvnor.into.jboss
ant install.designer.into.jboss
ant install.jBPM-gwt-console.into.jboss
ant install.droolsjbpm-eclipse.into.eclipse
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4、下面可以准备启动JBPM了。CMD到\jbpm-installer目录下，依次运行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ant start.h2 （启动h2数据库）
ant start.jboss （启动JBoss AS）
ant start.human.task （启动 task service）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5、Jboss启动之后，可以在http://localhost:8080/访问，jbpm自带的web控制台 http://localhost:8080/jbpm-console，登录的用户名、密码均为krisv，在web控制台中可启动一个新流程、查看正在执行流程的当前状态、查看当前登录人待办任务以及并可以以报表形式查看、跟踪流程状态。
Drools Guvnor的访问地址为：http://localhost:8080/drools-guvnor。&lt;/p&gt;

&lt;p&gt;6、把eclipse目录下的features和plugins中的内容copy到eclipse的相应目录中。启动Eclipse之后，现在可以使用eclipse导入jbpm自带的一个流程。方法为依次点击File -&gt; Import ，在General category下选择“Existing Projects into Workspace”，找到位于jbpm安装根目录/sample/evaluation文件夹，将该项目导入。&lt;/p&gt;

&lt;h3&gt;Activiti安装及开发环境配置&lt;/h3&gt;

&lt;p&gt;1、 到&lt;code&gt;http://www.activiti.org/download.html&lt;/code&gt;下载activiti-5.13.zip，解压到安装目录，页面上有个&lt;code&gt;The User Guide&lt;/code&gt;，这个教程比较详细，如需要可深入学习下。&lt;/p&gt;

&lt;p&gt;2、 打开解压目录，\wars下面有两个war包，把&lt;code&gt;activiti-explorer.war&lt;/code&gt;部署到应用服务器中，里面默认的数据源是h2的内存数据库，如需要改成自己的数据库；&lt;/p&gt;

&lt;p&gt;3、 安装完成后可以在&lt;code&gt;http://localhost:8080/activiti-explorer&lt;/code&gt;处访问 Activiti Explorer web 应用程序，id/pwd: kermit/Kermit(这个账号是administrator)，这个程序是流程引擎的用户接口，用户可以使用这个工具来执行启动新流程，分配用户任务，浏览或领取任务等操作。还可以用来执行 Activiti 引擎的管理工作；&lt;/p&gt;

&lt;p&gt;4、 Activiti 提供了基于 Eclipse 插件的开发工具和流程设计工具 ( 需要 Eclipse 的版本为 Helios 或 Indigo，如果尚未安装 Eclipse，请从 http://www.eclipse.org/downloads/下载安装最新版本的 Eclipse 集成开发环境。)。这些工具可以使用 Eclipse 的”Install new software”功能在线安装，安装方法如下：&lt;/p&gt;

&lt;p&gt;在 Eclipse 的 Help 菜单中选择 Install New Software 选项，在弹出菜单中，点击 Add Repository 按钮添加新的远程 Software Repository，如图 3 所示，在 Location 中添加 http://activiti.org/designer/update/ 作为 Repository 的远程地址。当新的 Repository 添加完成后，Eclipse 会自动获取 Repository 中的软件列表。&lt;/p&gt;

&lt;p&gt;5、 现在我们开始创建工作流。右键点击项目根目录，选择new -&gt; others，选择Activiti -&gt; Activiti Diagram。&lt;/p&gt;

&lt;p&gt;流程开发跟部署就不在这边说了，都是界面化的开发工具，两个都可以保存成同样的格式，也可以用同一个插件来开发。&lt;/p&gt;

&lt;h3&gt;jBPM5与Activiti5比较&lt;/h3&gt;

&lt;h4&gt;主要相似之处：&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;都是BPMN2过程建模和执行环境。
都是BPM系统（符合BPM规范）。
都是开源项目-遵循ASL协议（ Apache的 软件许可）。
都源自JBoss（Activiti5是jBPM4的衍生，jBPM5则基于Drools Flow）。
都很成熟，从无到有，双方开始约始于2年半前。
都有对人工任务的生命周期管理。 Activiti5和jBPM5唯一的区别是jBPM5基于WebService - HumanTask标准来描述人工任务和管理生命周期。 如有兴趣了解这方面的标准及其优点，可参阅WS - HT规范介绍  。
都使用了不同风格的 Oryx 流程编辑器对BPMN2建模。 jBPM5采用的是 Intalio 维护的开源项目分支。 Activiti5则使用了Signavio维护的分支。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;Activiti5与jBPM5技术组成对比&lt;/h4&gt;

&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;em&gt;序号&lt;/em&gt;&lt;/td&gt;&lt;td&gt;&lt;em&gt;技术组成&lt;/em&gt;&lt;/td&gt;&lt;td&gt;&lt;em&gt;Activiti&lt;/em&gt;&lt;/td&gt;&lt;td&gt;&lt;em&gt;jBPM5&lt;/em&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;数据库持久层ORM&lt;/td&gt;&lt;td&gt;MyBatis3&lt;/td&gt;&lt;td&gt;Hibernate3&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;持久化标准&lt;/td&gt;&lt;td&gt;无&lt;/td&gt;&lt;td&gt;JPA规范&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;事务管理&lt;/td&gt;&lt;td&gt;MyBatis机制/Spring事务控制&lt;/td&gt;&lt;td&gt;Bitronix，基于JTA事务管理&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;数据库连接方式&lt;/td&gt;&lt;td&gt;Jdbc/DataSource&lt;/td&gt;&lt;td&gt;Jdbc/DataSource&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;支持数据库&lt;/td&gt;&lt;td&gt;Oracle、SQL Server、MySQL等多数数据库&lt;/td&gt;&lt;td&gt;Oracle、SQL Server、MySQL等多数数据库&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;设计模式&lt;/td&gt;&lt;td&gt;Command模式、观察者模式等&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;7&lt;/td&gt;&lt;td&gt;内部服务通讯&lt;/td&gt;&lt;td&gt;Service间通过API调用&lt;/td&gt;&lt;td&gt;基于Apache Mina异步通讯&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;8&lt;/td&gt;&lt;td&gt;集成接口&lt;/td&gt;&lt;td&gt;SOAP、Mule、RESTful&lt;/td&gt;&lt;td&gt;消息通讯&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;9&lt;/td&gt;&lt;td&gt;支持的流程格式&lt;/td&gt;&lt;td&gt;BPMN2、xPDL、jPDL等&lt;/td&gt;&lt;td&gt;目前仅只支持BPMN2 xml&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;引擎核心&lt;/td&gt;&lt;td&gt;PVM（流程虚拟机）&lt;/td&gt;&lt;td&gt;Drools&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;11&lt;/td&gt;&lt;td&gt;技术前身&lt;/td&gt;&lt;td&gt;jBPM3、jBPM4&lt;/td&gt;&lt;td&gt;Drools Flow&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;12&lt;/td&gt;&lt;td&gt;所属公司&lt;/td&gt;&lt;td&gt;Alfresco&lt;/td&gt;&lt;td&gt;jBoss.org&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;Activiti5使用Spring进行引擎配置以及各个Bean的管理，综合使用IoC和AOP技术，使用CXF作为Web Services实现的基础，使用MyBatis进行底层数据库ORM的管理，预先提供Bundle化包能较容易的与OSGi进行集成，通过与Mule ESB的集成和对外部服务（Web Service、RESTful等）的接口可以构建全面的SOA应用；jBPM5使用jBoss.org社区的大多数组件，以Drools Flow为核心组件作为流程引擎的核心构成，以Hibernate作为数据持久化ORM实现，采用基于JPA/JTA的可插拔的持久化和事务控制规范，使用Guvnor作为流程管理仓库，能够与Seam、Spring、OSGi等集成。&lt;/p&gt;

&lt;p&gt;需要指出的是Activiti5是在jBPM3、jBPM4的基础上发展而来的，是原jBPM的延续，而jBPM5则与之前的jBPM3、jBPM4没有太大关联，且舍弃了备受推崇的PVM（流程虚拟机）思想，转而选择jBoss自身产品Drools Flow作为流程引擎的核心实现，工作流最为重要的“人机交互”任务（类似于审批活动）则由单独的一块“Human Task Service”附加到Drools Flow上实现，任务的查询、处理等行为通过Apache Mina异步通信机制完成。&lt;/p&gt;

&lt;h4&gt;优劣对比：&lt;/h4&gt;

&lt;p&gt;从技术组成来看，Activiti最大的优势是采用了PVM（流程虚拟机），支持除了BPMN2.0规范之外的流程格式，与外部服务有良好的集成能力，延续了jBPM3、jBPM4良好的社区支持，服务接口清晰，链式API更为优雅；劣势是持久化层没有遵循JPA规范。&lt;/p&gt;

&lt;p&gt;jBPM最大的优势是采用了Apache Mina异步通信技术，采用JPA/JTA持久化方面的标准，以功能齐全的Guvnor作为流程仓库，有RedHat(jBoss.org被红帽收购)的专业化支持；但其劣势也很明显，对自身技术依赖过紧且目前仅支持BPMN2。&lt;/p&gt;

&lt;h3&gt;总结&lt;/h3&gt;

&lt;p&gt;虽然是比较，但不一定要有胜负，只有适合自己的才是最好的，要针对具体的项目区别对待。对我们自己的项目，其实我更关注的是流程引擎的执行效率以及性能，每小时几十万甚至上百万的流程需要执行，需要多少个服务，集群、负载的策略是什么，会不会有冲突？目前这方面的资料还是比较少的，很多问题只有实际遇用到的时候才会去想办法解决。不过就我个人的感觉而言，Activiti上手比较快，界面也比较简洁、直观，值得一试，不过jBPM6的beta版也已经出来了，不知道会有什么变化，有兴趣的也可以试下。&lt;/p&gt;

&lt;p&gt;参考|推荐文章：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;http://blog.csdn.net/howareyoutodaysoft/article/details/8070068&lt;/code&gt; &amp;lt;&amp;lt;BPMN2,activiti,jbpm5学习资料&gt;&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;http://www.infoq.com/cn/articles/rh-jbpm5-activiti5&lt;/code&gt;  &amp;lt;&amp;lt;纵观jBPM：从jBPM3到jBPM5以及Activiti5&gt;&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>AIX下安装cppunit记</title>
   <link href="http://www.blogways.net/blog/2013/06/26/aix-cppunit.html"/>
   <updated>2013-06-26T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/06/26/aix-cppunit</id>
   <content type="html">&lt;h3&gt;一、下载&lt;/h3&gt;

&lt;p&gt;从官网下载cppunit，笔者当前使用版本为1.12.1。&lt;/p&gt;

&lt;p&gt;下载地址为：&lt;a href=&quot;http://downloads.sourceforge.net/project/cppunit/cppunit/1.12.1/cppunit-1.12.1.tar.gz&quot;&gt;http://downloads.sourceforge.net/project/cppunit/cppunit/1.12.1/cppunit-1.12.1.tar.gz&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;二、解压&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;gzip -d cppunit-1.12.1.tar.gz
tar -xvf cppunit-1.12.1.tar
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;三、编译&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#进入解压后的源码目录
cd cppunit-1.12.1

#在aix下面编译，目前不支持生成动态库，仅生成的是静态库。
./configure --disable-shared

#也可以添加prefix参数，指定编译后需要安装的目录
./configure --disable-shared  --prefix=……

#编译
make

#安装
make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在执行&lt;code&gt;configure&lt;/code&gt;时，如果出现了&lt;code&gt;configure: error: C compiler cannot create executables&lt;/code&gt;这种错误，需要检查一下&lt;code&gt;config.log&lt;/code&gt;文件，看看是不是参数啥的配置错误了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总的来说，&lt;code&gt;cppunit&lt;/code&gt;在&lt;code&gt;aix&lt;/code&gt;下面安装还是相当顺利的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果想在&lt;code&gt;aix&lt;/code&gt;上编译生成64位的目标，配置命令如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./configure --disable-shared &quot;LDFLAGS=-q64&quot; &quot;CFLAGS=-q64&quot; &quot;CXXFLAGS=-q64&quot; &quot;AR_FLAGS=-X64 cru&quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是在hp下安装,相关命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./configure --enable-hpuxshl CC=cc CXX=aCC CXXFLAGS=&quot;-AA&quot;
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>AIX下编译redis代码</title>
   <link href="http://www.blogways.net/blog/2013/06/21/aix-redis.html"/>
   <updated>2013-06-21T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/06/21/aix-redis</id>
   <content type="html">&lt;p&gt;在IBM AIX平台下编译redis还是比较顺利的. 我没有直接使用官方的&lt;code&gt;Makefile&lt;/code&gt;，参考了下官方&lt;code&gt;Makefile&lt;/code&gt;中的编译依赖关系，按照平时常用的格式自己写了个&lt;code&gt;Makefile&lt;/code&gt;文件。&lt;/p&gt;

&lt;p&gt;首先，编译&lt;code&gt;hiredis&lt;/code&gt;时，主要在编译命令中定义了三个宏:&lt;code&gt;__HIREDIS_FMACRO_H&lt;/code&gt;、&lt;code&gt;_BSD_SOURCE&lt;/code&gt;、&lt;code&gt;AF_LOCAL=AF_UNIX&lt;/code&gt;,编译就顺利通过了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-D__HIREDIS_FMACRO_H -D_BSD_SOURCE -DAF_LOCAL=AF_UNIX 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译服务器代码，稍微麻烦点，因为编译过程中会提示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;redis.h&quot;, line 502.9: 1506-275 (S) Unexpected text integer constant encountered.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为，&lt;code&gt;redis.h&lt;/code&gt;中结构体&lt;code&gt;redisServer&lt;/code&gt;用到了一个名为&lt;code&gt;hz&lt;/code&gt;的成员,而&lt;code&gt;hz&lt;/code&gt;这玩意在aix平台下被定义过。至此，编译就报错了。&lt;/p&gt;

&lt;p&gt;我在文件中加了&lt;code&gt;#undef hz&lt;/code&gt;，解决了。&lt;/p&gt;

&lt;p&gt;同样，编译服务器代码，采用相同的思路，这次添加了四个宏定义，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-D_XOPEN_SOURCE_EXTENDED=1 -D_ISOC99_SOURCE -D_ALL_SOURCE -DAF_LOCAL=AF_UNIX
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上修改后，redis的服务器代码和客户端代码的编译顺利通过！&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>AIX下编译64位Lua</title>
   <link href="http://www.blogways.net/blog/2013/06/20/aix-64-lua.html"/>
   <updated>2013-06-20T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/06/20/aix-64-lua</id>
   <content type="html">&lt;p&gt;Lua是一个非常有名的脚本语言，是使用标准C编写而成的，目前官方提供了其在众多平台下的编译的&lt;code&gt;Makefile&lt;/code&gt;文件，非常强大！&lt;/p&gt;

&lt;p&gt;支持编译的平台有&lt;code&gt;aix ansi bsd freebsd generic linux macosx mingw posix solaris&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我在AIX下小试了一下，非常顺利地就编译通过了。&lt;/p&gt;

&lt;p&gt;不过默认编译出来的是32位的，其库文件不能被64位的程序调用，需要修改一下其&lt;code&gt;Makefile&lt;/code&gt;文件，就可以编译出64位版本。&lt;/p&gt;

&lt;p&gt;修改&lt;code&gt;Makefile&lt;/code&gt;需要考虑其原有的结构，不影响其他平台下的命令的执行。&lt;/p&gt;

&lt;p&gt;故此，编辑&lt;code&gt;Makefile&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd lua-5.2.2/src
vi Makefile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改其中&lt;code&gt;aix&lt;/code&gt;小节如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aix:
    $(MAKE) $(ALL) CC=&quot;xlc -q64&quot; AR=&quot;ar -X64 rcu&quot; CFLAGS=&quot;-O2 -DLUA_USE_POSIX -DLUA_USE_DLOPEN&quot; SYSLIBS=&quot;-ldl&quot; SYSLDFLAGS=&quot;-brtl -bexpall&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译出来的目标文件就是64位的了！&lt;/p&gt;

&lt;p&gt;后面我们会介绍如何在&lt;a href=&quot;../../07/18/hp-ux-lua-64.html&quot;&gt;&lt;code&gt;hp-ux&lt;/code&gt;&lt;/a&gt;环境下编译Lua源码。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Junit4测试类中测试方法的执行顺序</title>
   <link href="http://www.blogways.net/blog/2013/06/02/junit-test-execution-order.html"/>
   <updated>2013-06-02T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/06/02/junit-test-execution-order</id>
   <content type="html">&lt;p&gt;我正在使用的Junit的版本为4.11,其中测试类的执行顺序有三种指定方式：默认、按方法名顺序和JVM顺序。&lt;/p&gt;

&lt;p&gt;如果你不做任何指定，那么就是由默认顺序来执行，那么默认顺序是怎么确定的？他是由方法名的hash值的大小来确定，如果hash值大小一致，则按名字顺序确定。&lt;/p&gt;

&lt;p&gt;看下面Junit的实现代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * DEFAULT sort order
 */
public static Comparator&amp;lt;Method&amp;gt; DEFAULT = new Comparator&amp;lt;Method&amp;gt;() {
    public int compare(Method m1, Method m2) {
        int i1 = m1.getName().hashCode();
        int i2 = m2.getName().hashCode();
        if (i1 != i2) {
            return i1 &amp;lt; i2 ? -1 : 1;
        }
        return NAME_ASCENDING.compare(m1, m2);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了默认顺序，我们可以指定按方法的名字顺序来执行。指定方法是在测试类上加一个注释&lt;code&gt;FixMethodOrder(MethodSorters.NAME_ASCENDING)&lt;/code&gt;，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class MyTest {

    @Test
    public void test2() {
    ...
    }

    @Test
    public void test1() {
    …
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样执行顺序就是，先&lt;code&gt;test1&lt;/code&gt;再&lt;code&gt;test2&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;除了上述两种顺序，还有&lt;code&gt;JVM&lt;/code&gt;顺序，&lt;code&gt;JVM&lt;/code&gt;顺序使之按调用反射API的顺序来执行。什么意思？看代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Method[] methods = testClass.getDeclaredMethods();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也即是说,通过上面语句获取测试类的方法，返回的顺序就是测试的顺序。这种顺序，会由JVM的实现不同而顺序不同。一般情况下，是一个未明确的但是固定的顺序。&lt;/p&gt;

&lt;p&gt;使用时,也是在测试类上加一个注释&lt;code&gt;FixMethodOrder(MethodSorters.JVM)&lt;/code&gt;,方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@FixMethodOrder(MethodSorters.JVM)
public class MyTest {

    @Test
    public void test2() {
    ...
    }

    @Test
    public void test1() {
    …
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在我的机器上，上面代码执行顺序是：先&lt;code&gt;test2&lt;/code&gt;再&lt;code&gt;test1&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;通过上面的了解，如果你想指定你的测试类中方法的执行顺序，那么最好使用名字顺序(&lt;code&gt;MethodSorters.NAME_ASCENDING&lt;/code&gt;)，这样最方便最可靠。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Redis的Java客户端Jedis的八种调用方式(事务、管道、分布式…)介绍</title>
   <link href="http://www.blogways.net/blog/2013/06/02/jedis-demo.html"/>
   <updated>2013-06-02T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/06/02/jedis-demo</id>
   <content type="html">&lt;p&gt;redis是一个著名的key-value存储系统，而作为其官方推荐的java版客户端jedis也非常强大和稳定，支持事务、管道及有jedis自身实现的分布式。&lt;/p&gt;

&lt;p&gt;在这里对jedis关于事务、管道和分布式的调用方式做一个简单的介绍和对比：&lt;/p&gt;

&lt;h3&gt;一、普通同步方式&lt;/h3&gt;

&lt;p&gt;最简单和基础的调用方式，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void test1Normal() {
    Jedis jedis = new Jedis(&quot;localhost&quot;);
    long start = System.currentTimeMillis();
    for (int i = 0; i &amp;lt; 100000; i++) {
        String result = jedis.set(&quot;n&quot; + i, &quot;n&quot; + i);
    }
    long end = System.currentTimeMillis();
    System.out.println(&quot;Simple SET: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);
    jedis.disconnect();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很简单吧，每次&lt;code&gt;set&lt;/code&gt;之后都可以返回结果，标记是否成功。&lt;/p&gt;

&lt;h3&gt;二、事务方式(Transactions)&lt;/h3&gt;

&lt;p&gt;redis的事务很简单，他主要目的是保障，一个client发起的事务中的命令可以连续的执行，而中间不会插入其他client的命令。&lt;/p&gt;

&lt;p&gt;看下面例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void test2Trans() {
    Jedis jedis = new Jedis(&quot;localhost&quot;);
    long start = System.currentTimeMillis();
    Transaction tx = jedis.multi();
    for (int i = 0; i &amp;lt; 100000; i++) {
        tx.set(&quot;t&quot; + i, &quot;t&quot; + i);
    }
    List&amp;lt;Object&amp;gt; results = tx.exec();
    long end = System.currentTimeMillis();
    System.out.println(&quot;Transaction SET: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);
    jedis.disconnect();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们调用&lt;code&gt;jedis.watch(…)&lt;/code&gt;方法来监控key，如果调用后key值发生变化，则整个事务会执行失败。另外，事务中某个操作失败，并不会回滚其他操作。这一点需要注意。还有，我们可以使用&lt;code&gt;discard()&lt;/code&gt;方法来取消事务。&lt;/p&gt;

&lt;h3&gt;三、管道(Pipelining)&lt;/h3&gt;

&lt;p&gt;有时，我们需要采用异步方式，一次发送多个指令，不同步等待其返回结果。这样可以取得非常好的执行效率。这就是管道，调用方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void test3Pipelined() {
    Jedis jedis = new Jedis(&quot;localhost&quot;);
    Pipeline pipeline = jedis.pipelined();
    long start = System.currentTimeMillis();
    for (int i = 0; i &amp;lt; 100000; i++) {
        pipeline.set(&quot;p&quot; + i, &quot;p&quot; + i);
    }
    List&amp;lt;Object&amp;gt; results = pipeline.syncAndReturnAll();
    long end = System.currentTimeMillis();
    System.out.println(&quot;Pipelined SET: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);
    jedis.disconnect();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;四、管道中调用事务&lt;/h3&gt;

&lt;p&gt;就Jedis提供的方法而言，是可以做到在管道中使用事务，其代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void test4combPipelineTrans() {
    jedis = new Jedis(&quot;localhost&quot;); 
    long start = System.currentTimeMillis();
    Pipeline pipeline = jedis.pipelined();
    pipeline.multi();
    for (int i = 0; i &amp;lt; 100000; i++) {
        pipeline.set(&quot;&quot; + i, &quot;&quot; + i);
    }
    pipeline.exec();
    List&amp;lt;Object&amp;gt; results = pipeline.syncAndReturnAll();
    long end = System.currentTimeMillis();
    System.out.println(&quot;Pipelined transaction: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);
    jedis.disconnect();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是经测试（见本文后续部分），发现其效率和单独使用事务差不多，甚至还略微差点。&lt;/p&gt;

&lt;h3&gt;五、分布式直连同步调用&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void test5shardNormal() {
    List&amp;lt;JedisShardInfo&amp;gt; shards = Arrays.asList(
            new JedisShardInfo(&quot;localhost&quot;,6379),
            new JedisShardInfo(&quot;localhost&quot;,6380));

    ShardedJedis sharding = new ShardedJedis(shards);

    long start = System.currentTimeMillis();
    for (int i = 0; i &amp;lt; 100000; i++) {
        String result = sharding.set(&quot;sn&quot; + i, &quot;n&quot; + i);
    }
    long end = System.currentTimeMillis();
    System.out.println(&quot;Simple@Sharing SET: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);

    sharding.disconnect();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个是分布式直接连接，并且是同步调用，每步执行都返回执行结果。类似地，还有异步管道调用。&lt;/p&gt;

&lt;h3&gt;六、分布式直连异步调用&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void test6shardpipelined() {
    List&amp;lt;JedisShardInfo&amp;gt; shards = Arrays.asList(
            new JedisShardInfo(&quot;localhost&quot;,6379),
            new JedisShardInfo(&quot;localhost&quot;,6380));

    ShardedJedis sharding = new ShardedJedis(shards);

    ShardedJedisPipeline pipeline = sharding.pipelined();
    long start = System.currentTimeMillis();
    for (int i = 0; i &amp;lt; 100000; i++) {
        pipeline.set(&quot;sp&quot; + i, &quot;p&quot; + i);
    }
    List&amp;lt;Object&amp;gt; results = pipeline.syncAndReturnAll();
    long end = System.currentTimeMillis();
    System.out.println(&quot;Pipelined@Sharing SET: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);

    sharding.disconnect();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;七、分布式连接池同步调用&lt;/h3&gt;

&lt;p&gt;如果，你的分布式调用代码是运行在线程中，那么上面两个直连调用方式就不合适了，因为直连方式是非线程安全的，这个时候，你就必须选择连接池调用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void test7shardSimplePool() {
    List&amp;lt;JedisShardInfo&amp;gt; shards = Arrays.asList(
            new JedisShardInfo(&quot;localhost&quot;,6379),
            new JedisShardInfo(&quot;localhost&quot;,6380));

    ShardedJedisPool pool = new ShardedJedisPool(new JedisPoolConfig(), shards);

    ShardedJedis one = pool.getResource();

    long start = System.currentTimeMillis();
    for (int i = 0; i &amp;lt; 100000; i++) {
        String result = one.set(&quot;spn&quot; + i, &quot;n&quot; + i);
    }
    long end = System.currentTimeMillis();
    pool.returnResource(one);
    System.out.println(&quot;Simple@Pool SET: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);

    pool.destroy();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是同步方式，当然还有异步方式。&lt;/p&gt;

&lt;h3&gt;八、分布式连接池异步调用&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void test8shardPipelinedPool() {
    List&amp;lt;JedisShardInfo&amp;gt; shards = Arrays.asList(
            new JedisShardInfo(&quot;localhost&quot;,6379),
            new JedisShardInfo(&quot;localhost&quot;,6380));

    ShardedJedisPool pool = new ShardedJedisPool(new JedisPoolConfig(), shards);

    ShardedJedis one = pool.getResource();

    ShardedJedisPipeline pipeline = one.pipelined();

    long start = System.currentTimeMillis();
    for (int i = 0; i &amp;lt; 100000; i++) {
        pipeline.set(&quot;sppn&quot; + i, &quot;n&quot; + i);
    }
    List&amp;lt;Object&amp;gt; results = pipeline.syncAndReturnAll();
    long end = System.currentTimeMillis();
    pool.returnResource(one);
    System.out.println(&quot;Pipelined@Pool SET: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);
    pool.destroy();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;九、需要注意的地方&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;事务和管道都是异步模式。在事务和管道中不能同步查询结果。比如下面两个调用，都是不允许的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; Transaction tx = jedis.multi();
 for (int i = 0; i &amp;lt; 100000; i++) {
     tx.set(&quot;t&quot; + i, &quot;t&quot; + i);
 }
 System.out.println(tx.get(&quot;t1000&quot;).get());  //不允许

 List&amp;lt;Object&amp;gt; results = tx.exec();

 …
 …

 Pipeline pipeline = jedis.pipelined();
 long start = System.currentTimeMillis();
 for (int i = 0; i &amp;lt; 100000; i++) {
     pipeline.set(&quot;p&quot; + i, &quot;p&quot; + i);
 }
 System.out.println(pipeline.get(&quot;p1000&quot;).get()); //不允许

 List&amp;lt;Object&amp;gt; results = pipeline.syncAndReturnAll();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;事务和管道都是异步的，个人感觉，在管道中再进行事务调用，没有必要，不如直接进行事务模式。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分布式中，连接池的性能比直连的性能略好(见后续测试部分)。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分布式调用中不支持事务。&lt;/p&gt;

&lt;p&gt; 因为事务是在服务器端实现，而在分布式中，每批次的调用对象都可能访问不同的机器，所以，没法进行事务。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;十、测试&lt;/h3&gt;

&lt;p&gt;运行上面的代码，进行测试，其结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Simple SET: 5.227 seconds

Transaction SET: 0.5 seconds
Pipelined SET: 0.353 seconds
Pipelined transaction: 0.509 seconds

Simple@Sharing SET: 5.289 seconds
Pipelined@Sharing SET: 0.348 seconds

Simple@Pool SET: 5.039 seconds
Pipelined@Pool SET: 0.401 seconds
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，经测试分布式中用到的机器越多，调用会越慢。上面是2片，下面是5片：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Simple@Sharing SET: 5.494 seconds
Pipelined@Sharing SET: 0.51 seconds
Simple@Pool SET: 5.223 seconds
Pipelined@Pool SET: 0.518 seconds
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是10片：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Simple@Sharing SET: 5.9 seconds
Pipelined@Sharing SET: 0.794 seconds
Simple@Pool SET: 5.624 seconds
Pipelined@Pool SET: 0.762 seconds
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是100片：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Simple@Sharing SET: 14.055 seconds
Pipelined@Sharing SET: 8.185 seconds
Simple@Pool SET: 13.29 seconds
Pipelined@Pool SET: 7.767 seconds
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分布式中，连接池方式调用不但线程安全外，根据上面的测试数据，也可以看出连接池比直连的效率更好。&lt;/p&gt;

&lt;h3&gt;十一、完整的测试代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package com.example.nosqlclient;

import java.util.Arrays;
import java.util.List;

import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisPoolConfig;
import redis.clients.jedis.JedisShardInfo;
import redis.clients.jedis.Pipeline;
import redis.clients.jedis.ShardedJedis;
import redis.clients.jedis.ShardedJedisPipeline;
import redis.clients.jedis.ShardedJedisPool;
import redis.clients.jedis.Transaction;

import org.junit.FixMethodOrder;
import org.junit.runners.MethodSorters;

@FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class TestJedis {

    private static Jedis jedis;
    private static ShardedJedis sharding;
    private static ShardedJedisPool pool;

    @BeforeClass
    public static void setUpBeforeClass() throws Exception {
        List&amp;lt;JedisShardInfo&amp;gt; shards = Arrays.asList(
                new JedisShardInfo(&quot;localhost&quot;,6379),
                new JedisShardInfo(&quot;localhost&quot;,6379)); //使用相同的ip:port,仅作测试


        jedis = new Jedis(&quot;localhost&quot;); 
        sharding = new ShardedJedis(shards);

        pool = new ShardedJedisPool(new JedisPoolConfig(), shards);
    }

    @AfterClass
    public static void tearDownAfterClass() throws Exception {
        jedis.disconnect();
        sharding.disconnect();
        pool.destroy();
    }

    @Test
    public void test1Normal() {
        long start = System.currentTimeMillis();
        for (int i = 0; i &amp;lt; 100000; i++) {
            String result = jedis.set(&quot;n&quot; + i, &quot;n&quot; + i);
        }
        long end = System.currentTimeMillis();
        System.out.println(&quot;Simple SET: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);
    }

    @Test
    public void test2Trans() {
        long start = System.currentTimeMillis();
        Transaction tx = jedis.multi();
        for (int i = 0; i &amp;lt; 100000; i++) {
            tx.set(&quot;t&quot; + i, &quot;t&quot; + i);
        }
        //System.out.println(tx.get(&quot;t1000&quot;).get());

        List&amp;lt;Object&amp;gt; results = tx.exec();
        long end = System.currentTimeMillis();
        System.out.println(&quot;Transaction SET: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);
    }

    @Test
    public void test3Pipelined() {
        Pipeline pipeline = jedis.pipelined();
        long start = System.currentTimeMillis();
        for (int i = 0; i &amp;lt; 100000; i++) {
            pipeline.set(&quot;p&quot; + i, &quot;p&quot; + i);
        }
        //System.out.println(pipeline.get(&quot;p1000&quot;).get());
        List&amp;lt;Object&amp;gt; results = pipeline.syncAndReturnAll();
        long end = System.currentTimeMillis();
        System.out.println(&quot;Pipelined SET: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);
    }

    @Test
    public void test4combPipelineTrans() {
        long start = System.currentTimeMillis();
        Pipeline pipeline = jedis.pipelined();
        pipeline.multi();
        for (int i = 0; i &amp;lt; 100000; i++) {
            pipeline.set(&quot;&quot; + i, &quot;&quot; + i);
        }
        pipeline.exec();
        List&amp;lt;Object&amp;gt; results = pipeline.syncAndReturnAll();
        long end = System.currentTimeMillis();
        System.out.println(&quot;Pipelined transaction: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);
    }

    @Test
    public void test5shardNormal() {
        long start = System.currentTimeMillis();
        for (int i = 0; i &amp;lt; 100000; i++) {
            String result = sharding.set(&quot;sn&quot; + i, &quot;n&quot; + i);
        }
        long end = System.currentTimeMillis();
        System.out.println(&quot;Simple@Sharing SET: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);
    }

    @Test
    public void test6shardpipelined() {
        ShardedJedisPipeline pipeline = sharding.pipelined();
        long start = System.currentTimeMillis();
        for (int i = 0; i &amp;lt; 100000; i++) {
            pipeline.set(&quot;sp&quot; + i, &quot;p&quot; + i);
        }
        List&amp;lt;Object&amp;gt; results = pipeline.syncAndReturnAll();
        long end = System.currentTimeMillis();
        System.out.println(&quot;Pipelined@Sharing SET: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);
    }

    @Test
    public void test7shardSimplePool() {
        ShardedJedis one = pool.getResource();

        long start = System.currentTimeMillis();
        for (int i = 0; i &amp;lt; 100000; i++) {
            String result = one.set(&quot;spn&quot; + i, &quot;n&quot; + i);
        }
        long end = System.currentTimeMillis();
        pool.returnResource(one);
        System.out.println(&quot;Simple@Pool SET: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);
    }

    @Test
    public void test8shardPipelinedPool() {
        ShardedJedis one = pool.getResource();

        ShardedJedisPipeline pipeline = one.pipelined();

        long start = System.currentTimeMillis();
        for (int i = 0; i &amp;lt; 100000; i++) {
            pipeline.set(&quot;sppn&quot; + i, &quot;n&quot; + i);
        }
        List&amp;lt;Object&amp;gt; results = pipeline.syncAndReturnAll();
        long end = System.currentTimeMillis();
        pool.returnResource(one);
        System.out.println(&quot;Pipelined@Pool SET: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>在服务器上创建 git 裸仓库</title>
   <link href="http://www.blogways.net/blog/2013/05/28/git-bare-repo-sever.html"/>
   <updated>2013-05-28T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/05/28/git-bare-repo-sever</id>
   <content type="html">&lt;p&gt;git裸仓库，就是指没有工作目录的仓库。简单点说，裸仓库就是你工作目录下面的 &lt;code&gt;.git&lt;/code&gt; 子目录里面的内容。&lt;/p&gt;

&lt;p&gt;远程仓库，一般不需要工作目录，所以通常都是裸仓库。&lt;/p&gt;

&lt;p&gt;如何在服务器上创建裸仓库？很简单，跟我来！&lt;/p&gt;

&lt;p&gt;如果你还没有代码，直接在服务器上创建裸仓库很简单，一个命令就够了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git init --bare
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是如果在本机，你已经有了一些代码，如何把这些代码部署到服务器上，并且仅仅部署成一个裸仓库呢？其实，也很简单，因为我们了解了 git 裸仓库实际上就是你工作目录下的 &lt;code&gt;.git&lt;/code&gt; 子目录的内容，拷过去就行了。&lt;/p&gt;

&lt;p&gt;所以，下面有三个思路，都可以实现：&lt;/p&gt;

&lt;h3&gt;思路一：在本机生成裸仓库，把裸仓库部署到服务器上&lt;/h3&gt;

&lt;p&gt;具体步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;本机生成裸仓库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $ git clone --bare my_project my_project.git

 $ cp -Rf my_project/.git my_project.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 上面两个命令结果一样，都可以根据现有的仓库生成一个裸仓库。按喜欢选择一个即可。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;部署到服务器上&lt;/p&gt;

&lt;p&gt; 可以用工具部署到远程服务器上，也可以用命令，命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $ scp -r my_project.git user@git.example.com:/opt/git
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;大功告成了&lt;/p&gt;

&lt;p&gt; 可以测试一下，获取远程服务器上的版本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $ git clone user@git.example.com:/opt/git/my_project.git
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;思路二：把本机的&lt;code&gt;.git&lt;/code&gt;目录部署到服务器上，然后改成裸仓库&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;将&lt;code&gt;.git&lt;/code&gt;目录部署到服务器上&lt;/p&gt;

&lt;p&gt; 可以用工具部署到远程服务器上，也可以用命令，命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $ scp -r my_project/.git user@git.example.com:/opt/git
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将服务器&lt;code&gt;.git&lt;/code&gt;目录改成裸仓库&lt;/p&gt;

&lt;p&gt; 在服务器上执行命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; cd /opt/git
 mv .git my_project.git
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;大功告成了&lt;/p&gt;

&lt;p&gt; 可以测试一下，获取远程服务器上的版本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $ git clone user@git.example.com:/opt/git/my_project.git
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;思路三：git push 到远程仓库&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;先在远程主机上建个裸仓库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $ mkdir my_project.git
 $ cd my_project.git
 $ git init --bare
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;给本地仓库添加一个远程仓库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; # git remote add &amp;lt;远程仓库名字&amp;gt; &amp;lt;地址&amp;gt;
 $ git remote add ball git@xxx.xxx.xxx.xxx:/path/to/my_project.git
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将本地仓库内容上传远程仓库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $ git push ball master
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;clone版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone -o jQuery https://github.com/jquery/jquery.git
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;注意：&lt;/h3&gt;

&lt;p&gt;按思路一、思路二创建的远程仓库，如果需要支持其他人&lt;code&gt;push&lt;/code&gt;数据，需要修改仓库下配置文件&lt;code&gt;config&lt;/code&gt;,添加如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[receive]
    denyCurrentBranch = ignore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;否则，可能会遇到在客户端不被允许向裸仓库&lt;code&gt;push&lt;/code&gt;数据。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>在Eclipse中创建Maven多模块工程的例子[20150428更新]</title>
   <link href="http://www.blogways.net/blog/2013/05/13/maven-multi-modules-demo.html"/>
   <updated>2013-05-13T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/05/13/maven-multi-modules-demo</id>
   <content type="html">&lt;p&gt;如果，你需要创建多个项目，项目之间即独立又有关系，那么创建一个Maven多模块项目是个非常好的选择，也非常cool！怎么在Eclipse里面创建多模块工程，以及需要注意哪些地方，我在这里做个简单的介绍。&lt;/p&gt;

&lt;h3&gt;一、准备&lt;/h3&gt;

&lt;p&gt;若想在Eclipse里面做这些的话，那么在做这一切前，请确认你是否已经在eclipse里面安装了maven插件。如果没有装插件，那只能通过命令行去做了。&lt;/p&gt;

&lt;p&gt;好，现在假设已经在Eclipse里面装了maven插件，那么我们一起用Eclipse来创建Maven多模块项目吧！&lt;/p&gt;

&lt;h3&gt;二、先创建父项目&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;在Eclipse里面New -&gt; &lt;code&gt;Maven Project&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;在弹出界面中选择“Create a simple project”&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置工程的参数，见下图&lt;br/&gt;&lt;img src=&quot;/images/post/maven-modules1.png&quot; alt=&quot;Params Settings&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Group Id: com.example&lt;/li&gt;
&lt;li&gt;Artifact Id: multi-modules-demo&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;Packaging: pom&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Name: Multi Modules Demo&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;点击完成&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;这样，我们就按常规模版创建了一个Maven工程。我们还需要对这个工程进行修改。&lt;/p&gt;

&lt;p&gt;因为，这是一个父项目，不需要有什么源码，那么，我们在Eclipse中将这个工程下的不用的目录都删除，仅留下&lt;code&gt;pom.xml&lt;/code&gt;文件就行了。&lt;/p&gt;

&lt;h3&gt;三、创建子项目&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;选中刚建的父项目，在弹出菜单中点击 New -&gt; &lt;code&gt;Maven Module&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;如图配置&lt;br/&gt;&lt;img src=&quot;/images/post/maven-modules3.png&quot; alt=&quot;child settings&quot; /&gt;&lt;/li&gt;
&lt;li&gt;使用默认的Archetype（默认：GroupId:org.apache.maven.archetypes,Artifact Id:maven-archetype-quickstart）&lt;/li&gt;
&lt;li&gt;完成工程配置，见下图&lt;br/&gt;&lt;img src=&quot;/images/post/maven-modules4.png&quot; alt=&quot;Params Settings&quot; /&gt;&lt;/li&gt;
&lt;li&gt;点击完成&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;这样一个子项目就创建完成了，在文件系统中，子项目会建在父项目的目录中。在父目录中运行&lt;code&gt;mvn test&lt;/code&gt;等命令，所有的子项目都会按顺序执行。&lt;/p&gt;

&lt;p&gt;细心一点的人，可能会发现，通过这个步骤创建子项目的同时，会修改父项目的&lt;code&gt;pom.xml&lt;/code&gt;，增加了类似下面的信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;modules&amp;gt;
    &amp;lt;module&amp;gt;module-children1-demo&amp;lt;/module&amp;gt;
&amp;lt;/modules&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个信息，就是标记有哪些子模块。&lt;/p&gt;

&lt;p&gt;重复创建子项目的步骤，可以创建多个子项目。&lt;/p&gt;

&lt;h3&gt;四、优化配置&lt;/h3&gt;

&lt;p&gt;虽然上面的步骤，可以完成多模块的创建，但是创建出来的多模块，在一个程序员的眼里，还是挺别扭的，怎么回事呢？对，存在重复。那让我们重构吧。&lt;/p&gt;

&lt;p&gt;按上面步骤创建的子项目，在&lt;code&gt;pom.xml&lt;/code&gt;中有个&lt;code&gt;parent&lt;/code&gt;节点，所以，他可以继承父项目的相关信息。没错，父子项目中存在继承关系。&lt;/p&gt;

&lt;p&gt;在子项目的&lt;code&gt;pom.xml&lt;/code&gt;中，子项目的&lt;code&gt;groupId&lt;/code&gt;和&lt;code&gt;version&lt;/code&gt;一般和父项目相同，那么可以把子项目的这两个参数删除，这样会自动继承父项目的取值。&lt;/p&gt;

&lt;p&gt;同样，如果其他的一些属性，所有子项目都是一样的，那么可以上移到父项目中设置，子项目中无需重复设置。比如：&lt;code&gt;&amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;&lt;/code&gt;可以仅在父项目中设置一次。&lt;/p&gt;

&lt;p&gt;除了这种情况以外，还有一种情况，就是依赖和插件。依赖和插件的情况是这样，某一个依赖或插件可能会被大部分子项目所使用，但是也可能有些子项目不需要使用，这样使用上述的方式，简简单单地进行继承就不合适了。&lt;/p&gt;

&lt;p&gt;Manen提供&lt;code&gt;dependencyManagement&lt;/code&gt;和&lt;code&gt;pluginManagement&lt;/code&gt;两个标签。使用这两个标签，可以在父项目中统一管理依赖和插件的配置参数，比如版本号啥的。而在子项目中，仅需列出需要使用的依赖和插件的&lt;code&gt;groupId&lt;/code&gt;和&lt;code&gt;artifactId&lt;/code&gt;就可以了，其他信息会自动从父项目管理的信息里面获取。&lt;/p&gt;

&lt;p&gt;看例子，父项目中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;dependencyManagement&amp;gt;
  &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${junit.version}&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.7.5&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.7.5&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;   
  &amp;lt;/dependencies&amp;gt;
&amp;lt;/dependencyManagement&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  在子项目中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;dependencies&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
  &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;四、命令行创建&lt;/h3&gt;

&lt;p&gt;上面就是在Eclipse里面创建多模块的步骤，和一些优化配置。&lt;/p&gt;

&lt;p&gt;其中，具体的步骤可以根据实际情况进行适当的修改，比如选择&lt;code&gt;Archetype&lt;/code&gt;时，可以根据需要，选择适当的&lt;code&gt;Archetype&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;上述步骤中的一些环节，也可以先通过命令行来生成雏形，然后再修改&lt;code&gt;pom.xml&lt;/code&gt;来实现。&lt;/p&gt;

&lt;p&gt;相关命令为:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mvn archetype:generate -DarchetypeCatalog=internal -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-quickstart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;工程创建后需要修改&lt;code&gt;pom.xml&lt;/code&gt;.修改方式，可以参考上面说到的内容。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Redis Linux Pipeline && 分布式</title>
   <link href="http://www.blogways.net/blog/2013/05/05/redis-usage-2.html"/>
   <updated>2013-05-05T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/05/05/redis-usage-2</id>
   <content type="html">&lt;h2&gt;事务&lt;/h2&gt;

&lt;p&gt;redis对事务的支持目前还比较简单。redis只能保证一个client发起的事务中的命令可以连续的执行，而中间不会插入其他client的命令。 由于redis是单线程来处理所有client的请求的所以做到这点是很容易的。一般情况下redis在接受到一个client发来的命令后会立即处理并 返回处理结果，但是当一个client在一个连接中发出multi命令有，这个连接会进入一个事务上下文，该连接后续的命令并不是立即执行，而是先放到一 个队列中。当从此连接受到exec命令后，redis会顺序的执行队列中的所有命令。并将所有命令的运行结果打包到一起返回给client.然后此连接就 结束事务上下文。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6479&amp;gt; multi
OK
redis 127.0.0.1:6479&amp;gt; incr a
QUEUED
redis 127.0.0.1:6479&amp;gt; incr b
QUEUED
redis 127.0.0.1:6479&amp;gt; get a
QUEUED
redis 127.0.0.1:6479&amp;gt; get b
QUEUED
redis 127.0.0.1:6479&amp;gt; exec
1) (integer) 1
2) (integer) 1
3) &quot;1&quot;
4) &quot;1&quot;
redis 127.0.0.1:6479&amp;gt; get a
&quot;1&quot;
redis 127.0.0.1:6479&amp;gt; get b
&quot;1&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;批量操作效率的确的很大的提高，但同时也会带来其他的问题，因为 redis 本身并不提供同步锁机制，如果在批量执行的过程中另一个客户端对批量里面的元素进行操作，当调用 exec 执行的时候发现结果已经不是我们想要的结果了，还好 redis2.1 后添加了 watch 命令，可以用来实现乐观锁，通过对元素的监控来判断在等待的过程中元素的值有没有发生变化，如果有则执行失败。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6479&amp;gt; watch a
OK
redis 127.0.0.1:6479&amp;gt; get a
&quot;5&quot;
redis 127.0.0.1:6479&amp;gt; multi
OK
redis 127.0.0.1:6479&amp;gt; set a 2
QUEUED
redis 127.0.0.1:6479&amp;gt; exec
(nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;redis 的事务是如此简单，当然也会存在一些问题，首先 redis 只能保证每个命令连续执行，如果事务中一个命令失败了，并不回滚其他的命令，这样就会导致的事务的完整性无法得到保证。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6479&amp;gt; set a 5
OK
redis 127.0.0.1:6479&amp;gt; lpush b 5
(integer) 1
redis 127.0.0.1:6479&amp;gt; multi
OK
redis 127.0.0.1:6479&amp;gt; incr a
QUEUED
redis 127.0.0.1:6479&amp;gt; incr b
QUEUED
redis 127.0.0.1:6479&amp;gt; exec
1) (integer) 6
2) (error) ERR Operation against a key holding the wrong kind of value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一个十分罕见的问题是 当事务的执行过程中，如果redis意外的挂了。很遗憾只有部分命令执行了，后面的也就被丢弃了。当然如果我们使用的append-only file方式持久化，redis会用单个write操作写入整个事务内容。即是是这种方式还是有可能只部分写入了事务到磁盘。发生部分写入事务的情况 下，redis重启时会检测到这种情况，然后失败退出。可以使用redis-check-aof工具进行修复，修复会删除部分写入的事务内容。修复完后就 能够重新启动了。&lt;/p&gt;

&lt;h2&gt;pipeline&lt;/h2&gt;

&lt;p&gt;redis是一个cs模式的tcp server，使用和http类似的请求响应协议。一个client可以通过一个socket连接发起多个请求命令。每个请求命令发出后client通常 会阻塞并等待redis服务处理，redis处理完后请求命令后会将结果通过响应报文返回给client。我们还可以利用pipeline的方式从client打包多条命令一起发出，不需要等待单条命令的响应返回，而redis服务端会处理完多条命令后会将多条命令的处理结果打包到一起返回给客户端。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;String host = &quot;127.0.0.1&quot;;
int port = 6479, timeout = 30000;
Jedis jedis = new Jedis(host, port, timeout);
Pipeline p = jedis.pipelined();
for (int i = 1; i &amp;lt;= 500000; i++) {
    String key = &quot;comppara_&quot; + i;
    String value = &quot;{param1: &quot; + i + &quot;, param2: &quot; + i + &quot;, param3: &quot; + i + &quot;}&quot;;
    p.set(key, value);
}
p.sync();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过 pipeline 模式，set 跟 get 效率有了明显的提交，前面测试的50W数据导入只需要不到3秒种，读2秒左右。&lt;/p&gt;

&lt;h2&gt;redis持久化&lt;/h2&gt;

&lt;p&gt;redis是一个支持持久化的内存数据库，也就是说redis需要经常将内存中的数据同步到磁盘来保证持久化。redis支持两种持久化方式，一种是 Snapshotting（快照）也是默认方式，另一种是Append-only file（缩写aof）的方式。下面分别介绍&lt;/p&gt;

&lt;p&gt;Snapshotting
快照是默认的持久化方式。这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。可以通过配置设置自动做快照持久 化的方式。我们可以配置redis在n秒内如果超过m个key被修改就自动做快照，下面是默认的快照保存配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;save 900 1  #900秒内如果超过1个key被修改，则发起快照保存
save 300 10 #300秒内容如超过10个key被修改，则发起快照保存
save 60 10000
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;分布式&lt;/h2&gt;

&lt;p&gt;在jedis的源码里发现了两种hash算法（MD5，MURMUR Hash(默认）），也可以自己实现redis.clients.util.Hashing接口扩展。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List&amp;lt;JedisShardInfo&amp;gt; hosts = new ArrayList&amp;lt;JedisShardInfo&amp;gt;();

JedisShardInfo host1 = new JedisShardInfo(&quot;127.0.0.1&quot;, 6479, 3000);
JedisShardInfo host2 = new JedisShardInfo(&quot;192.168.4.17&quot;, 6479, 3000);

hosts.add(host1);
hosts.add(host2);

ShardedJedis jedis = new ShardedJedis(hosts);
ShardedJedisPipeline p = jedis.pipelined();

for (int i = 1; i &amp;lt;= 10000; i++) {
    String key = &quot;shard_&quot; + i;
    String value = &quot;value_&quot; + i;
    p.set(key, value);
}

p.sync();
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>Redis Linux 数据类型</title>
   <link href="http://www.blogways.net/blog/2013/05/05/redis-usage.html"/>
   <updated>2013-05-05T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/05/05/redis-usage</id>
   <content type="html">&lt;h2&gt;数据类型&lt;/h2&gt;

&lt;h3&gt;keys&lt;/h3&gt;

&lt;p&gt;redis本质上还是一个key-value db，所以我们首先来看看他的key。&lt;/p&gt;

&lt;p&gt;相关命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exists key 测试指定的 key 是否存在，真1｜假0
del key1 key2 ... keyn 返回删除的 key 的数目，0表示不存在
type key 返回 key 的 value 类型
keys pattern 返回匹配指定模式的所有 key
randomkey 随机返回一个 key
rename oldkey newkey 重命名一个 key，如果 newkey 存在会被覆盖
renamenx oldkey newkey 同上，如果 newkey 存在返回失败
dbsize 返回当前数据库的 key 数量
expire key seconds 为 key 指定过期时间，单位是秒
ttl key 返回设置过期时间的 key 的剩余过期时间
select db-index 通过索引选择数据库，默认连接的是数据库0，默认数据库数是16个
move key db-index 将 key 从当前数据库移动到指定数据库
flushdb 删除当前数据库里面所有的 key
flushall 删除所有数据库中所有的 key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6479&amp;gt; set test 1
OK
redis 127.0.0.1:6479&amp;gt; set tast 2
OK
redis 127.0.0.1:6479&amp;gt; set tist 3
OK
redis 127.0.0.1:6479&amp;gt; exists test
(integer) 1
redis 127.0.0.1:6479&amp;gt; del tist
(integer) 1
redis 127.0.0.1:6479&amp;gt; type test
string
redis 127.0.0.1:6479&amp;gt; keys *
1) &quot;tast&quot;
2) &quot;test&quot;
3) &quot;tist&quot;
redis 127.0.0.1:6479&amp;gt; keys t*
1) &quot;tast&quot;
2) &quot;test&quot;
3) &quot;tist&quot;
redis 127.0.0.1:6479&amp;gt; keys t[ia]st
1) &quot;tast&quot;
2) &quot;tist&quot;
redis 127.0.0.1:6479&amp;gt; keys t?st
1) &quot;tast&quot;
2) &quot;test&quot;
3) &quot;tist&quot;
redis 127.0.0.1:6479&amp;gt; randomkey
&quot;test&quot;
redis 127.0.0.1:6479&amp;gt; rename test tt
OK
redis 127.0.0.1:6479&amp;gt; dbsize
(integer) 2
redis 127.0.0.1:6479&amp;gt; expire tt 30
(integer) 1
redis 127.0.0.1:6479&amp;gt; ttl tt
(integer) 24
redis 127.0.0.1:6479&amp;gt; select 10
OK
redis 127.0.0.1:6479[10]&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;string&lt;/h3&gt;

&lt;p&gt;string 是 redis 最基本的类型，而且 string 类型是二进制安全的，可以包含任何数据，包括图片和序列化的对象，最大可存1G字节。&lt;/p&gt;

&lt;p&gt;相关命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set key value 设置 key 对应的 string 类型的值
setnx key value 同上，如果 key 已经存在返回 0
get key 获取 key 对应的 string 值，不存在返回 nil
getset key 设置 key 的新值，并返回旧值
mget key1 key2 ... keyn 一次获取多个 key 值
mset key1 value1 key2 value2 ... keyn valuen 一次设置多个值
incr key 对 key 做 ++ 操作，如果 value 不是 int 类型会返回错误
decr kdy 对 key 做 -- 操作，可以为负 
incrby key integer 对 key 加指定值
decrby key integer 对 key 减指定值
append key value 对 key 的值追加字符串
substr key start end 截取指定 key 的字符串值，下标从0开始
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6479&amp;gt; flushdb
OK
redis 127.0.0.1:6479&amp;gt; set k1 a k2 b k3 c
(error) ERR syntax error
redis 127.0.0.1:6479&amp;gt; mset k1 a k2 b k3 c
OK
redis 127.0.0.1:6479&amp;gt; mget k1 k2 k3 k4
1) &quot;a&quot;
2) &quot;b&quot;
3) &quot;c&quot;
4) (nil)
redis 127.0.0.1:6479&amp;gt; incr k4
(integer) 1
redis 127.0.0.1:6479&amp;gt; decrby k4 5
(integer) -4
redis 127.0.0.1:6479&amp;gt; set k1 hello
OK
redis 127.0.0.1:6479&amp;gt; append k1 ' world'
(integer) 11
redis 127.0.0.1:6479&amp;gt; mget k1 k2 k3 k4
1) &quot;hello world&quot;
2) &quot;b&quot;
3) &quot;c&quot;
4) &quot;-4&quot;
redis 127.0.0.1:6479&amp;gt; substr k1 2 8
&quot;llo wor&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;list&lt;/h3&gt;

&lt;p&gt;redis的list类型其实就是一个每个子元素都是string类型的双向链表。所以[lr]push和[lr]pop命令的算法时间复杂度都是O(1)
另外list会记录链表的长度。所以llen操作也是O(1).链表的最大长度是(2的32次方-1)。我们可以通过push,pop操作从链表的头部
或者尾部添加删除元素。这使得list既可以用作栈，也可以用作队列。有意思的是list的pop操作还有阻塞版本的。当我们[lr]pop一个
list对象是，如果list是空，或者不存在，会立即返回nil。但是阻塞版本的b[lr]pop可以则可以阻塞，当然可以加超时时间，超时后也会返回nil
。为什么要阻塞版本的pop呢，主要是为了避免轮询。举个简单的例子如果我们用list来实现一个工作队列。执行任务的thread可以调用阻塞版本的pop去
获取任务这样就可以避免轮询去检查是否有任务存在。当任务来时候工作线程可以立即返回，也可以避免轮询带来的延迟。&lt;/p&gt;

&lt;p&gt;相关命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lpush key string 在 key 对应的 list 头部添加字符串元素，如果 key 不是 list 类型返回错误
rpush key string 同上，在尾部添加
llen key 返回 key 对应的 list 的长度，key 不存在返回0，key 不是 list 类型返回错误
lrange key start end 返回指定区间内的元素，下标从0开始，负数表示从后面开始
ltrim key start end 截取 list，保留指定区间内的元素
lset key index value 设置 list 指定下标的元素值
lrem key count value 从 key 对应的 list 中删除 count 个 和 value 元素相同的元素，count 为0时删除全部
lpop key 从 list 头部删除元素，并返回删除元素
rpop key 同上，从 list 尾部删除
blpop key1 key2 ... keyn timeout 从左到右返回一个非空 list 进行 lpop 操作并返回，如果所有的 list 都为空或者不存在，则会等待 timeout 秒，等待期间有 list 的 push 操作则立即返回，超时则返回 nil
brpop key1 key2 ... keyn timeout 同上，从尾部删除
rpoplpush srckey destkey 从 srckey 对应的 list 的尾部移动元素添加到 destkey 对应的 list 头部，最后返回被移除的元素，srckey 为空或者不存在返回 nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6479&amp;gt; lpush list1 aaa
(integer) 1
redis 127.0.0.1:6479&amp;gt; rpush list1 bbb
(integer) 2
redis 127.0.0.1:6479&amp;gt; lpush list1 ccc
(integer) 3
redis 127.0.0.1:6479&amp;gt; lpush list1 ddd
(integer) 4
redis 127.0.0.1:6479&amp;gt; llen list1
(integer) 4
redis 127.0.0.1:6479&amp;gt; lrange list1 0 2
1) &quot;ddd&quot;
2) &quot;ccc&quot;
3) &quot;aaa&quot;
redis 127.0.0.1:6479&amp;gt; ltrim list1 0 2
OK
redis 127.0.0.1:6479&amp;gt; lrange list1 0 3
1) &quot;ddd&quot;
2) &quot;ccc&quot;
3) &quot;aaa&quot;
redis 127.0.0.1:6479&amp;gt; lset list1 1 eeee
OK
redis 127.0.0.1:6479&amp;gt; lpop list1
&quot;ddd&quot;
redis 127.0.0.1:6479&amp;gt; rpop list1
&quot;aaa&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;set&lt;/h3&gt;

&lt;p&gt;redis的set是string类型的无序集合。set元素最大可以包含(2的32次方-1)个元素。set的是通过hash table实现的，所以添加，删除，查找的复杂度都是O(1)。hash table会随着添加或者删除自动的调整大小。需要注意的是调整hash table大小时候需要同步（获取写锁）会阻塞其他读写操作。可能不久后就会改用跳表（skip list）来实现
跳表已经在sorted set中使用了。关于set集合类型除了基本的添加删除操作，其他有用的操作还包含集合的取并集(union)，交集(intersection)，
差集(difference)。通过这些操作可以很容易的实现sns中的好友推荐和blog的tag功能。&lt;/p&gt;

&lt;p&gt;相关命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sadd key member 添加一个 string 元素到 key 对应的 set 集合中
srem key member 从 key 对应的 set 中移除给定元素
spop key 删除并返回 key 对应的 set 随机的一个元素
srandmember key 随机获取 set 中的一个元素，不删除
smove srckey destkey member 从 srckey 对应的 set 中移除 member 并添加到 destkey 对应的 set 中
scard key 返回 set 的元素个数
sismember key member 判断 member 是否在 set 中
sinter key1 key2 ... keyn 返回所有 set 的交集
sinterstore destkey key1 key2 ... keyn 同上，并保存交集到 destkey 对应的 set 下
sunion key1 key2 ... keyn 返回所有给定 set 的并集
sunion destkey key1 key2 ... keyn 同上，并同时保存并集到 destkey 对应的 set 下
sdiff key1 key2 ... keyn 返回所有 set 的差集
sdiffstore destkey key1 key2 ... keyn 同上，并保存差集到 destkey 对应的 set 下
smembers key 返回 key 对应的所有元素，结果是无序的
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6479&amp;gt; sadd set1 aaa
(integer) 1
redis 127.0.0.1:6479&amp;gt; sadd set1 bbb
(integer) 1
redis 127.0.0.1:6479&amp;gt; sadd set1 ccc
(integer) 1
redis 127.0.0.1:6479&amp;gt; srem set1 bbb
(integer) 1
redis 127.0.0.1:6479&amp;gt; spop set1
&quot;aaa&quot;
redis 127.0.0.1:6479&amp;gt; scard set1
(integer) 1
redis 127.0.0.1:6479&amp;gt; smembers set1
1) &quot;ccc&quot;
redis 127.0.0.1:6479&amp;gt; sadd set2 aaa
(integer) 1
redis 127.0.0.1:6479&amp;gt; sadd set2 bbb
(integer) 1
redis 127.0.0.1:6479&amp;gt; sadd set2 ccc
(integer) 1
redis 127.0.0.1:6479&amp;gt; sinterstore set3 set1 set2
(integer) 1
redis 127.0.0.1:6479&amp;gt; smembers set3
1) &quot;ccc&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;sorted set&lt;/h3&gt;

&lt;p&gt;和set一样sorted set也是string类型元素的集合，不同的是每个元素都会关联一个double类型的score。sorted set的实现是skip list和hash table的混合体
当元素被添加到集合中时，一个元素到score的映射被添加到hash table中，所以给定一个元素获取score的开销是O(1),另一个score到元素的映射被添加到skip list
并按照score排序，所以就可以有序的获取集合中的元素。添加，删除操作开销都是O(log(N))和skip list的开销一致,redis的skip list实现用的是双向链表,这样就
可以逆序从尾部取元素。sorted set最经常的使用方式应该是作为索引来使用.我们可以把要排序的字段作为score存储，对象的id当元素存储。&lt;/p&gt;

&lt;p&gt;相关命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;zadd key score member 添加元素互集合，元素存在只更新对应的 scroe
zrem key member 删除指定元素
zincrby key incr member 增加对应 member 的 scroe 值
zrank key member 返回指定元素在集合中的下标，默认按 score 从小到大排序
zrevrank key member 同上，按 scroe 从大到小排序
zrange key start end 返回指定区间的元素
zrevrange key start end 同上，返回结果按 score 逆序
zrangebystore key min max 返回集合中 score 在给定区间的元素
zcount key min max 返回集合中 score 在给定区间的数量
zcard key 返回集合中元素个数
zscore key element 返回给定元素对应的 score
zremrangebyrank key min max 删除集合中排名在给定区间的元素
zremrangebyscore key min max 删除集合中 score 在给定区间的元素
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6479&amp;gt; zadd ss1 10000 abc
(integer) 1
redis 127.0.0.1:6479&amp;gt; zadd ss1 20000 bbb
(integer) 1
redis 127.0.0.1:6479&amp;gt; zadd ss1 30000 ccc
(integer) 1
redis 127.0.0.1:6479&amp;gt; zadd ss1 44000 ddd
(integer) 1
redis 127.0.0.1:6479&amp;gt; zrank ss1 bbb
(integer) 1
redis 127.0.0.1:6479&amp;gt; zrevrank ss1 bbb
(integer) 2
redis 127.0.0.1:6479&amp;gt; zcard ss1
(integer) 4
redis 127.0.0.1:6479&amp;gt; zrangebyscore ss1 20000 40000
1) &quot;bbb&quot;
2) &quot;ccc&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;hash&lt;/h3&gt;

&lt;p&gt;redis hash是一个string类型的field和value的映射表.它的添加，删除操作都是O(1)（平均）.hash特别适合用于存储对象。相较于将对象的每个字段存成
单个string类型。将一个对象存储在hash类型中会占用更少的内存，并且可以更方便的存取整个对象。省内存的原因是新建一个hash对象时开始是用zipmap（又称为small hash）来存储的。这个zipmap其实并不是hash table，但是zipmap相比正常的hash实现可以节省不少hash本身需要的一些元数据存储开销。尽管zipmap的添加，删除，查找都是O(n)，但是由于一般对象的field数量都不太多。所以使用zipmap也是很快的,也就是说添加删除平均还是O(1)。如果field或者value的大小超出一定限制后，redis会在内部自动将zipmap替换成正常的hash实现. 这个限制可以在配置文件中指定
hash-max-zipmap-entries 64 #配置字段最多64个
hash-max-zipmap-value 512 #配置value最大为512字节&lt;/p&gt;

&lt;p&gt;相关命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hset key field value 设置 hash field 指定值
hget key field 获取指定的 hash field 值
hmget key field1 field2 ... fieldn 获取全部指定的值
hmset key field1 value1 field2 value2 ... fieldn valuen 同时设定多个 field 值
hincrby key field integer 将指定的 field 加上给定的值
hexists key field 判断指定的 field 是否存在
hdel key field 删除指定的 field
hlen key 返回指定的 field 数量
hkeys key 返回所有的 field
hvals key 返回所有的 value
hgetall 返回所有的 field 和 value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6479&amp;gt; hmset hash1 field1 aaa field2 bbb field3 ccc
OK
redis 127.0.0.1:6479&amp;gt; hmget hash1 field1 field2 field3
1) &quot;aaa&quot;
2) &quot;bbb&quot;
3) &quot;ccc&quot;
redis 127.0.0.1:6479&amp;gt; hexists hash1 field2
(integer) 1
redis 127.0.0.1:6479&amp;gt; hlen hash1
(integer) 3
redis 127.0.0.1:6479&amp;gt; hkeys hash1
1) &quot;field1&quot;
2) &quot;field2&quot;
3) &quot;field3&quot;
redis 127.0.0.1:6479&amp;gt; hvals hash1
1) &quot;aaa&quot;
2) &quot;bbb&quot;
3) &quot;ccc&quot;
redis 127.0.0.1:6479&amp;gt; hgetall hash1
1) &quot;field1&quot;
2) &quot;aaa&quot;
3) &quot;field2&quot;
4) &quot;bbb&quot;
5) &quot;field3&quot;
6) &quot;ccc&quot;
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>Redis Linux 安装 && 测试</title>
   <link href="http://www.blogways.net/blog/2013/05/02/redis.html"/>
   <updated>2013-05-02T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/05/02/redis</id>
   <content type="html">&lt;h2&gt;Redis Linux 安装&lt;/h2&gt;

&lt;p&gt;由于 Redis 并没有发布 windows 的官方版本，windows 的安装使用不作介绍，只介绍 Linux 下的安装使用。
下载地址：&lt;code&gt;https://github.com/dmajkic/redis/downloads&lt;/code&gt; 下载最新版本&lt;/p&gt;

&lt;p&gt;然后tar, make,即可。(make前，如果确认自己的测试机是32位linux，在src/Makefile文件中的头部加上 &lt;code&gt;CFLAGS= -march=i686&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;redis 2.6.9 安装报错&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Jimmy 2013-01-21 11:53
zmalloc.h:50:31: error: jemalloc/jemalloc.h: No such file or directory
zmalloc.h:55:2: error: #error &quot;Newer version of jemalloc required&quot;
make[1]: *** [adlist.o] Error 1
make[1]: Leaving directory `/data0/src/redis-2.6.2/src'
make: *** [all] Error 2
解决办法是：
make MALLOC=libc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动 server：
根目录下执行 &lt;code&gt;nohup src/redis-server redis.conf &amp;amp;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果端口有冲突改下 redis.conf 里面的 port 配置&lt;/p&gt;

&lt;p&gt;启动客户端
&lt;code&gt;src/redis-cli&lt;/code&gt;
端口有变化
&lt;code&gt;src/redis-cli -p 6479&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;测试下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;redis 127.0.0.1:6479&amp;gt; set test hello
OK
redis 127.0.0.1:6479&amp;gt; get test
&quot;hello&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与你熟悉的关系型数据库一致，Redis有着相同的数据库基本概念，即一个数据库包含一组数据。典型的数据库应用案例是，将一个程序的所有数据组织起来，使之与另一个程序的数据保持独立。
在Redis里，数据库简单的使用一个数字编号来进行辨认，默认数据库的数字编号是0。如果你想切换到一个不同的数据库，你可以使用select命令来实现。在命令行界面里键入&lt;code&gt;select 1&lt;/code&gt;，Redis应该会回复一条OK的信息，然后命令行界面里的提示符会变成类似&lt;code&gt;redis 127.0.0.1:6379[1]&amp;gt;&lt;/code&gt;这样。如果你想切换回默认数据库，只要在命令行界面键入&lt;code&gt;select 0&lt;/code&gt;即可。&lt;/p&gt;

&lt;blockquote&gt;&lt;h2&gt;Redis 客户端测试&lt;/h2&gt;

&lt;p&gt;Java 官方推荐客户端
Jedis&lt;/p&gt;&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;import java.util.Date;
import redis.clients.jedis.Jedis;

public class RedisTest {

    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        String host = &quot;127.0.0.1&quot;;
        int port = 6479, timeout = 30000;
        Jedis jedis = new Jedis(host, port, timeout);
        for (int i = 1; i &amp;lt;= 500000; i++) {
            String key = &quot;comppara_&quot; + i;
            String value = &quot;{param1: &quot; + i + &quot;, param2: &quot; + i + &quot;, param3: &quot; + i + &quot;}&quot;;
            jedis.set(key, value);
        }
        long end = System.currentTimeMillis();
        System.out.println(Thread.currentThread().getName() + &quot; insert times &quot; + (end - start));

        long s = System.currentTimeMillis();
        for (int i = 0; i &amp;lt;= 500000; i++) {
            String key = &quot;comppara_&quot; + i;
            jedis.get(key);
        }
        long e = System.currentTimeMillis();
        System.out.println(Thread.currentThread().getName() + &quot; read times &quot; + (e - s));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C 官方推荐客户端
hiredis&lt;/p&gt;

&lt;p&gt;C 也不怎么会用，就改的 hiredis 自带的 example.c 示例，编译完了直接执行 ./hiredis-example&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &quot;time.h&quot;
#include &quot;hiredis.h&quot;

void get_time() {
        time_t rawtime;
        struct tm * timeinfo;
        time ( &amp;amp;rawtime );
        timeinfo = localtime ( &amp;amp;rawtime );
        printf ( &quot;\007The current date/time is: %s&quot;, asctime (timeinfo) );
}
int main(void) {
    unsigned int j;
    redisContext *c;
    redisReply *reply;

    struct timeval timeout = { 1, 500000 }; // 1.5 seconds
    c = redisConnectWithTimeout((char*)&quot;127.0.0.1&quot;, 6479, timeout);
    if (c == NULL || c-&amp;gt;err) {
        if (c) {
            printf(&quot;Connection error: %s\n&quot;, c-&amp;gt;errstr);
            redisFree(c);
        } else {
            printf(&quot;Connection error: can't allocate redis context\n&quot;);
        }
        exit(1);
    }

        get_time();
        printf(&quot;test_bach start&quot;);
        for (int i = 1; i &amp;lt;= 500000; i++) {
redisCommand(c,&quot;SET param_%d {param1:param%d,param2:param%d,param3:param%d,param4:param%d}&quot;, i, i, i, i, i);
        }
        printf(&quot;test_bach end&quot;);
        get_time();

        for (int j = 1; j &amp;lt;= 500000; j++) {
redisCommand(c,&quot;GET param_%d&quot;, j);
        }
        get_time();

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试主机配置：8CPU32G内存，测试结果 C 插入 50W 记录大概在31秒左右，JAVA 34秒左右；读 50W 的速度 C 大概需要 29 s 左右，JAVA 需要 31s 左右。如果是远程机器调用JAVA速度基本跟C相差无几。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>MAC OSX 环境下搭建 memcached 环境</title>
   <link href="http://www.blogways.net/blog/2013/05/01/demo-libmemcached-at-mac.html"/>
   <updated>2013-05-01T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/05/01/demo-libmemcached-at-mac</id>
   <content type="html">&lt;p&gt;在MAC OSX下搭建 memcached 环境，那是轻松的一塌糊涂啊。整个过程几分钟就搞定了，让我再次感叹，MacBook 就是为 *nux 下程序员量身定制的！&lt;/p&gt;

&lt;p&gt;我是使用 brew 来安装的，让我们再回顾一下整个过程吧。如果你没有装 brew ,先看步骤一，否则直接看步骤二。&lt;/p&gt;

&lt;h3&gt;步骤一：安装 Homebrew&lt;/h3&gt;

&lt;p&gt;先看看是否满足下面条件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Intel 的 CPU
OS X 10.5 或者更高
安装了XCode 或者 XCode命令行工具
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;满足了，就可以安装 Homebrew，命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ruby -e &quot;$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开Terminal, 粘贴上面的语句.该脚本首先将会解释它要做什么, 然后暂停下来, 直到您确认继续. 更多的安装选项在&lt;a href=&quot;https://github.com/mxcl/homebrew/wiki/Installation&quot;&gt;这里&lt;/a&gt;可以看到 .&lt;/p&gt;

&lt;h3&gt;步骤二：安装 memcached&lt;/h3&gt;

&lt;p&gt;安装前，可以先查找一下，看看有没有：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew search memcache
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回结果:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;libmemcached    memcache-top    memcached   memcacheq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明和关键字&lt;code&gt;memcache&lt;/code&gt;相关的有上面这四个，这样就确认了，有我们需要的东西，第一个是客户端，第三个是服务器。&lt;/p&gt;

&lt;p&gt;那么安装吧！&lt;/p&gt;

&lt;p&gt;先装服务器：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew install memcached
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装日志：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;==&amp;gt; Installing memcached dependency: libevent
==&amp;gt; Downloading https://github.com/downloads/libevent/libevent/libevent-2.0.21-s
######################################################################## 100.0%
==&amp;gt; ./configure --disable-debug-mode --prefix=/usr/local/Cellar/libevent/2.0.21
==&amp;gt; make
==&amp;gt; make install
🍺  /usr/local/Cellar/libevent/2.0.21: 48 files, 1.8M, built in 84 seconds
==&amp;gt; Installing memcached
==&amp;gt; Downloading http://memcached.googlecode.com/files/memcached-1.4.15.tar.gz
######################################################################## 100.0%
==&amp;gt; ./configure --prefix=/usr/local/Cellar/memcached/1.4.15 --disable-coverage
==&amp;gt; make install
==&amp;gt; Caveats
To have launchd start memcached at login:
    ln -sfv /usr/local/opt/memcached/*.plist ~/Library/LaunchAgents
Then to load memcached now:
    launchctl load ~/Library/LaunchAgents/homebrew.mxcl.memcached.plist
Or, if you don't want/need launchctl, you can just run:
    /usr/local/opt/memcached/bin/memcached
==&amp;gt; Summary
🍺  /usr/local/Cellar/memcached/1.4.15: 10 files, 176K, built in 8 seconds
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面安装日志，可以看出:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;安装 memcached 前，先安装了其所依赖的 libevent 库&lt;/li&gt;
&lt;li&gt;下载的libevent和memcached，被安装到/usr/local/Cellar下面，但是又自动在/usr/local/bin下面建立了软连接，方便使用。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;安装后可以查看安装的结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ which memcached
/usr/local/bin/memcached

$ memcached -h
memcached 1.4.15
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;步骤二：安装 libmemcached&lt;/h3&gt;

&lt;p&gt;继续安装客户端库：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew install libmemcached
==&amp;gt; Downloading https://launchpad.net/libmemcached/1.0/1.0.16/+download/libmemca
######################################################################## 100.0%
==&amp;gt; ./configure --prefix=/usr/local/Cellar/libmemcached/1.0.16
==&amp;gt; make install
🍺  /usr/local/Cellar/libmemcached/1.0.16: 110 files, 1.4M, built in 108 seconds
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;步骤三：启动服务器&lt;/h3&gt;

&lt;p&gt;先默认参数启动吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ /usr/local/bin/memcached -d
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;步骤四：编写客户端测试程序并运行&lt;/h3&gt;

&lt;p&gt;编写程序文件 &lt;code&gt;example.cpp&lt;/code&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;libmemcached/memcached.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/time.h&amp;gt;

#define TEST_NUM 500000

void printNowTime() {
    struct timeval current;

    gettimeofday(&amp;amp; current, NULL);
    struct tm * mtm = localtime(&amp;amp; current.tv_sec);

    printf(&quot;[%04d-%02d-%02d %02d:%02d:%02d.%03d] &quot;, mtm-&amp;gt;tm_year+1900, mtm-&amp;gt;tm_mon + 1, mtm-&amp;gt;tm_mday, mtm-&amp;gt;tm_hour, mtm-&amp;gt;tm_min, mtm-&amp;gt;tm_sec, current.tv_usec / 1000);
}

int main() {

    const char *config_string = &quot;--SERVER=localhost&quot;;
    memcached_st *memc= memcached(config_string, strlen(config_string));

    //const char  *keys[]= {&quot;key1&quot;, &quot;key2&quot;, &quot;key3&quot;,&quot;key4&quot;};
    const  size_t key_length[]= {4, 4, 4, 4};   
    const char *values[] = {&quot;This is 1 first value&quot;, &quot;This is 2 second value&quot;, &quot;This is 3 third value&quot;,&quot;this is 4 forth value&quot;};   
    size_t val_length[]= {21, 22, 21, 21};  

    char keys[TEST_NUM][10];

    printNowTime();
    printf(&quot;start init keys.\n&quot;);

    for(int i=0; i&amp;lt;TEST_NUM; ++i) {
        sprintf(keys[i], &quot;key%06d&quot;, i);
    }

    printNowTime();
    printf(&quot;end init keys.\n\n&quot;);


    memcached_return_t rc;

    printNowTime();
    printf(&quot;start set value.\n&quot;);

    for (int i=0; i &amp;lt; TEST_NUM; i++)        
    {  
        rc = memcached_set(memc, keys[i], 9, values[i%4], val_length[i%4], (time_t)180,(uint32_t)0);
        //printf(&quot;key: %s  rc:%s\n&quot;, keys[i], memcached_strerror(memc, rc));   // 输出状态
    }

    printNowTime();
    printf(&quot;end set value.\n\n&quot;);


    char * result;
    uint32_t flags;
    size_t value_length;



    printNowTime();
    printf(&quot;start read value.\n&quot;);

    for(int i=0; i &amp;lt; TEST_NUM; i++)
    {  
        result = memcached_get(memc, keys[i], 9, &amp;amp;value_length, &amp;amp;flags, &amp;amp;rc);

        //if (i%10000 == 0)
        //    printf(&quot;key: %s, value: %s.\n&quot;, keys[i], result);
    } 

    printNowTime();
    printf(&quot;end read value.\n&quot;);

    memcached_free(memc);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编写 &lt;code&gt;Makefile&lt;/code&gt; 文件:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;example: example.cpp
    gcc -o example example.cpp -lmemcached

clean:
    rm example
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行测试:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./example
[2013-05-01 20:20:39.500] start init keys.
[2013-05-01 20:20:39.593] end init keys.

[2013-05-01 20:20:39.593] start set value.
[2013-05-01 20:21:04.527] end set value.

[2013-05-01 20:21:04.527] start read value.
[2013-05-01 20:21:26.959] end read value.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整个过程结束！&lt;/p&gt;

&lt;p&gt;确实很简单吧！&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>TDD 读后心得</title>
   <link href="http://www.blogways.net/blog/2013/04/28/tdd-impression.html"/>
   <updated>2013-04-28T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/28/tdd-impression</id>
   <content type="html">&lt;p&gt;在拜读Kent Beck（也是JUnit的联合作者）的大作《Test-Driven Development By Example》（测试驱动开发）之后，内心颇为震撼。也可以算是对自己原有认知的一种思想层面的颠覆。震撼之余，感觉很有必要把自己的一些心得分享出来。&lt;/p&gt;

&lt;p&gt;书中表述的信息量很大，并且配合了丰富的代码实例，然而由于鄙人理解有限，一遍阅读之后，能够摄取的知识点可能也就是书中内容的三四成。&lt;/p&gt;

&lt;p&gt;下面仅将最震撼&lt;a href=&quot;http://www.blogways.net&quot;&gt;自己&lt;/a&gt;的几点内容分享如下：&lt;/p&gt;

&lt;h3&gt;心得一：先写测试，再写实现&lt;/h3&gt;

&lt;p&gt;对，你没看错。&lt;/p&gt;

&lt;p&gt;按我们的常规，可能都是先写代码，再写测试。至少我本人以前这么干过。也因为以前是先写代码，再写测试，所以，常常感觉没必要写测试。因为代码是怎么实现的，心里明镜似的，写出来的测试代码，意义也不大。除非是开发中有些拿不准的地方，需要写测试来验证，除此之外，基本就不需要写测试。&lt;/p&gt;

&lt;p&gt;然而，TDD的精华就是先写测试，再写代码。&lt;/p&gt;

&lt;p&gt;只所以这样，我觉得和TDD内在的思想有关，他包含“简单设计”这么一个思想。&lt;/p&gt;

&lt;h3&gt;心得二：简单设计&lt;/h3&gt;

&lt;p&gt;我们之前做的设计，基本都是大而全的设计，这个不是TDD所提倡的。TDD所提倡的是“简单设计”，即设计以致用，或者说测试以致用。&lt;/p&gt;

&lt;p&gt;你目前需要什么功能，就做怎样的设计，或者说体现为写怎样的测试代码。&lt;/p&gt;

&lt;p&gt;这样，也就有了“先写测试，再写实现”，所以，从某种角度上来说，我觉得先写的测试，其实上是设计的一种变相表现。&lt;/p&gt;

&lt;p&gt;对，我是这么理解的，“测试”是一种“设计”。并且，这种设计不是大而全的设计，而是一种“设以致用”的“简单设计”。&lt;/p&gt;

&lt;p&gt;那么，怎么去做到“简单设计”呢？他需要我们，“积跬步，以至千里”。&lt;/p&gt;

&lt;h3&gt;心得三：积跬步，以至千里&lt;/h3&gt;

&lt;p&gt;关于“积跬步，以至千里”，书中给出了一个非常详细的实践例子。这个例子，给我的感觉，也是相当震撼的，原来居然可以这样来…&lt;/p&gt;

&lt;p&gt;我想，这应该也是敏捷开发的一个思想吧，回顾前段时间学习的“scrum”方法，其实，也是对这种“积跬步，以至千里”的思想进行的实践。&lt;/p&gt;

&lt;p&gt;但是，怎么去做到“积跬步，以至千里”，我觉得这也是一个技术活，需要好好体会书中的例子，并在实践中加以运用。运用好了，才能把测试当做设计。&lt;/p&gt;

&lt;p&gt;当然了，在“积跬步，以至千里”的过程中，必不可少的就是“重构”。&lt;/p&gt;

&lt;h3&gt;心得四：重构&lt;/h3&gt;

&lt;p&gt;在“积跬步”的过程中，必须不断的做重构，否则代码就会凌乱。而且，不仅需要不断地重构实现代码，也需要不断地重构测试代码。这一点，书中也有实例，很好地进行了佐证。&lt;/p&gt;

&lt;p&gt;“简单设计”（或者说测试体现设计）——“积跬步”——“重构”，这是一条线，是一个整体。线上的每个环节，都缺一不可。这条整线，我理解就是本书的最大精华了。&lt;/p&gt;

&lt;p&gt;除了这些外，书中还讲了一些方法论，这些方法论包括：“可运行模式”、“测试模式”、“设计模式”、“重构”，这些方法论中，给我感触最深的是“可运行模式”和“测试模式”。这两个模式，也是在“测试”中不可少的两个环节。&lt;/p&gt;

&lt;p&gt;要真正做到前面所说的——“简单设计、积跬步”，必须要了解“可运行模式”。&lt;/p&gt;

&lt;h3&gt;心得五：可运行模式&lt;/h3&gt;

&lt;p&gt;可运行模式中包含四种方法：“伪实现”、“三角法”、“显明实现”、“从一到多”。个人认为，虽然这些内容很简单，但是，这些都是必须要掌握的细节。&lt;/p&gt;

&lt;p&gt;这有掌握了这些，并在实践中加以应用，才能做的“积跬步，以至千里”。&lt;/p&gt;

&lt;h3&gt;心得六:测试模式&lt;/h3&gt;

&lt;p&gt;测试模式实际上就是测试方法，其实，不用看书，我们或多或少，都已经在之前的实践中进行应用了，只是作者做了一个相对来说，比较全面的总结。&lt;/p&gt;

&lt;p&gt;如果，你想做好测试，这些模式也需要掌握，至少其中的部分，需要成为我们以后测试中的利器。&lt;/p&gt;

&lt;p&gt;这些方法，包含有：“子测试”、“模拟对象”、“自分流”、“日志字符串”、“清扫测试死角”、“不完整测试”等等。&lt;/p&gt;

&lt;h3&gt;总结&lt;/h3&gt;

&lt;p&gt;以上六点，是我读后的一些心得，记之以分享！&lt;/p&gt;

&lt;p&gt;BTW：关于《测试驱动开发》这本书，我读的是网上流传的一个pdf版的中文译本。可能不是最新版，也可能由于是译本，对作者的本意存在理解偏差。不当之处，请指教。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>memcache NOSQL服务器安装及使用</title>
   <link href="http://www.blogways.net/blog/2013/04/27/memcache.html"/>
   <updated>2013-04-27T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/27/memcache</id>
   <content type="html">&lt;h3&gt;一、概述&lt;/h3&gt;

&lt;p&gt;Memcache是danga的一个项目，最早是LiveJournal 服务的，最初为了加速 LiveJournal 访问速度而开发的，后来被很多大型的网站采用。Memcached是以守护程序方式运行于一个或多个服务器中，随时会接收客户端的连接和操作。&lt;/p&gt;

&lt;p&gt;在 Memcached中可以保存的item数据量是没有限制的，只要内存足够。Memcached单进程最大使用内存为2G，要使用更多内存，可以分多个端口开启多个Memcached进程，最大30天的数据过期时间,设置为永久的也会在这个时间过期，常量REALTIME_MAXDELTA
60&lt;em&gt;60&lt;/em&gt;24*30控制，最大键长为250字节，大于该长度无法存储，常量KEY_MAX_LENGTH 250控制，单个item最大数据是1MB，超过1MB数据不予存储，常量POWER_BLOCK 1048576进行控制（可以修改slabs.c：POWER_BLOCK的值，然后重新编译memcached），它是默认的slab大小，最大同时连接数是200，通过 conn_init()中的freetotal进行控制，最大软连接数是1024，通过settings.maxconns=1024 进行控制，跟空间占用相关的参数：settings.factor=1.25, settings.chunk_size=48,影响slab的数据占用和步进方式。memcached是一种无阻塞的socket通信方式服务，基于libevent库，由于无阻塞通信，对内存读写速度非常之快。memcached分服务器端和客户端，可以配置多个服务器端和客户端，应用于分布式的服务非常广泛。memcached作为小规模的数据分布式平台是十分有效果的。&lt;/p&gt;

&lt;p&gt;memcached是键值一一对应，key默认最大不能超过128个字 节，value默认大小是1M，也就是一个slabs，如果要存2M的值（连续的），不能用两个slabs，因为两个slabs不是连续的，无法在内存中 存储，故需要修改slabs的大小，多个key和value进行存储时，即使这个slabs没有利用完，那么也不会存放别的数据。&lt;/p&gt;

&lt;p&gt;目前memcached支持C/C++、Perl、PHP、Python、Ruby、Java、C#、Postgres、Chicken Scheme、Lua、MySQL和Protocol等语言客户端。&lt;/p&gt;

&lt;h3&gt;二、Memcache和memcached&lt;/h3&gt;

&lt;p&gt;其实Memcache是这个项目的名称，而memcached是它服务器端的主程序文件名，知道我的意思了吧。一个是项目名称，一个是主程序文件名，在网上看到了很多人不明白，于是混用了。&lt;/p&gt;

&lt;h3&gt;三、Memcached 安装&lt;/h3&gt;

&lt;p&gt;1.在Linux环境下应用Memcache时，Memcache用到了libevent这个库，用于Socket的处理，所以还需要安装libevent。这里用的libevent的版本是libevent-1.4.9。下载地址&lt;a href=&quot;http://www.monkey.org/~provos/libevent/&quot;&gt;http://www.monkey.org/~provos/libevent/&lt;/a&gt;（如果你的系统已经安装了libevent，可以不用安装）。&lt;/p&gt;

&lt;p&gt;2.Memcached 下载地址&lt;a href=&quot;https://code.google.com/p/memcached/&quot;&gt;https://code.google.com/p/memcached/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3.这里我运用了Magent作为Memcached代理服务器软件，它可以搭建高可用性的集群应用的Memcached服务，magent采用的是：Consistent Hashing原理，Consistent Hashing如下所示：首先求出memcached服务器（节点）的哈希值， 并将其配置到0～232的圆（continuum）上。然后用同样的方法求出存储数据的键的哈希值，并映射到圆上。然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。 如果超过232仍然找不到服务器，就会保存到第一台memcached服务器上，magent下载地址为：&lt;a href=&quot;http://code.google.com/p/memagent/&quot;&gt;http://code.google.com/p/memagent/&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;4.编译安装libevent&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar zxvf libevent-1.4.9-stable.tar.gz
cd libevent-1.4.9-stable/
./configure --prefix=/usr
make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.编译安装Memcached&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar zxvf memcached-1[1].4.5.tar.gz
cd memcached-1.4.5/
./configure --with-libevent=/usr
make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6.编译安装magent&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir magent
cd magent/
tar zxvf magent-0.5.tar.gz
/sbin/ldconfig
sed -i &quot;s#LIBS = -levent#LIBS = -levent -lm#g&quot; Makefile
make
cp magent /usr/bin/magent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在安装magent过程中可能遇到一些问题，下面列举几个可能出现的问题及解决方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc -Wall -g -O2 -I/usr/local/include -m64 -c -o magent.o magent.c
magent.c: In function 'writev_list':
magent.c:729: error: 'SSIZE_MAX' undeclared (first use in this function)
magent.c:729: error: (Each undeclared identifier is reported only once
magent.c:729: error: for each function it appears in.)
make: *** [magent.o] Error 1

解决办法：
[spdev@slave2 magent]# vi ketama.h 
#在开头加入
#ifndef SSIZE_MAX
#define SSIZE_MAX      32767
#endif

gcc -Wall -g -O2 -I/usr/local/include -m64 -c -o magent.o magent.c
gcc -Wall -g -O2 -I/usr/local/include -m64 -c -o ketama.o ketama.c
gcc -Wall -g -O2 -I/usr/local/include -m64 -o magent magent.o ketama.o
/usr/lib64/libevent.a /usr/lib64/libm.a 
gcc: /usr/lib64/libevent.a: No such file or directory
gcc: /usr/lib64/libm.a: No such file or directory
解决办法：
[spdev@slave2 magent]#  ln -s /usr/lib/libevent*  /usr/lib64/

gcc -Wall -g -O2 -I/usr/local/include -m64 -o magent magent.o ketama.o 
/usr/lib64/libevent.a /usr/lib64/libm.a 
gcc: /usr/lib64/libm.a: No such file or directory
make: *** [magent] Error 1
解决办法：
[spdev@slave2 magent]# cp /usr/lib64/libm.so /usr/lib64/libm.a

gcc -Wall -g -O2 -I/usr/local/include -m64 -o magent magent.o ketama.o 
/usr/lib64/libevent.a /usr/lib64/libm.a 
/usr/lib64/libevent.a(event.o): In function `detect_monotonic':
event.c:(.text+0xc79): undefined reference to `clock_gettime'
/usr/lib64/libevent.a(event.o): In function `gettime':
event.c:(.text+0xd60): undefined reference to `clock_gettime'
collect2: ld returned 1 exit status
make: *** [magent] Error 1
解决办法：
[spdev@slave2 magent]#vi Makefile 
CFLAGS = -Wall -g -O2 -I/usr/local/include $(M64)
改为：    
CFLAGS = -lrt -Wall -g -O2 -I/usr/local/include $(M64)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;四、启动和结束服务&lt;/h3&gt;

&lt;p&gt;1.启动一个Memcache的服务器端：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;memcached -d -m 10 -u spdev -l 192.168.4.19 -p 11211 -c 256 -P /tmp/memcached.pid
? -d 选项是启动一个守护进程，
? -m 是分配给Memcache使用的内存数量，单位是MB，我这里是10MB，
? -u 是运行Memcache的用户，我这里是spdev，
? -l 是监听的服务器IP地址，我这里指定了服务器的IP地址192.168.4.19，
? -p 是设置Memcache监听的端口，我这里设置了11211，最好是1024以上的端口，
? -c 是最大运行的并发连接数，默认1024，这里设置了256，按照服务器的负载量来设定，
? -P 是设置保存Memcache的pid文件，我这里是保存在/tmp/memcached.pid。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.结束一个Memcache进程&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;如果要结束Memcache进程，执行：
# kill `cat /tmp/memcached.pid`
? 注意，上面命令中的符号是 `，不是单引号’
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.启动Magent代理&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;magent -u spdev -n 51200 -l 192.168.4.19 -p 12000 -s 192.168.4.19:11211 
-s 192.168.4.19:11212 -b 192.168.4.19:11213 

-h this message
-u uid
-g gid
-p port, default is 11211. (0 to disable tcp support)
-s ip:port, set memcached server ip and port
-b ip:port, set backup memcached server ip and port
-l ip, local bind ip address, default is 0.0.0.0
-n number, set max connections, default is 4096
-D don't go to background
-k use ketama key allocation algorithm
-f file, unix socket path to listen on. default is off
-i number, max keep alive connections for one memcached server, default is 20
-v verbose

启动magent代理服务器，端口为12000.代理服务器ip端口192.168.4.19:11211、
192.168.4.19:11212，备份主机ip端口为192.168.4.19:11213
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;五、telnet memcache服务器及magent代理服务器测试&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;telnet memcache 192.168.4.19:11211服务器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; C:\Users\Administrator&amp;gt;telnet 192.168.4.19:11211
 set key 0 0 8
 88888888
 STORED
 quit

 遗失对主机的连接。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;telnet magent 192.168.4.19:12000代理服务器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; C:\Users\Administrator&amp;gt;telnet 192.168.4.19:12000
 get key
 VALUE key 0 8
 88888888
 END
 quit

 遗失对主机的连接。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;这里可以发现在服务器上set的值，在代理服务器上可以取到。&lt;/p&gt;

&lt;h3&gt;六、运用libmemcached c++客户端编写客户端测试程序&lt;/h3&gt;

&lt;p&gt;libmemcached下载地址:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://launchpad.net/libmemcached/+download/&quot;&gt;https://launchpad.net/libmemcached/+download/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;此处要注意，libmemcached 1.0以上版本需要gcc4.2以上版本才能支持，这里我用的是最新版libmemcached-1.0.17，而16主机上gcc版本为4.12,所以我升级了gcc，升级gcc步骤这里就不做介绍&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;libmemcached客户端程序连接magent代理服务器测试&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;循环500000次向memcache服务器set 500000条值，本次测试是ip为
192.168.4.16的主机调ip为192.168.4.19的memcache服务器，具体
调用时间如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Save data:begin
    2013-04-29 15:39:32.129
    2013-04-29 15:41:43.406
    Save data:end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  从上面数据看出set 500000数据用了2分多钟&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;循环10000次，每次随机取1-500000中任意一个随机数，然后从上面set的值中get对应
数据，具体调用时间如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  2013-04-29 15:41:43.406
  2013-04-29 15:41:45.899
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由此看出随机取10000条数据用了两秒多的时间&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;2.libmemcached客户端程序直接连接memcache服务器测试&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;循环500000次向memcache服务器set 500000条值，本次测试是ip为
192.168.4.16的主机调ip为192.168.4.19的memcache服务器，具体
调用时间如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Save data:begin
  2013-04-29 20:28:42.439
  2013-04-29 20:30:10.462
  Save data:end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面数据看出set 500000数据用了1分多钟&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;循环10000次，每次随机取1-500000中任意一个随机数，然后从上面set的值中get对应
数据，具体调用时间如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  2013-04-29 20:30:10.462
  2013-04-29 20:30:12.085
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由此看出随机取10000条数据用了1秒多的时间&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;七、运用memcached client for java客户端编写客户端测试程序&lt;/h3&gt;

&lt;p&gt;memcached client for java下载地址为：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://github.com/gwhalin/Memcached-Java-Client/&quot;&gt;http://github.com/gwhalin/Memcached-Java-Client/&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;java客户端程序连接magent代理服务器测试&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;循环500000次向memcache服务器set 500000条值，本次测试是ip为
192.168.4.16的主机调ip为192.168.4.19的memcache服务器，具体
调用时间如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    save begin:2013-04-29 10:09:04:0790
    save end:2013-04-29 10:13:11:0721
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  从上面数据看出set 500000数据用了4分多钟&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;循环10000次，每次随机取1-500000中任意一个随机数，然后从上面set的值中get对应
数据，具体调用时间如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  get begin:2013-04-29 10:13:11:0722
  get end:2013-04-29 10:13:16:0678
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由此看出随机取10000条数据用了4秒多的时间&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;2.java客户端程序直接连接memcache服务器测试&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;循环500000次向memcache服务器set 500000条值，本次测试是ip为
192.168.4.16的主机调ip为192.168.4.19的memcache服务器，具体
调用时间如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  save begin:2013-04-29 20:21:46:0195
  save end:2013-04-29 20:25:06:0365
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面数据看出set 500000数据用了3分多钟&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;循环10000次，每次随机取1-500000中任意一个随机数，然后从上面set的值中get对应
数据，具体调用时间如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  get begin:2013-04-29 20:25:06:0366
  get end:2013-04-29 20:25:10:0357
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由此看出随机取10000条数据用了接近4秒的时间&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;八、说明&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;从步骤七中测试结果可以看出，c++客户端调用memcache服务器在性能上明显优于java客户端，同时运用magent代理服务器时性能上还是有所降低&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;至于redis与memcache性能差异本文没有做对比，可参照redis文档中列出的测试数据加以对比，这里列下在网上看到一些大拿们列出的对比：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;性能对比：由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起Memcached，还是稍有逊色&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内存使用效率对比：使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Redis支持服务器端的数据操作：Redis相比Memcached来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在Memcached里，你需要将数据拿到客户端来进行类似的修改再set回去。这大大增加了网络IO的次数和数据体积。在Redis中，这些复杂的操作通常和一般的GET/SET一样高效。所以，如果需要缓存能够支持更复杂的结构和操作，那么Redis会是不错的选择&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>2013年待研究学习事项</title>
   <link href="http://www.blogways.net/blog/2013/04/25/2013-todo-list.html"/>
   <updated>2013-04-25T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/25/2013-todo-list</id>
   <content type="html">&lt;h3&gt;列表：&lt;/h3&gt;

&lt;table&gt;

    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt; 序号 &lt;/th&gt;
            &lt;th&gt; 研究内容 &lt;/th&gt;
            &lt;th&gt; 子内容 &lt;/th&gt;
            &lt;th&gt; 优先级 &lt;/th&gt;
            &lt;th&gt; 添加人 &lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;

    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt; 1 &lt;/td&gt;
            &lt;td&gt; 敏捷开发环境搭建  &lt;/td&gt;
            &lt;td&gt; &lt;/td&gt;
            &lt;td&gt; 100 &lt;/td&gt;
            &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt; 1.1 &lt;/td&gt;
            &lt;td&gt; &lt;/td&gt;
            &lt;td&gt; GIT环境搭建 &lt;/td&gt;
            &lt;td&gt; 100&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt; 1.2 &lt;/td&gt;
            &lt;td&gt; &lt;/td&gt;
            &lt;td&gt; Maven环境搭建 &lt;/td&gt;
            &lt;td&gt;100&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt; 1.3 &lt;/td&gt;
            &lt;td&gt; &lt;/td&gt;
            &lt;td&gt; jenkins环境搭建 &lt;/td&gt;
            &lt;td&gt; 100&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt; 1.4 &lt;/td&gt;
            &lt;td&gt; &lt;/td&gt;
            &lt;td&gt; 测试驱动开发(TDD)学习&lt;/td&gt;
            &lt;td&gt; 100&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt; 1.5&lt;/td&gt;
            &lt;td&gt; &lt;/td&gt;
            &lt;td&gt; Scrum方法学习&lt;/td&gt;
            &lt;td&gt;100&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt; 2 &lt;/td&gt;
            &lt;td&gt; NoSQL研究 &lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;100&lt;/td&gt;
            &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt;2.1&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;memcached研究&lt;/td&gt;
            &lt;td&gt;100&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt;2.2&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;redis研究&lt;/td&gt;
            &lt;td&gt;100&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt;2.3&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;mongodb研究&lt;/td&gt;
            &lt;td&gt;100&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        
        &lt;tr&gt;
            &lt;td&gt; 3 &lt;/td&gt;
            &lt;td&gt; 手机应用研究 &lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;100&lt;/td&gt;
            &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt; 3.1 &lt;/td&gt;
            &lt;td&gt; &lt;/td&gt;
            &lt;td&gt; Sencha框架研究 &lt;/td&gt;
            &lt;td&gt;100&lt;/td&gt;
            &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        
        
        &lt;tr&gt;
            &lt;td&gt; 4 &lt;/td&gt;
            &lt;td&gt; 云化 &lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;100&lt;/td&gt;
            &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt; 4.1 &lt;/td&gt;
            &lt;td&gt; &lt;/td&gt;
            &lt;td&gt; U-Cloud研究学习 &lt;/td&gt;
            &lt;td&gt;100&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;!--  在这里继续添加内容 BEGIN --&gt;
        
        &lt;tr&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;待添加&lt;/td&gt;
        &lt;/tr&gt;
        
        
        
        &lt;!--  在这里继续添加内容 END --&gt;
        
        &lt;tr&gt;
            &lt;td&gt;9&lt;/td&gt;
            &lt;td&gt;杂记&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;50&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt;9.1&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;OSGi学习&lt;/td&gt;
            &lt;td&gt;50&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt;9.2&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;工作流引擎——jBPM5/Activiti&lt;/td&gt;
            &lt;td&gt;50&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt;9.3&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;规则引擎——drools&lt;/td&gt;
            &lt;td&gt;50&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt;9.4&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;EAI/ESB组件研究&lt;/td&gt;
            &lt;td&gt;50&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt;9.4&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;HTML5/CSS3特性学习&lt;/td&gt;
            &lt;td&gt;50&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt;9.5&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;去 IOE 之 关系数据库MySQL化&lt;/td&gt;
            &lt;td&gt;80&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt;9.6&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;实时/准实时数据同步实现&lt;/td&gt;
            &lt;td&gt;50&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt;9.7&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;ArcGIS学习和研究&lt;/td&gt;
            &lt;td&gt;50&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        
        
        &lt;!--  在这里继续添加内容 BEGIN --&gt;
        
        &lt;tr&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;待添加&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;!--  在这里继续添加内容 END --&gt;
        
        
    &lt;/tbody&gt;
&lt;/table&gt;


&lt;h3&gt;说明&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;上表为大家共同维护，发现有什么好的东西就向里面添加。根据工作要求，定期讨论后续研究内容的优先级。&lt;/li&gt;
&lt;li&gt;序号 9 开始为杂记，根据工作要求，定期调整 9 中的内容至序号 1-8 内。&lt;/li&gt;
&lt;li&gt;优先级说明：100为分界线。100及其以上为需优先研究学习内容。&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Maven 环境搭建</title>
   <link href="http://www.blogways.net/blog/2013/04/23/maven.html"/>
   <updated>2013-04-23T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/23/maven</id>
   <content type="html">&lt;h2&gt;Maven 安装 简介&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Maven 安装&lt;/p&gt;

&lt;p&gt;  下载安装包
  地址：http://maven.apache.org/download.html&lt;/p&gt;

&lt;p&gt;  Windows 安装：
  本机jdk必需是1.5或者以上版本&lt;/p&gt;

&lt;p&gt;  解压安装包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  目录结构：
  bin   Maven的运行脚本
  boot  Maven自己的类装载器
  conf  该目录下包含了全局行为定制文件setting.xml
  lib   Maven运行时所需的类库
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置环境变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  M2_HOME=安装目录
  在path变量中增加%M2_HOME%\bin
  检查安装是否正确
  Mvn –v
  能看到Maven和JDK的版本号为安装正确
  试运行maven命令
  mvn help:system
  该命令将会下载help插件并运行它，且打印出Java系统属性和环境变量
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Maven名词解释&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; Project：任何您想build的事物，Maven都可以认为它们是工程。这些工程被定义为工程对象模型(POM，Poject Object Model)。一个工程可以依赖其它的工程；一个工程也可以由多个子工程构成。&lt;/li&gt;
&lt;li&gt; POM：POM(pom.xml)是Maven的核心文件，它是指示Maven如何工作的元数据文件，类似于Ant中的build.xml文件。POM文件位于每个工程的根目录中。&lt;/li&gt;
&lt;li&gt; GroupId：groupId是一个工程的在全局中唯一的标识符，一般地，它就是工程名。groupId有利于使用一个完全的包名，将一个工程从其它有类似名称的工程里区别出来。&lt;/li&gt;
&lt;li&gt; Artifact：artifact 是工程将要产生或需要使用的文件，它可以是jar文件，源文件，二进制文件，war文件，甚至是pom文件。每个artifact都由groupId和 artifactId组合的标识符唯一识别。需要被使用(依赖)的artifact都要放在仓库(见Repository)中，否则Maven无法找到 (识别)它们。&lt;/li&gt;
&lt;li&gt; Dependency：为了能够build或运行，一个典型的Java工程会依赖其它的包。在Maven中，这些被依赖的包就被称为dependency。dependency一般是其它工程的artifact。&lt;/li&gt;
&lt;li&gt; Plug-in：Maven是由插件组织的，它的每一个功能都是由插件提供的。插件提供goal(类似于Ant中的target)，并根据在POM中找到的元数据去完成工作。主要的Maven插件要是由Java写成的，但它也支持用Beanshell或Ant脚本写成的插件。&lt;/li&gt;
&lt;li&gt; Repository：仓库。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置文件&lt;/p&gt;

&lt;p&gt;  $user.home/.m2/repository/setting.xml
  为用户范围的配置文件
  $M2_HOME/conf/setting.xml
  为全局范围的配置文件，修改后将影响本机所有用户的配置
  建议：只修改用户级别的配置，既不影响其它用户，也不影响后期升级。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置介绍&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; localRepository： 自定义本地库路径，默认在$user.home/.m2中&lt;/li&gt;
&lt;li&gt; interactiveMode：&lt;/li&gt;
&lt;li&gt; offline：是否每次编译都去查找远程中心库&lt;/li&gt;
&lt;li&gt; pluginGroups：插件组，例如org.mortbay.jetty&lt;/li&gt;
&lt;li&gt; proxies：通过代理访问外部库&lt;/li&gt;
&lt;li&gt; servers：集成认证服务，例如集成Tomcat&lt;/li&gt;
&lt;li&gt; mirrors：镜像库，可以指定内部中心库&lt;/li&gt;
&lt;li&gt; profiles：个性配置，需要在Activation标签中激活&lt;/li&gt;
&lt;li&gt; activeProfiles：表示激活的profile&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;maven仓库&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 远程公用仓库
Maven内置了远程公用仓库：http://repo1.maven.org/maven2这个公共仓库是由Maven自己维护，里面有大量的常用类库，并包含了世界上大部分流行的开源项目构件。目前是以java为主。&lt;/li&gt;
&lt;li&gt; 内部中心仓库
也称私有共享仓库(私服)。一般是由公司自己设立的，只为本公司内部共享使用。它既可以作为公司内部构件协作和存档，也可作为公用类库镜像缓存，减少在外部访问和下载的频率。Nexus和Artifactory均可搭建仓库服务器。但后者支持LDAP认证，这样就可以将私有仓库的认证集成到公司已经有的LDAP认证服务器。内部中心库又可以连接第三方库，例如Jboss中心库、Spring中心库，以随时获得最新版本的第三方构件。&lt;/li&gt;
&lt;li&gt; 本地仓库
Maven会将工程中依赖的构件(Jar包)从远程下载到本机一个目录下管理，通常默认在$user.home/.m2/repository下。
修改本地库位置：在$M2_HOME/conf/setting.xml文件的&lt;localRepository&gt;元素中指定路径，例如：&lt;localRepository&gt;D:/my_repository&lt;/localRepository&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Maven常用命令&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 检测Maven、JDK版本
mvn –v  或者  mvn -version&lt;/li&gt;
&lt;li&gt; 获取帮助选项
mvn –h  或者  mvn –help&lt;/li&gt;
&lt;li&gt; 显示详细错误信息
mvn –e&lt;/li&gt;
&lt;li&gt; 创建Java项目
mvn archetype:create -DgroupId=${groupId} -DartifactId=${artifactId}
示例：mvn archetype:create -DgroupId=com.howsun -DartifactId=myApp-Dversion=0.1&lt;/li&gt;
&lt;li&gt; 创建Web项目
mvn archetype:create -DgroupId=${packageName}    -DartifactId=${webappName} -DarchetypeArtifactId=maven-archetype-webapp&lt;/li&gt;
&lt;li&gt; 创建其它项目(例如SSH、JPA、JSF、Seam…)
mvn archetype:generate然后根据提示选择项目骨架、groupid、artifactid、版本号…Maven3已有上百个项目骨架&lt;/li&gt;
&lt;li&gt; 转换成Eclipse工程
mvn eclipse:eclipse
mvn eclipse:clean  //清除Eclipse设置信息
转换成idea项目：mvn idea:ide&lt;/li&gt;
&lt;li&gt; 编译
mvn compile&lt;/li&gt;
&lt;li&gt;. 编译测试代码
mvn test-compile&lt;/li&gt;
&lt;li&gt;. 产生Site：
mvn site&lt;/li&gt;
&lt;li&gt;. 测试
mvn test  //运行测试
mvn test -Dtest=${类名} //单独运行测试类&lt;/li&gt;
&lt;li&gt;. 清除
mvn clean  //将清除原来编译的结果&lt;/li&gt;
&lt;li&gt;. 打包
mvn packagemvn package –Dmaven.test.skip=true //打包时不执行测试&lt;/li&gt;
&lt;li&gt;. 发布
mvn install //将项目打包成构件安装到本地仓库
mvn deploy  //发布到本地仓库或服务器(例如Tomcat、Jboss)&lt;/li&gt;
&lt;li&gt;. 手动添加构件到仓库
mvn install:install-file -Dfile=${jar包文件位置} -DgroupId=${groupId} -DartifactId=${artifactId} -Dversion=${版本号} -Dpackaging=jar -DgeneratePom=${是否同时创建pom文件}&lt;/li&gt;
&lt;li&gt;. 复制依赖构件到相应目录
mvn dependency:copy-dependencies -DoutputDirectory=${目标目录} -DexcludeScope=${scope} -Dsilent=true
示例：
mvn dependency:copy-dependencies
 -DoutputDirectory=WebRoot/WEB-INF/lib
 -Dsilent=true
 -DincludeScope=runtime&lt;/li&gt;
&lt;li&gt;. 显示一个插件的详细信息(configuration, goals等):
mvn help:describe -Dplugin=pluginName –Ddetail&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;工程配置文件 pom.xml&lt;/p&gt;

&lt;p&gt;  是Maven项目的核心配置文件，位于每个工程的根目录，指示Maven工作的元数据文件。
  节点介绍&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; &lt;project &gt; ：文件的根节点 .&lt;/li&gt;
&lt;li&gt; &lt;modelversion &gt; ： pom.xml使用的对象模型版本 .&lt;/li&gt;
&lt;li&gt; &lt;groupId &gt; ：创建项目的组织或团体的唯一 Id.&lt;/li&gt;
&lt;li&gt; &lt;artifactId &gt; ：项目的唯一 Id, 可视为项目名 .&lt;/li&gt;
&lt;li&gt; &lt;packaging &gt; ：打包类型，一般有JAR,WAR,EAR 等&lt;/li&gt;
&lt;li&gt; &lt;version &gt; ：产品的版本号 .&lt;/li&gt;
&lt;li&gt; &lt;name &gt; ：项目的显示名，常用于 Maven 生成的文档。&lt;/li&gt;
&lt;li&gt; &lt;url &gt; ：组织的站点，常用于 Maven 生成的文档。&lt;/li&gt;
&lt;li&gt; &lt;description &gt; ：项目描述，常用于 Maven 生成的文档。&lt;/li&gt;
&lt;li&gt;. &lt;dependencies&gt;：构件依赖&lt;parent&gt;：模型继承&lt;/li&gt;
&lt;li&gt;. &lt;dependencyManagement&gt;：依赖管理&lt;/li&gt;
&lt;li&gt;. &lt;reporting&gt;：创建报告&lt;/li&gt;
&lt;li&gt;. &lt;build&gt;：构建&lt;/li&gt;
&lt;li&gt;. &lt;repositories&gt;：引用第三方仓库&lt;/li&gt;
&lt;li&gt;. &lt;licenses&gt;：许可&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Eclipse中使用maven&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 安装M2Eclipse插件
Help -&gt; InstallNewSoftware -&gt; Work with -&gt; Add
核心组件：&lt;/li&gt;
&lt;li&gt; Name：m2e
Location：http://m2eclipse.sonatype.org/sites/m2e&lt;/li&gt;
&lt;li&gt; 扩展组件：
Name： m2e-extras
Location：http://m2eclipse.sonatype.org/sites/m2e-extras&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;示例&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;命令行创建java工程&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt; command 窗口执行&lt;/p&gt;

&lt;p&gt;  F:\maven&gt;mvn archetype:create -DgroupId=com.ailk.test -DartifactId=hello -DpackageName=com.ailk.test -Dversion=1.0
  目录会下生成一个 hello 的文件夹
  Hello/src/main/java 是源文件目录
  Hello/src/test/java 是测试文件目录
  Hello/target 是编译目标文件夹
  Hello/pom.xml 是工程的 maven 配置文件&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt; Setting 配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
  &amp;lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot; 
            xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
            xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&amp;gt;
    &amp;lt;localRepository&amp;gt;F:\maven\repo&amp;lt;/localRepository&amp;gt;
    &amp;lt;pluginGroups&amp;gt;
    &amp;lt;/pluginGroups&amp;gt;
    &amp;lt;proxies&amp;gt;
    &amp;lt;/proxies&amp;gt;
    &amp;lt;servers&amp;gt;
      &amp;lt;server&amp;gt;
              &amp;lt;id&amp;gt;sphost&amp;lt;/id&amp;gt;
              &amp;lt;username&amp;gt;admin&amp;lt;/username&amp;gt;
              &amp;lt;password&amp;gt;admin123&amp;lt;/password&amp;gt;
          &amp;lt;/server&amp;gt;
          &amp;lt;server&amp;gt;
              &amp;lt;id&amp;gt;spsnap&amp;lt;/id&amp;gt;
              &amp;lt;username&amp;gt;admin&amp;lt;/username&amp;gt;
              &amp;lt;password&amp;gt;admin123&amp;lt;/password&amp;gt;
          &amp;lt;/server&amp;gt;
    &amp;lt;/servers&amp;gt;
    &amp;lt;mirrors&amp;gt;
      &amp;lt;mirror&amp;gt;
              &amp;lt;id&amp;gt;nexus-public&amp;lt;/id&amp;gt;
              &amp;lt;mirrorOf&amp;gt;public&amp;lt;/mirrorOf&amp;gt;
              &amp;lt;!--url&amp;gt;http://127.0.0.1:8081/nexus/content/groups/mygroup&amp;lt;/url--&amp;gt;
              &amp;lt;url&amp;gt;http://192.168.4.19:8081/nexus/content/groups/spgroup/&amp;lt;/url&amp;gt;
          &amp;lt;/mirror&amp;gt;
    &amp;lt;/mirrors&amp;gt;
    &amp;lt;profiles&amp;gt;
      &amp;lt;profile&amp;gt;
      &amp;lt;id&amp;gt;nexus&amp;lt;/id&amp;gt;
      &amp;lt;repositories&amp;gt;
          &amp;lt;repository&amp;gt;
              &amp;lt;id&amp;gt;nexus&amp;lt;/id&amp;gt;
              &amp;lt;name&amp;gt;local private nexus&amp;lt;/name&amp;gt;
              &amp;lt;url&amp;gt;http://192.168.4.19:8081/nexus/content/groups/spgroup/&amp;lt;/url&amp;gt;
              &amp;lt;releases&amp;gt;
                  &amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;
              &amp;lt;/releases&amp;gt;
              &amp;lt;snapshots&amp;gt;
                  &amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;
              &amp;lt;/snapshots&amp;gt;
          &amp;lt;/repository&amp;gt;
      &amp;lt;/repositories&amp;gt;
      &amp;lt;pluginRepositories&amp;gt;
          &amp;lt;pluginRepository&amp;gt;
              &amp;lt;id&amp;gt;nexus&amp;lt;/id&amp;gt;
              &amp;lt;name&amp;gt;local private nexus&amp;lt;/name&amp;gt;
              &amp;lt;url&amp;gt;http://192.168.4.19:8081/nexus/content/groups/spgroup/&amp;lt;/url&amp;gt;
              &amp;lt;releases&amp;gt;
                  &amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;
              &amp;lt;/releases&amp;gt;
              &amp;lt;snapshots&amp;gt;
                  &amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;
              &amp;lt;/snapshots&amp;gt;
          &amp;lt;/pluginRepository&amp;gt;
      &amp;lt;/pluginRepositories&amp;gt;
  &amp;lt;/profile&amp;gt;
    &amp;lt;/profiles&amp;gt;

    &amp;lt;activeProfiles&amp;gt;
          &amp;lt;activeProfile&amp;gt;nexus&amp;lt;/activeProfile&amp;gt;
      &amp;lt;/activeProfiles&amp;gt;
  &amp;lt;/settings&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt; Pom 配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;groupId&amp;gt;com.ailk.test&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;hello&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0&amp;lt;/version&amp;gt;
    &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;
    &amp;lt;name&amp;gt;hello&amp;lt;/name&amp;gt;
    &amp;lt;url&amp;gt;http://maven.apache.org&amp;lt;/url&amp;gt;
    &amp;lt;properties&amp;gt;
      &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
    &amp;lt;/properties&amp;gt;
    &amp;lt;dependencies&amp;gt;
      &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;4.8.1&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
      &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
    &amp;lt;build&amp;gt;
          &amp;lt;pluginManagement&amp;gt;
              &amp;lt;plugins&amp;gt;
                  &amp;lt;plugin&amp;gt;
                      &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                      &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
                      &amp;lt;configuration&amp;gt;
                          &amp;lt;source&amp;gt;1.5&amp;lt;/source&amp;gt;
                          &amp;lt;target&amp;gt;1.5&amp;lt;/target&amp;gt;
                      &amp;lt;/configuration&amp;gt;
                  &amp;lt;/plugin&amp;gt;
              &amp;lt;/plugins&amp;gt;
          &amp;lt;/pluginManagement&amp;gt;
          &amp;lt;extensions&amp;gt;
              &amp;lt;extension&amp;gt;
                  &amp;lt;groupId&amp;gt;org.apache.maven.wagon&amp;lt;/groupId&amp;gt;
                  &amp;lt;artifactId&amp;gt;wagon-ftp&amp;lt;/artifactId&amp;gt;
                  &amp;lt;version&amp;gt;1.0-alpha-6&amp;lt;/version&amp;gt;
              &amp;lt;/extension&amp;gt;
          &amp;lt;/extensions&amp;gt;
      &amp;lt;/build&amp;gt;
      &amp;lt;!-- 配置远程发布到私服，mvn deploy --&amp;gt;
      &amp;lt;distributionManagement&amp;gt;
          &amp;lt;repository&amp;gt;
              &amp;lt;id&amp;gt;sphost&amp;lt;/id&amp;gt;
              &amp;lt;name&amp;gt;Nexus Release Repository&amp;lt;/name&amp;gt;
              &amp;lt;url&amp;gt;http://192.168.4.19:8081/nexus/content/repositories/sphost/&amp;lt;/url&amp;gt;
          &amp;lt;/repository&amp;gt;
          &amp;lt;snapshotRepository&amp;gt;
              &amp;lt;id&amp;gt;spsnap&amp;lt;/id&amp;gt;
              &amp;lt;name&amp;gt;Nexus Snapshot Repository&amp;lt;/name&amp;gt;
              &amp;lt;url&amp;gt;http://192.168.4.19:8081/nexus/content/repositories/spsnap/&amp;lt;/url&amp;gt;
          &amp;lt;/snapshotRepository&amp;gt;
      &amp;lt;/distributionManagement&amp;gt;
  &amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt; 清除、编译、测试、打包、安装到本机、发布到远程仓库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  F:\maven&amp;gt;cd hello
  F:\maven\hello&amp;gt;mvn clean compile test package install deploy
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Eclipse创建web工程&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt; 创建 maven web 工程&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  File/new/project/maven project/next/next
  选择创建maven web项目（maven-archetype-webapp）
  Group id: com.ailk.web.test
  Artiface id: hello
  Version: 0.0.1-SNAPSHOT
  Package: com.ailk.web.test.hello
  创建完按下面目录添加serverlet、struts.xml、web.xml以及一些页面
  src/main/java java源文件
  src/main/resources struts等配置文件目录
  src/main/webapp 页面以及web.xml文件目录
  target 编译和打包目录
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt; setting.xml 配置&lt;/p&gt;

&lt;p&gt;  添加一个 tomcat server&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;servers&amp;gt;
      &amp;lt;server&amp;gt;
              &amp;lt;id&amp;gt;sphost&amp;lt;/id&amp;gt;
              &amp;lt;username&amp;gt;admin&amp;lt;/username&amp;gt;
              &amp;lt;password&amp;gt;admin123&amp;lt;/password&amp;gt;
          &amp;lt;/server&amp;gt;
          &amp;lt;server&amp;gt;
              &amp;lt;id&amp;gt;spsnap&amp;lt;/id&amp;gt;
              &amp;lt;username&amp;gt;admin&amp;lt;/username&amp;gt;
              &amp;lt;password&amp;gt;admin123&amp;lt;/password&amp;gt;
          &amp;lt;/server&amp;gt;
          &amp;lt;server&amp;gt;
              &amp;lt;id&amp;gt;tomcat&amp;lt;/id&amp;gt;
              &amp;lt;username&amp;gt;admin&amp;lt;/username&amp;gt;
              &amp;lt;password&amp;gt;admin&amp;lt;/password&amp;gt;
          &amp;lt;/server&amp;gt;
    &amp;lt;/servers&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt; pom.xml 配置&lt;/p&gt;

&lt;p&gt;  添加编译 tomcat 插件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;build&amp;gt;
      &amp;lt;finalName&amp;gt;hello&amp;lt;/finalName&amp;gt;
      &amp;lt;plugins&amp;gt;
          &amp;lt;plugin&amp;gt;
              &amp;lt;groupId&amp;gt;org.codehaus.mojo&amp;lt;/groupId&amp;gt;
              &amp;lt;artifactId&amp;gt;tomcat-maven-plugin&amp;lt;/artifactId&amp;gt;
              &amp;lt;version&amp;gt;1.0-beta-1&amp;lt;/version&amp;gt;
              &amp;lt;configuration&amp;gt;
                  &amp;lt;url&amp;gt;http://localhost:8080/manager/text&amp;lt;/url&amp;gt;
                  &amp;lt;server&amp;gt;tomcat&amp;lt;/server&amp;gt;
              &amp;lt;/configuration&amp;gt;
          &amp;lt;/plugin&amp;gt;
      &amp;lt;/plugins&amp;gt;
  &amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt; 清除、编译、测试、打包、安装本地仓库、发布远程仓库、部署 tomcat 服务器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  项目右键/run as/maven build.../goals:clean compile test package install deploy site/run
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Jenkins+git+maven+junit 二</title>
   <link href="http://www.blogways.net/blog/2013/04/23/jenkins-git-maven-junit-2.html"/>
   <updated>2013-04-23T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/23/jenkins-git-maven-junit-2</id>
   <content type="html">&lt;h3&gt;一、概述&lt;/h3&gt;

&lt;p&gt;对于可持续集成描述及Jenkins介绍及安装在前面文档中有所介绍，本文就不做说明，本文只介绍如何实现Jenkins如何自动取git上web工程代码，maven实现编译及打包，最后Jenkins负责将war包发布到tomcat中&lt;/p&gt;

&lt;h3&gt;二、Jenkins配置及使用&lt;/h3&gt;

&lt;p&gt;tomcat中tomcat-users.xml文件添加如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;role rolename=&quot;manager-gui&quot;/&amp;gt;
&amp;lt;role rolename=&quot;manager-script&quot;/&amp;gt;   
&amp;lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;manager-gui,
 manager-script&quot;/&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 更改git仓库中pom.xml 文件，添加如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;plugin&amp;gt;
     &amp;lt;groupId&amp;gt;org.apache.tomcat.maven&amp;lt;/groupId&amp;gt;
     &amp;lt;artifactId&amp;gt;tomcat6-maven-plugin&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;2.0&amp;lt;/version&amp;gt;
      &amp;lt;configuration&amp;gt;
            &amp;lt;url&amp;gt;http://localhost:8080/manager&amp;lt;/url&amp;gt;
            &amp;lt;server&amp;gt;tomcat&amp;lt;/server&amp;gt;
            &amp;lt;!--  &amp;lt;uriEncoding&amp;gt;utf-8&amp;lt;/uriEncoding&amp;gt; --&amp;gt;
            &amp;lt;warSourceDirectory&amp;gt;WebContent&amp;lt;/warSourceDirectory&amp;gt; 

      &amp;lt;/configuration&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Maven安装目录下settings.xml文件添加如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;server&amp;gt;
    &amp;lt;id&amp;gt;tomcat&amp;lt;/id&amp;gt;
    &amp;lt;username&amp;gt;tomcat&amp;lt;/username&amp;gt;
    &amp;lt;password&amp;gt;tomcat&amp;lt;/password&amp;gt;
  &amp;lt;/server&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   其中&lt;id&gt;tomcat&lt;/id&gt; 与pom.xml 文件中&lt;server&gt;tomcat&lt;/server&gt; 要一致&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;进入“系统管理”-&gt;“插件管理”&lt;/p&gt;

&lt;p&gt;  1.选择“可选插件”tab页，找到“Deploy to container Plugin”插件并安装，为
   Jenkins部署tomcat工程所用&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;回到Jenkins首页，点击“新Job”，输入job名称如：MavenWeb，选择“构建一个maven2/3项目”&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;选择任务“MavenWeb”，点击“配置”进入任务配置界面，源代码管理中选择git,并输入仓库路径如：/home/git/MavenWeb/mytest，Branches to build根据自己需要输入，这里我取得主分支代码，输入的为master&lt;/li&gt;
&lt;li&gt;&lt;p&gt;“构建触发器”选择项下我选择的为“Poll SCM”，含义为在指定作业时间内有代码更新的时候去取代码，这里”Build periodically“含义为不管是否有代码更新在指定作业时间内都去取代码，”Build whenever a SNAPSHOT dependency is built“含义为当构建成功后，项目jar包会发到maven二方库上去
-”日程表“我这里配的是&lt;em&gt;/1 * * * &lt;/em&gt;，代表每隔一分钟取一次，这里五个 * 号从左到右分别
分 时 日 月 年，相同 * 号段内用”,“号隔开，如：&lt;em&gt; * 8,20 * * &lt;/em&gt;含义为每天8点、20点取代码
-”构建后操作“Editable Email NOtification” 其中Project Recipient List
可以配置收件人信箱，点击“高级”，“Add a Trigger”中可以选择对应触发器，我这里用到了构建失败(Failure),和测试报错(系统不稳定Unstable)两项，收件人选择了“Send To Recipient List”和提交者“Send To Committers”&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;“Deploy war/ear to a container” 中“WAR/EAR files”输入target/mytest.war，“Context path”输入MyApp（为项目访问contextPath），“Container”我这里用的tomcat6，所以选择tomcat6，“Tomcat URL”中输入tomcat访问地址如：http://192.168.4.19:8001&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;git上建立仓库将本地现有Maven+junit web项目push到git仓库，打开Jenkins主页进入MavenPrj任务，几分钟后就能看到构建任务及结果，&lt;/li&gt;
&lt;li&gt;构建成功后输入http://192.168.4.19:8001/MyApp即可访问项目首页&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Nexus 环境搭建</title>
   <link href="http://www.blogways.net/blog/2013/04/22/nexus.html"/>
   <updated>2013-04-22T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/22/nexus</id>
   <content type="html">&lt;h2&gt;安装&lt;/h2&gt;

&lt;p&gt;下载：http://nexus.sonatype.org/downloads/&lt;/p&gt;

&lt;p&gt;解压到服务器上&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;unix 启动：&lt;/p&gt;

&lt;p&gt; 目录：./nexus-2.3.1-01-bundle/nexus-2.3.1-01/bin/jsw/linux-x86-64&lt;/p&gt;

&lt;p&gt; 启动 nexus 服务：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; [spdev@slave2 linux-x86-64]$ sh nexus start
 Starting Nexus OSS... 
 Started Nexus OSS
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 从控制台可以看到 nexus 已经启动成功，可以在浏览器中访问&lt;/p&gt;

&lt;p&gt; http://192.168.4.19:8081/nexus/index.html#view-repositories&lt;/p&gt;

&lt;p&gt; login：admin/admin123&lt;/p&gt;

&lt;p&gt; 里面自带一些已经创建好的仓库供参考&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;window 启动：&lt;/p&gt;

&lt;p&gt; 目录：\nexus-2.3.1-01-bundle\nexus-2.3.1-01\bin\jsw\windows-x86-64&lt;/p&gt;

&lt;p&gt; 启动 nexus 服务:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; start-nexus.bat
 wrapper  | The nexus service is already running with status: RUNNING
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 访问同上，nexus 默认端口是 8081 ，如果有冲突可以在 \nexus-2.3.1-01-bundle\nexus-2.3.1-01\conf\nexus.properties 配置文件里面修改&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;创建我们自己的仓库&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建主机仓库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; Add/Hosted Repository
 Repository ID: Sphost
 Repository Name: SP Host
 Repository Policy: Release
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建代理仓库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; Add/Proxy Repository
 Repository ID: spproxy
 Repository Name: SP Proxy
 Remote Storage Location: http://repo1.maven.org/maven2/
 Download remote indexes: true
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建快照仓库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; Add/Hosted Repository
 Repository ID: Spsnap
 Repository Name: SP Snap
 Repository Policy: snapshot
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建仓库组&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; add/Repository Group
 Group ID:spgroup
 Group Name: SP Group
 Publish URL: TRUE
 Ordered group repositories: SP Host、SP Proxy、SP Snap
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 每个仓库后面都对应一个 repository path，这个地址在配 maven 的 setting.xml 跟项目的 pom.xml 文件里面的地址要对应上，否则会下载不走主机仓库或者没法发布到主机仓库。由于现在主机连不上网，代理仓库无法连到网上下载，本地maven从代理仓库下不了的时候会默认自动从中心库上下载所需要的jar包。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>windows 下安装jekyll</title>
   <link href="http://www.blogways.net/blog/2013/04/18/install-jekyll-on-windows.html"/>
   <updated>2013-04-18T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/18/install-jekyll-on-windows</id>
   <content type="html">&lt;h3&gt;一、ruby安装&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;下载 &lt;a href=&quot;http://www.ruby-lang.org/en/&quot;&gt;ruby&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;配置环境变量，path中添加ruby安装环境变量&lt;/li&gt;
&lt;li&gt;执行 ruby --version 检查ruby是否安装成功&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;二、DevKit&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;下载 &lt;a href=&quot;https://github.com/oneclick/rubyinstaller/downloads/&quot;&gt;DevKit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;解压DevKit，命令行下到DevKit目录，执行ruby dk.rb init    ruby dk.rb install&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;三、安装jekyll&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;执行gem install jekyll&lt;/li&gt;
&lt;li&gt;执行gem install rdiscount&lt;/li&gt;
&lt;li&gt;&lt;p&gt;打开命令窗口到博客工程根目录下执行jekyll --server，如果此处报字符集错误，请先设置环境变量执行
set LC_ALL=en_US.UTF-8，set  LANG=en_US.UTF-8，2.0及以后版本此方法不行，需修将ruby安装
目录下lib\ruby\gems\2.0.0\gems\jekyll-1.2.0\lib\jekyll下convertible.rb文件中
self.content = File.read(File.join(base, name))改为
self.content = File.read(File.join(base, name), :encoding =&gt; &quot;utf-8&quot;)，lib\ruby\gems\2.0.0\gems\jekyll-1.2.0\lib\jekyll\tags下include.rb文件中
source = File.read(File.join(includes_dir, @file))改为
source = File.read(File.join(includes_dir, @file), :encoding =&gt; &quot;utf-8&quot;)，然后再执行jekyll --server&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;服务启动成功后，在浏览器访问&lt;code&gt;localhost:4000&lt;/code&gt;，显示博客列表&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>Jenkins+git+maven+junit 一</title>
   <link href="http://www.blogways.net/blog/2013/04/17/jenkins-git-maven-junit.html"/>
   <updated>2013-04-17T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/17/jenkins-git-maven-junit</id>
   <content type="html">&lt;h3&gt;一、持续集成概述&lt;/h3&gt;

&lt;p&gt;随着软件开发复杂度的不断提高，团队开发成员间如何更好地协同工作以确保软件开发的质量已经慢慢成为开发过程中不可回避的问题。尤其是近些年来，敏捷（Agile） 在软件工程领域越来越红火，如何能再不断变化的需求中快速适应和保证软件的质量也显得尤其的重要。
持续集成正是针对这一类问题的一种软件开发实践。它倡导团队开发成员必须经常集成他们的工作，甚至每天都可能发生多次集成。而每次的集成都是通过自动化的构建来验证，包括自动编译、发布和测试，从而尽快地发现集成错误，让团队能够更快的开发内聚的软件。
持续集成的核心价值在于：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.持续集成中的任何一个环节都是自动完成的，无需太多的人工干预，有利于减少重复过程以节省时间、
  费用和工作量；
2.持续集成保障了每个时间点上团队成员提交的代码是能成功集成的。换言之，任何时间点都能第一时
  间发现软件的集成问题，使任意时间发布可部署的软件成为了可能；
3.持续集成还能利于软件本身的发展趋势，这点在需求不明确或是频繁性变更的情景中尤其重要，持
  续集成的质量能帮助团队进行有效决策，同时建立团队对开发产品的信心。 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;二、持续集成的原则&lt;/h3&gt;

&lt;p&gt;业界普遍认同的持续集成的原则包括：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.需要版本控制软件保障团队成员提交的代码不会导致集成失败。常用的版本控制软件有 CVS、
  Subversion、git 等，本文中用的是git；
2.开发人员必须及时向版本控制库中提交代码，也必须经常性地从版本控制库中更新代码到本地；
3.需要有专门的集成服务器来执行集成构建。根据项目的具体实际，集成构建可以被软件的修改来
  直接触发，也可以定时启动，如每半个小时构建一次；
4.必须保证构建的成功。如果构建失败，修复构建过程中的错误是优先级最高的工作。一旦修复，
  需要手动启动一次构建。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;三、持续集成系统的组成&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;1.一个自动构建过程，包括自动编译、分发、部署和测试等，本文中用的是maven+junit。 
2.一个代码存储库，即需要版本控制软件来保障代码的可维护性，同时作为构建过程的素材库，
  本文中用的是git。 
3.一个持续集成服务器。本文中用到的是jenkins。 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;四、Jenkins简介及安装&lt;/h3&gt;

&lt;p&gt;git、maven、junit本博客其他篇章中都有所介绍，所以今天我们主要介绍Jenkins的应用：
Jenkins 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，
专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文
件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;下载Jenkins，&lt;a href=&quot;http://jenkins-ci.org/&quot;&gt;http://jenkins-ci.org/ &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Jenkins 安装：本文介绍安装在linux主机上通过命令行安装&lt;/p&gt;

&lt;p&gt;  1.将下载的jenkins.war文件上传到linux主机安装目录下
     如：/home/spdev
  2.执行java -jar jenkins.war
  3.打开ie输入地址 http://hoestname:8080 （hostname为主机  ip）即能访问Jenkins,如自己设定端口可执行：java -jar jenkins.war --httpPort= port&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;五、Jenkins配置及使用&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;进入“系统管理”-&gt;“插件管理”&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  1.选择“已安装”tab页查看发下maven插件已经安装，git、junit插件没有安装
  2.选择“可选插件”tab页，在Filter输入框输入git，过滤条件后将git相关插件安装，同样
     操作安装junit插件
  3.选择“可选插件”tab页，找到“Jenkins Email Extension Plugin”插件并安装，此插件
     是后面发布及测试法邮件使用
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;进入“系统管理”-&gt;“系统设置”&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  1.选择“JDK”安装，定义别名，JAVA_HOME输入JDK安装目录
  2.选择“Git”安装，定义别名，安装目录输入Git安装目录
  3.选择“Maven”安装，定义别名，安装目录输入MAVEN_HOME安装目录
  4.“System Admin e-mail address”输入系统管理员邮箱地址
  5.“Extended E-mail Notification”标签为插件“Jenkins Email Extension Plugin“里
      内容，为邮件通知设置，这里我的配置如下图：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/jenkins-setting.jpg&quot; width=&quot;400&quot; height=&quot;300&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;回到Jenkins首页，点击“新Job”，输入job名称如：MavenPrj，选择“构建一个maven2/3项目”&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;选择任务“MavenPrj”，点击“配置”进入任务配置界面，源代码管理中选择git,并输入仓库路径如：/home/git/MavenPrj/mytest，Branches to build根据自己需要输入，这里我取得主分支代码，输入的为master&lt;/li&gt;
&lt;li&gt;“构建触发器”选择项下我选择的为“Poll SCM”，含义为在指定作业时间内有代码更新的时候去取代码，这里”Build periodically“含义为不管是否有代码更新在指定作业时间内都去取代码，”Build whenever a SNAPSHOT dependency is built“含义为当构建成功后，项目jar包会发到maven二方库上去&lt;/li&gt;
&lt;li&gt;&lt;p&gt;”日程表“我这里配的是&lt;em&gt;/1 * * * &lt;/em&gt;，代表每隔一分钟取一次，这里五个 * 号从左到右分别
分 时 日 月 年，相同 * 号段内用”,“号隔开，如：&lt;em&gt; * 8,20 * * &lt;/em&gt;含义为每天8点、20点取代码
-”构建后操作“Editable Email NOtification” 其中Project Recipient List
可以配置收件人信箱，点击“高级”，“Add a Trigger”中可以选择对应触发器，我这里用到了构建失败(Failure),和测试报错(系统不稳定Unstable)两项，收件人选择了“Send To Recipient List”和提交者“Send To Committers”&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;git上建立仓库将本地现有Maven+junit java项目push到git仓库，打开Jenkins主页进入MavenPrj任务，几分钟后就能看到构建任务及测试结果了，下面是构建完的效果图：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;/images/post/jenkins-setting2.jpg&quot; width=&quot;400&quot; height=&quot;300&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>JUnit4 使用进阶五</title>
   <link href="http://www.blogways.net/blog/2013/04/15/junit-usage-5.html"/>
   <updated>2013-04-15T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/15/junit-usage-5</id>
   <content type="html">&lt;p&gt;在&lt;a href=&quot;junit-usage-2.html&quot;&gt;进阶二&lt;/a&gt;中，我们介绍了&lt;code&gt;@Rule&lt;/code&gt;的两个用法，对异常进行检查和对超时时间的设定。其实，Rule还有很多用途，本文将做进一步介绍。&lt;/p&gt;

&lt;h3&gt;Rule的应用&lt;/h3&gt;

&lt;p&gt;Rule将在框架的很多方面提供解决方案。下面一一举例：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;TemporaryFolder&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; &lt;code&gt;TemporaryFolder&lt;/code&gt;作为Rule，可以运行在测试过程中创建临时文件或者临时目录，当测试结束后，框架会自动删除。&lt;/p&gt;

&lt;p&gt; 见实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   public static class HasTempFolder {
   @Rule
   public TemporaryFolder folder = new TemporaryFolder();

   @Test
   public void testUsingTempFolder() throws IOException {
     File createdFile = folder.newFile(&quot;myfile.txt&quot;);
     File createdFolder = folder.newFolder(&quot;subfolder&quot;);
     // ...
   }
 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;TemporaryFolder#newFolder(String... folderNames)&lt;/code&gt;可以根据输入的参数创建目录。如果是多级目录，可以递归创建。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TemporaryFolder#newFile()&lt;/code&gt;可以创建一个随机名字的临时文件；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TemporaryFolder##newFolder()&lt;/code&gt; 可以创建一个随机名字的临时目录。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;ExternalResource&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; &lt;code&gt;ExternalResource&lt;/code&gt;可以设置测试前后需要做的事情（比如：文件、socket、服务、数据库的连接与关闭）。这个我们在之前的&lt;a href=&quot;junit-usage-2.html&quot;&gt;进阶二&lt;/a&gt;中稍有提及。&lt;/p&gt;

&lt;p&gt; 见实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; public static class UsesExternalResource {
   Server myServer = new Server();

   @Rule
   public ExternalResource resource = new ExternalResource() {
     @Override
     protected void before() throws Throwable {
       myServer.connect();
     };

     @Override
     protected void after() {
       myServer.disconnect();
     };
   };

   @Test
   public void testFoo() {
     new Client().run(myServer);
   }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ExternalResource#before&lt;/code&gt;会在每个测试之前处理；&lt;code&gt;#after&lt;/code&gt;会在每个测试之后处理；&lt;/li&gt;
&lt;li&gt;关于&lt;code&gt;ExternalResource&lt;/code&gt;与&lt;code&gt;@Before&lt;/code&gt;已经&lt;code&gt;@After&lt;/code&gt;等标记步骤的执行顺序，我们会在本文后面部分介绍。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;ErrorCollector&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; &lt;code&gt;ErrorCollector&lt;/code&gt;这个Rule，在出现一个错误后，还可以让测试继续进行下去。&lt;/p&gt;

&lt;p&gt; 他提供三个方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; checkThat(final T value, Matcher&amp;lt;T&amp;gt; matcher)
 checkSucceeds(Callable&amp;lt;Object&amp;gt; callable)
 addError(Throwable error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 前面两个是用来处理断言的，最后一个是添加错误至错误列表中。&lt;/p&gt;

&lt;p&gt; 看下面例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; package mytest;

 import static org.hamcrest.CoreMatchers.is;
 import static org.junit.Assert.assertThat;

 import java.util.concurrent.Callable;

 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ErrorCollector;

 public class JUnitCoreErrorControllerRuleTest {

   private final int multiplesOf2[] = { 0, 2, 4, 7, 8, 11, 12 };

   @Rule
   public ErrorCollector errorCollector = new ErrorCollector();

   /*
    * 下面这个测试，会报告两个failures。这一点和下面的checkSucceeds测试不同
    */
   @Test
   public void testMultiplesOf2() {
     int multiple = 0;
     for (int multipleOf2 : multiplesOf2) {
       // Will count the number of issues in this list
       // - 3*2 = 6 not 7, 5*2 = 10 not 11 : 2 Failures
       errorCollector.checkThat(2 * multiple, is(multipleOf2));
       multiple++;
     }
   }

   /*
    * 下面代码中有两个断言会失败，但每次运行JUnit框架只会报告一个。这一点和上面的checkThat测试不同，可以对比一下。
    */
   @Test
   public void testCallableMultiples() {
     errorCollector.checkSucceeds(new Callable&amp;lt;Object&amp;gt;() {
       public Object call() throws Exception {
         assertThat(2 * 2, is(5));
         assertThat(2 * 3, is(6));
         assertThat(2 * 4, is(8));
         assertThat(2 * 5, is(9));
         return null;
       }
     });
   }

   /*
    * 下面运行时，会报告2个错误
    */
   @Test
   public void testAddingAnError() {
     assertThat(2 * 2, is(4));
     errorCollector.addError(new Throwable(&quot;Error Collector added an error&quot;));
     assertThat(2 * 3, is(6));
     errorCollector.addError(new Throwable(
         &quot;Error Collector added a second error&quot;));
   }

 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 运行结果，类似下面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; Failed tests: 

 testCallableMultiples(mytest.JUnitCoreErrorControllerRuleTest): 
 Expected: is &amp;lt;5&amp;gt;
     but: was &amp;lt;4&amp;gt;

 testMultiplesOf2(mytest.JUnitCoreErrorControllerRuleTest): 
 Expected: is &amp;lt;7&amp;gt;
     but: was &amp;lt;6&amp;gt;

 testMultiplesOf2(mytest.JUnitCoreErrorControllerRuleTest): 
 Expected: is &amp;lt;11&amp;gt;
     but: was &amp;lt;10&amp;gt;

 Tests in error: 
 testAddingAnError(tangzhi.mytest.JUnitCoreErrorControllerRuleTest): Error Collector added an error

 testAddingAnError(tangzhi.mytest.JUnitCoreErrorControllerRuleTest): Error Collector added a second error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 从这个例子，可以看出：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ErrorCollector#checkThat&lt;/code&gt; 会报告测试中的每一个failures&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ErrorCollector#checkSucceeds&lt;/code&gt; 只会检查是否成功，如果不成功，只报告第一个导致不成功的failure&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ErrorCollector#addError&lt;/code&gt; 是添加一个错误(error)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Verifier&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; 如果，你想在每个测试之后，甚至是在&lt;code&gt;@After&lt;/code&gt;之后，想检查些什么，就可以使用&lt;code&gt;Verifier&lt;/code&gt;这个Rule.&lt;/p&gt;

&lt;p&gt; 看例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; private static String sequence;

 public static class UsesVerifier {
   @Rule
   public Verifier collector = new Verifier() {
       @Override
       protected void verify() {
           sequence += &quot; verify &quot;;
       }
   };

   @Test
   public void example() {
       sequence += &quot;test&quot;;
   }

   @Test
   public void example2() {
       sequence += &quot;test2&quot;;
   }

   @After
   public void after() {
       sequence += &quot; after&quot;;
   }
 }

 @Test
 public void verifierRunsAfterTest() {
   sequence = &quot;&quot;;
   assertThat(testResult(UsesVerifier.class), isSuccessful());
   assertEquals(&quot;test after verify test2 after verify &quot;, sequence);
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 从上面例子可以看出:&lt;code&gt;Verifier#verify&lt;/code&gt;针对每个测试都会运行一次，并且运行在&lt;code&gt;@After&lt;/code&gt;步骤之后。&lt;/p&gt;

&lt;p&gt; 需要说明：如果某测试出现失败(fail)，那么这个测试之后就不会做&lt;code&gt;verify&lt;/code&gt;,这一点，可以结合下面的例子看出。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;TestWatcher&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; 对测试的每个步骤进行监控。&lt;/p&gt;

&lt;p&gt; 看例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; package tangzhi.mytest;

 import static org.junit.Assert.*;  
 import static org.hamcrest.CoreMatchers.*;

 import org.junit.After;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
 import org.junit.rules.TestWatcher;
 import org.junit.rules.Verifier;
 import org.junit.runner.Description;
 import org.junit.runners.model.Statement;

 public class WatchmanTest {
     private static String watchedLog;

       @Rule
       public TestRule watchman = new TestWatcher() {
         @Override
         public Statement apply(Statement base, Description description) {
             Statement s = super.apply(base, description);
             watchedLog=&quot;&quot;;
             System.out.println(&quot;watch apply.&quot;);
             return s;
         }

         @Override
         protected void succeeded(Description description) {
             watchedLog += description.getDisplayName() + &quot; &quot; + &quot;success!&quot;;
             System.out.println(&quot;watch succeed:&quot;+watchedLog);

         }

         @Override
         protected void failed(Throwable e, Description description) {
             watchedLog += description.getDisplayName() + &quot; &quot; + e.getClass().getSimpleName();
             System.out.println(&quot;watch failed:&quot;+watchedLog);

         }

         @Override
         protected void starting(Description description) {
           super.starting(description);
           System.out.println(&quot;watch starting.&quot;);
         }

         @Override
         protected void finished(Description description) {
           super.finished(description);
           System.out.println(&quot;watch finished.&quot;);
         }
       };

       @Rule
       public Verifier collector = new Verifier() {
           @Override
           protected void verify() {
               System.out.println(&quot;@Verify:&quot;+watchedLog);
           }
       };

       @Test
       public void fails() {
           System.out.println(&quot;in fails&quot;);
           assertThat(&quot;ssss&quot;, is(&quot;sss&quot;));
       }

       @Test
       public void succeeds() {
           System.out.println(&quot;in succeeds&quot;);
       }

       @After
       public void after() {
           System.out.println(&quot;@After&quot;);
       }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 运行后，日志如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; watch apply.
 watch starting.
 in succeeds
 @After
 watch succeed:succeeds(tangzhi.mytest.WatchmanTest) success!
 watch finished.
 @Verify:succeeds(tangzhi.mytest.WatchmanTest) success!
 watch apply.
 watch starting.
 in fails
 @After
 watch failed:fails(tangzhi.mytest.WatchmanTest) AssertionError
 watch finished.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;TestName&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; &lt;code&gt;TestName&lt;/code&gt;可以获取当前测试方法的名字。&lt;/p&gt;

&lt;p&gt; 看例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; public class NameRuleTest {
   @Rule
   public TestName name = new TestName();

   @Test
   public void testA() {
     assertEquals(&quot;testA&quot;, name.getMethodName());
   }

   @Test
   public void testB() {
     assertEquals(&quot;testB&quot;, name.getMethodName());
   }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 如果，是在参数化测试(Parameterized)中，使用了&lt;code&gt;@Parameters&lt;/code&gt;，那么其&lt;code&gt;name&lt;/code&gt;属性定义的方法名也将会被&lt;code&gt;TestName#getMethodName&lt;/code&gt;获取。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Timeout&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; 这个我们在前面介绍过，可以设置某个测试类，所有测试方法的超时时间。详见&lt;a href=&quot;junit-usage-2.html&quot;&gt;进阶二&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;ExpectedException&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; 这个也在&lt;a href=&quot;junit-usage-2.html&quot;&gt;进阶二&lt;/a&gt;中有介绍。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;ClassRule&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; 注释&lt;code&gt;@ClassRule&lt;/code&gt;是类级别的，而不是方法级别的。&lt;/p&gt;

&lt;p&gt; 见下面例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; @RunWith(Suite.class)
 @SuiteClasses({A.class, B.class, C.class})
 public class UsesExternalResource {
   public static Server myServer= new Server();

   @ClassRule
   public static ExternalResource resource= new ExternalResource() {
     @Override
     protected void before() throws Throwable {
       myServer.connect();
     };

     @Override
     protected void after() {
       myServer.disconnect();
     };
   };
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 在Suite所打包的几个类测试前后，会执行一遍&lt;code&gt;ClassRule&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;RuleChain&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;见例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static class UseRuleChain {
    @Rule
    public TestRule chain= RuleChain
                           .outerRule(new LoggingRule(&quot;outer rule&quot;)
                           .around(new LoggingRule(&quot;middle rule&quot;)
                           .around(new LoggingRule(&quot;inner rule&quot;);

    @Test
    public void example() {
        assertTrue(true);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行后，日志如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;starting outer rule
starting middle rule
starting inner rule
finished inner rule
finished middle rule
finished outer rule
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>JUnit4 使用进阶四</title>
   <link href="http://www.blogways.net/blog/2013/04/15/junit-usage-4.html"/>
   <updated>2013-04-15T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/15/junit-usage-4</id>
   <content type="html">&lt;div class=&quot;code fl&quot;&gt;
    &lt;dl&gt;
    &lt;dt&gt;目录&lt;/dt&gt;
    &lt;dd&gt;
    &lt;ol&gt;
        &lt;li&gt;&lt;a href=&quot;#1&quot;&gt;Suite测试&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#2&quot;&gt;Parameterized测试&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#3&quot;&gt;Categories测试&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#4&quot;&gt;Theories测试&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#5&quot;&gt;第三方的Runner&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#6&quot;&gt;小结&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
    &lt;/dd&gt;
    &lt;/dl&gt;
&lt;/div&gt;


&lt;p&gt;在&lt;a href=&quot;junit-usage-1.html&quot;&gt;进阶一&lt;/a&gt;，我们介绍了默认的JUnit4默认的运行器是&lt;code&gt;JUnit4&lt;/code&gt;。本文，我们将继续向大家介绍JUnit4框架提供的另外几个非常实用的运行器(Runner)：&lt;code&gt;Suite&lt;/code&gt;、&lt;code&gt;Parameterized&lt;/code&gt;、&lt;code&gt;Categories&lt;/code&gt;、&lt;code&gt;Enclosed&lt;/code&gt;和&lt;code&gt;Theories&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在测试中，可以使用注释&lt;code&gt;@RunWith&lt;/code&gt;来指定这些运行器，比如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@RunWith(Parameterized.class)
public class MyTest { …
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好吧，下面我们来一一介绍吧！&lt;/p&gt;

&lt;h3&gt;&lt;a name=&quot;1&quot;&gt;&lt;/a&gt;一、Suite测试&lt;/h3&gt;

&lt;p&gt;进行&lt;code&gt;Suite&lt;/code&gt;测试可以将多个待测试的类，打包(Suite)一起测试。在入口测试类上加两个注释:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@RunWith(Suite.class)
@SuiteClasses(TestClass1.class, ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你运行这个入口测试类，框架就会把打包在一起的所有待测试类都测试一遍。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import org.junit.runner.RunWith;
import org.junit.runners.Suite;

@RunWith(Suite.class)
@Suite.SuiteClasses({
    TestFeatureLogin.class,
    TestFeatureLogout.class,
    TestFeatureNavigate.class,
    TestFeatureUpdate.class
})

public class FeatureTestSuite {
  // the class remains empty,
  // used only as a holder for the above annotations
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;框架运行那些待测试的类，是按他们在&lt;code&gt;@Suite.SuiteClasses&lt;/code&gt;中罗列的顺序开始测试。&lt;/p&gt;

&lt;h3&gt;&lt;a name=&quot;2&quot;&gt;&lt;/a&gt;二、Parameterized测试&lt;/h3&gt;

&lt;p&gt;很多时候，需要用很多测试数据进行多次测试。怎么办？通过复制粘贴代码来实现？累...&lt;/p&gt;

&lt;p&gt;针对这种情况，JUnit4框架提供&lt;code&gt;Parameterized&lt;/code&gt;测试器(&lt;code&gt;Runner&lt;/code&gt;)来实现这种需求。&lt;/p&gt;

&lt;p&gt;看下面这个例子:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package mytest;

import static org.junit.Assert.*;

import java.util.Arrays;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameters;

@RunWith(Parameterized.class)
public class FibonacciTest {
    @Parameters
    public static Iterable&amp;lt;Object[]&amp;gt; data() {
        return Arrays.asList(new Object[][] { { 0, 0 }, { 1, 1 }, { 2, 1 },
                { 3, 2 }, { 4, 3 }, { 5, 5 }, { 6, 8 } });
    }

    private int fInput;

    private int fExpected;

    public FibonacciTest(int input, int expected) {
        fInput= input;
        fExpected= expected;
    }
    @Test
    public void test() {
        assertEquals(fExpected, Fibonacci.compute(fInput));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很简单，很方便是吧！&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;用&lt;code&gt;@Parameters&lt;/code&gt;来标记，我们为测试准备的数据&lt;/li&gt;
&lt;li&gt;定义一个构造函数，构造函数的参数顺序和准备数据的顺序一致&lt;/li&gt;
&lt;li&gt;写你需要的测试方法，用&lt;code&gt;@Test&lt;/code&gt;注释&lt;/li&gt;
&lt;li&gt;运行起来，每个数据都会测试一遍&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;如果，你不习惯去写那样一个构造函数，也可以用下面的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@RunWith(Parameterized.class)
public class FibonacciTest {
    @Parameters
    public static Iterable&amp;lt;Object[]&amp;gt; data() {
        return Arrays.asList(new Object[][] { { 0, 0 }, { 1, 1 }, { 2, 2 },
                { 3, 2 }, { 4, 3 }, { 5, 5 }, { 6, 8 } });
    }

    @Parameter(0)
    public int fInput;

    @Parameter(1)
    public int fExpected;

    @Test
    public void test() {
        assertEquals(fExpected, Fibonacci.compute(fInput));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行起来是不是很爽！&lt;/p&gt;

&lt;p&gt;可能，你是一个完美主义者，对运行后报错信息不是很满意，现在报错时反馈的信息可能是这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;test[3](mytest.FibonacciTest): expected:&amp;lt;2&amp;gt; but was:&amp;lt;0&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你想报错时显示测试的输入数据，希望报错类似如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;test[the 3 test, input:3,2](mytest.FibonacciTest): expected:&amp;lt;2&amp;gt; but was:&amp;lt;0&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要实现这点很简单，给&lt;code&gt;@Parameters&lt;/code&gt;加个参数&lt;code&gt;name&lt;/code&gt;，整个代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package mytest;

import static org.junit.Assert.*;

import java.util.Arrays;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameters;

@RunWith(Parameterized.class)
public class FibonacciTest {
    @Parameters(name=&quot;the {index} test, input:{0},{1}&quot;)
    public static Iterable&amp;lt;Object[]&amp;gt; data() {
        return Arrays.asList(new Object[][] { { 0, 0 }, { 1, 1 }, { 2, 1 },
                { 3, 2 }, { 4, 3 }, { 5, 5 }, { 6, 8 } });
    }

    private int fInput;

    private int fExpected;

    public FibonacciTest(int input, int expected) {
        fInput= input;
        fExpected= expected;
    }
    @Test
    public void test() {
        assertEquals(fExpected, Fibonacci.compute(fInput));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里需要稍微解释一下&lt;code&gt;name&lt;/code&gt;中的几个参数的含义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{index} 表示序号，测试数据在整个数据列表中的序号
{0} 表示第一个参数
{1} 表示第二个参数
...
{n} 表示第n+1个参数
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;a name=&quot;3&quot;&gt;&lt;/a&gt;三、Categories测试&lt;/h3&gt;

&lt;p&gt;一个测试类里面包含很多待测试的方法，很多时候，我们需要把这些待测试的方法分类，某些时候测试某类方法，那么需要怎么做呢？&lt;/p&gt;

&lt;p&gt;看下面这个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface FastTests { /* category marker */ }
public interface SlowTests { /* category marker */ }

public class A {
  @Test
  public void a() {
    fail();
  }

  @Category(SlowTests.class)
  @Test
  public void b() {
  }
}

@Category({SlowTests.class, FastTests.class})
public class B {
  @Test
  public void c() {

  }
}

@RunWith(Categories.class)
@IncludeCategory(SlowTests.class)
@SuiteClasses( { A.class, B.class }) // Note that Categories is a kind of Suite
public class SlowTestSuite {
  // Will run A.b and B.c, but not A.a
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中，将会测试&lt;code&gt;A.b&lt;/code&gt;和&lt;code&gt;B.c&lt;/code&gt;两个方法，不会测试&lt;code&gt;A.a&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;再看下面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@RunWith(Categories.class)
@IncludeCategory(SlowTests.class)
@ExcludeCategory(FastTests.class)
@SuiteClasses( { A.class, B.class }) // Note that Categories is a kind of Suite
public class SlowTestSuite {
  // Will run A.b, but not A.a or B.c
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这次，只会运行&lt;code&gt;A.b&lt;/code&gt;，而不会运行&lt;code&gt;A.a&lt;/code&gt;和&lt;code&gt;B.c&lt;/code&gt;。&lt;/p&gt;

&lt;h3&gt;&lt;a name=&quot;4&quot;&gt;&lt;/a&gt;四、Theories测试&lt;/h3&gt;

&lt;p&gt;结合前面&lt;a href=&quot;junit-usage-3.html&quot;&gt;进阶三&lt;/a&gt;中介绍的假设(assumeThat)，我们可以对大量的测试数据做一些理论测试。&lt;/p&gt;

&lt;p&gt;先看例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@RunWith(Theories.class)
public class UserTest {
    @DataPoint
    public static String GOOD_USERNAME = &quot;optimus&quot;;
    @DataPoint
    public static String USERNAME_WITH_SLASH = &quot;optimus/prime&quot;;

    @Theory
    public void filenameIncludesUsername(String username) {
        assumeThat(username, not(containsString(&quot;/&quot;)));
        assertThat(new User(username).configFileName(), containsString(username));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是不是看得有点苦涩难懂，没关系，我来给你一一讲解：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;@RunWith(Theories.class)&lt;/code&gt; 是告诉框架，下面的测试类将要做理论测试；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@DataPoint&lt;/code&gt; 告诉框架，标注的这些数据都是准备用来测试的数据；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Theory&lt;/code&gt;标注的方法，是需要进行理论测试的方法；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;assumeThat&lt;/code&gt; 是对待测试的数据(&lt;code&gt;@DataPoint&lt;/code&gt;标注的数据)进行检查，符合的数据继续往下走，不符合的数据忽略掉.如果，所有的数据都不符合，那么&lt;code&gt;@Theory&lt;/code&gt;标注的测试，则算失败(fail)。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;关于理论测试，也可以扩展更多的功能，网上已经有人做了一些扩展，比如&lt;a href=&quot;http://web.archive.org/web/20071012143326/popper.tigris.org/tutorial.html&quot;&gt;这里&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;&lt;a name=&quot;5&quot;&gt;&lt;/a&gt;五、第三方的Runner&lt;/h3&gt;

&lt;p&gt;我们也可以使用&lt;code&gt;@RunWith&lt;/code&gt;来标注一些第三方的Runner，比如：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;SpringJUnit4ClassRunner&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/test/context/junit4/SpringJUnit4ClassRunner.html&quot;&gt;http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/test/context/junit4/SpringJUnit4ClassRunner.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MockitoJUnitRunner&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.mockito.googlecode.com/hg/latest/org/mockito/runners/MockitoJUnitRunner.html&quot;&gt;http://docs.mockito.googlecode.com/hg/latest/org/mockito/runners/MockitoJUnitRunner.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;&lt;a name=&quot;6&quot;&gt;&lt;/a&gt;六、小结&lt;/h3&gt;

&lt;p&gt;让我们回顾一下，本文介绍了JUnit4里面内置的几个特色运行器（Runner），包括：将多个测试类打包一起测试的Suite、可以实现参数化测试的Parameterized、可以实现分类测试的Categories、可以实现理论测试的Theories，还有网络上的一些第三方Runner。&lt;/p&gt;

&lt;p&gt;根据实际情况的需要，合理的利用这些Runner，可以达到事半功倍的效果。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>JUnit4 使用进阶三</title>
   <link href="http://www.blogways.net/blog/2013/04/15/junit-usage-3.html"/>
   <updated>2013-04-15T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/15/junit-usage-3</id>
   <content type="html">&lt;div class=&quot;code fl&quot;&gt;
    &lt;dl&gt;
    &lt;dt&gt;目录&lt;/dt&gt;
    &lt;dd&gt;
    &lt;ol&gt;
        &lt;li&gt;&lt;a href=&quot;#1&quot;&gt;不得不说的`assertThat`方法&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#2&quot;&gt;还有个`assumeThat`方法&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
    &lt;/dd&gt;
    &lt;/dl&gt;
&lt;/div&gt;


&lt;p&gt;在&lt;a href=&quot;junit-usage-1.html&quot;&gt;JUnit4 使用进阶一&lt;/a&gt;中，我们介绍了JUnit4中断言的基本用法，在本文我们要做深入的介绍。当前JUnit4框架已经引入了 Hamcrest 匹配机制，使得程序员在编写单元测试的 assert 语句时，可以具有更强的可读性，而且也更加灵活。&lt;/p&gt;

&lt;h3&gt;&lt;a name=&quot;1&quot;&gt;&lt;/a&gt;一、不得不说的&lt;code&gt;assertThat&lt;/code&gt;方法&lt;/h3&gt;

&lt;p&gt;JUnit4 结合 Hamcrest 提供了一个全新的断言语法——&lt;code&gt;assertThat&lt;/code&gt;。程序员可以只使用 &lt;code&gt;assertThat&lt;/code&gt; 一个断言语句，结合 Hamcrest 提供的匹配符，就可以表达全部的测试思想。&lt;/p&gt;

&lt;p&gt;其基本语法为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;assertThat([message,] value, matcher-statement);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;第一个参数&lt;code&gt;message&lt;/code&gt;，为可选参数，为出错是的提示信息；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;value&lt;/code&gt;为想要测试的变量；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;matcher-statement&lt;/code&gt;为使用 Hamcrest 匹配符来表达的对前面变量所期望的值的声明，如果 value 值与 &lt;code&gt;matcher-statement&lt;/code&gt; 所表达的期望值相符，则测试成功，否则测试失败。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;开发人员可以通过实现 Matcher 接口，定制自己想要的匹配符。当开发人员发现自己的某些测试代码在不同的测试中重复出现，经常被使用，这时用户就可以自定义匹配符，将这些代码绑定在一个断言语句中，从而可以达到减少重复代码并且更加易读的目的。&lt;/p&gt;

&lt;p&gt;目前，JUnit提供的匹配符，定义在两个类里面:&lt;code&gt;org.junit.matchers.JUnitMatchers&lt;/code&gt;和&lt;code&gt;org.hamcrest.CoreMatchers&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;org.junit.matchers.JUnitMatchers&lt;/code&gt;提供的匹配符，目前有两个：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;isThrowable(Matcher&amp;lt;T&amp;gt; throwableMatcher);
isException(Matcher&amp;lt;T&amp;gt; exceptionMatcher);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而&lt;code&gt;org.hamcrest.CoreMatchers&lt;/code&gt;提供的匹配符就很多了，常用的有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;核心&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;anything - 总是匹配,如果你不关心测试下的对象是什么是有用的&lt;/li&gt;
&lt;li&gt;describedAs - 添加一个定制的失败表述装饰器&lt;/li&gt;
&lt;li&gt;is - 改进可读性的装饰器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;逻辑&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;allOf - 如果所有匹配器都匹配才匹配, short circuits (很难懂的一个词,意译是短路,感觉不对,就没有翻译)(像 Java &amp;amp;&amp;amp;)&lt;/li&gt;
&lt;li&gt;anyOf - 如果任何匹配器匹配就匹配, short circuits (像 Java ||)&lt;/li&gt;
&lt;li&gt;not - 如果包装的匹配器不匹配器时匹配,反之亦然&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对象&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;equalTo - 测试对象相等使用Object.equals方法&lt;/li&gt;
&lt;li&gt;hasToString - 测试Object.toString方法&lt;/li&gt;
&lt;li&gt;instanceOf, isCompatibleType - 测试类型&lt;/li&gt;
&lt;li&gt;notNullValue, nullValue - 测试null&lt;/li&gt;
&lt;li&gt;sameInstance - 测试对象实例&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Beans&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;hasProperty - 测试JavaBeans属性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;集合&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;array - 测试一个数组元素test an array’s elements against an array of matchers&lt;/li&gt;
&lt;li&gt;hasEntry, hasKey, hasValue - 测试一个Map包含一个实体,键或者值&lt;/li&gt;
&lt;li&gt;hasItem, hasItems - 测试一个集合包含一个元素&lt;/li&gt;
&lt;li&gt;hasItemInArray - 测试一个数组包含一个元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数字&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;closeTo - 测试浮点值接近给定的值&lt;/li&gt;
&lt;li&gt;greaterThan, greaterThanOrEqualTo, lessThan, lessThanOrEqualTo - 测试次序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;文本&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;equalToIgnoringCase - 测试字符串相等忽略大小写&lt;/li&gt;
&lt;li&gt;equalToIgnoringWhiteSpace - 测试字符串忽略空白&lt;/li&gt;
&lt;li&gt;containsString, endsWith, startsWith - 测试字符串匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;如何自定义一个匹配符呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;看代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package mytest;

import org.hamcrest.Description;
import org.hamcrest.Factory;
import org.hamcrest.Matcher;
import org.hamcrest.TypeSafeMatcher;

public class IsNotANumber extends TypeSafeMatcher&amp;lt;Double&amp;gt; {

  @Override
  public boolean matchesSafely(Double number) {
    return number.isNaN();
  }

  public void describeTo(Description description) {
    description.appendText(&quot;not a number&quot;);
  }

  @Factory
  public static &amp;lt;T&amp;gt; Matcher&amp;lt;Double&amp;gt; notANumber() {
    return new IsNotANumber();
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以这样用于测试：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void testSquareRootOfMinusOneIsNotANumber() {
    assertThat(Math.sqrt(-1), is(notANumber()));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;a name=&quot;1&quot;&gt;&lt;/a&gt;一、还有个&lt;code&gt;assumeThat&lt;/code&gt;方法&lt;/h3&gt;

&lt;p&gt;理想情况下，写测试用例的开发人员可以明确的知道所有导致他们所写的测试用例不通过的地方，但是有的时候，这些导致测试用例不通过的地方并不是很容易的被发现，可能隐藏得很深，从而导致开发人员在写测试用例时很难预测到这些因素，而且往往这些因素并不是开发人员当初设计测试用例时真正目的，他们的测试点是希望测试出被测代码中别的出错地方。&lt;/p&gt;

&lt;p&gt;比如，一个测试用例运行的 locale（如：Locale.US）与之前开发人员设计该测试用例时所设想的不同（如：Locale.UK），这样会导致测试不通过，但是这可能并不 是开发人员之前设计测试用例时所设想的测试出来的有用的失败结果（测试点并不是此，比如测试的真正目的是想判断函数的返回值是否为 true，返回 false 则测试失败），这时开发人员可以通过编写一些额外的代码来消除这些影响（比如将 locale 作为参数传入到测试用例中，每次运行测试用例时，明确指定 locale），但是花费时间和精力来编写这些不是测试用例根本目的的额外代码其实是种浪费，这时就可以使用 Assumption 假设机制来轻松达到额外代码的目的。编写该测试用例时，首先假设 locale 必须是 Locale.UK，如果运行时 locale 是 Locale.UK，则继续执行该测试用例函数，如果是其它的 locale，则跳过该测试用例函数，执行该测试用例函数以外的代码，这样就不会因为 locale 的问题导致测试出错。&lt;/p&gt;

&lt;p&gt;JUnit4 结合 Hamcrest 库提供了 assumeThat 语句，开发人员可以使用其配合匹配符 Matcher 设计所有的假设条件（语法和 assertThat 一样）。&lt;/p&gt;

&lt;p&gt;看下面例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import static org.junit.Assume.*
@Test public void filenameIncludesUsername() {
    assumeThat(File.separatorChar, is('/'));
    assertThat(new User(&quot;optimus&quot;).configFileName(), is(&quot;configfiles/optimus.cfg&quot;));
}

@Test public void correctBehaviorWhenFilenameIsNull() {
    assumeTrue(bugFixed(&quot;13356&quot;));  // bugFixed is not included in JUnit
    assertThat(parse(null), is(new NullDocument()));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JUnit自带的运行器(Runner)会忽略那些假设不成立的测试数据，而自定义运行器的处理逻辑可能会不一样。&lt;/p&gt;

&lt;p&gt;上面这个例子，也可以结合&lt;a href=&quot;junit-usage-4.html&quot;&gt;进阶四&lt;/a&gt;中的理论测试来一起理解。&lt;/p&gt;

&lt;p&gt;另外，假设也可以用在&lt;code&gt;@Before&lt;/code&gt; 或者 &lt;code&gt;@BeforeClass&lt;/code&gt;这两个步骤里面。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>JUnit4 使用进阶二</title>
   <link href="http://www.blogways.net/blog/2013/04/15/junit-usage-2.html"/>
   <updated>2013-04-15T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/15/junit-usage-2</id>
   <content type="html">&lt;div class=&quot;code fl&quot;&gt;
    &lt;dl&gt;
    &lt;dt&gt;目录&lt;/dt&gt;
    &lt;dd&gt;
    &lt;ol&gt;
        &lt;li&gt;&lt;a href=&quot;#1&quot;&gt;忽略某个测试&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#2&quot;&gt;对异常的测试&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#3&quot;&gt;测试的超时时间&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#4&quot;&gt;测试前后&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#5&quot;&gt;小结&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
    &lt;/dd&gt;
    &lt;/dl&gt;
&lt;/div&gt;


&lt;p&gt;在&lt;a href=&quot;junit-usage-1.html&quot;&gt;JUnit4 使用进阶一&lt;/a&gt;中，我们介绍了JUnit4的下载安装，简单调用及运行测试方法，在本文中将继续对JUnit4提供的一些常用功能（忽略某个测试、对异常进行测试、设置超时时间、测试前后及顺序）进行介绍。&lt;/p&gt;

&lt;h3&gt;&lt;a name=&quot;1&quot;&gt;&lt;/a&gt;一、忽略某个测试&lt;/h3&gt;

&lt;p&gt;在测试过程中，我们可能需要临时禁止某个方法或者某个测试类的测试，比如：由于没完全准备好或者平台差异。这时，我们需要有一个方法可以告诉JUnit4框架，不要对这些方法或者类进行测试。&lt;/p&gt;

&lt;p&gt;基于这个需要，JUnit4提供了一个注释&lt;code&gt;@Ignore&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;举个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Ignore 
@Test 
public void something() { ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;@Ignore&lt;/code&gt;也可以添加一个可选的字符串参数，来说明为什么要忽略这个测试，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Ignore(&quot;还没准备好&quot;) 
@Test 
public void something() { ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，&lt;code&gt;@Ignore&lt;/code&gt;也可以直接作用在一个测试类上，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Ignore 
public class IgnoreMe {
    @Test 
    public void test1() { ... }

    @Test 
    public void test2() { ... }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;a name=&quot;2&quot;&gt;&lt;/a&gt;二、对异常的测试&lt;/h3&gt;

&lt;p&gt;程序是否会按照我们所期待的，在运行过程中抛出异常呢？比如下面这个语句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new ArrayList&amp;lt;Object&amp;gt;().get(0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码将会抛出&lt;code&gt;IndexOutOfBoundsException&lt;/code&gt;异常，&lt;code&gt;@Test&lt;/code&gt;注释有一个可选参数&lt;code&gt;expected&lt;/code&gt;,这个参数的取值是&lt;code&gt;Throwable&lt;/code&gt;的子类。如果我们想判断上面的代码是否抛出正确的异常，测试代码可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test(expected= IndexOutOfBoundsException.class) 
public void empty() { 
    new ArrayList&amp;lt;Object&amp;gt;().get(0); 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JUnit4框架会对上面&lt;code&gt;expected&lt;/code&gt;参数值进行检查，被测试的方法中如果抛出&lt;code&gt;IndexOutOfBoundsException&lt;/code&gt;异常，那么测试就通过了。&lt;/p&gt;

&lt;p&gt;一般，对异常的简单的测试，使用上面的方法就够了，但是有时，我们需要检查异常所包含的提示信息，那么我们就需要使用&lt;code&gt;ExpectedException&lt;/code&gt;规则，来帮助我们实现了。&lt;/p&gt;

&lt;p&gt;看下面这个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Rule
public ExpectedException thrown = ExpectedException.none();

@Test
public void shouldTestExceptionMessage() throws IndexOutOfBoundsException {
    List&amp;lt;Object&amp;gt; list = new ArrayList&amp;lt;Object&amp;gt;();

    thrown.expect(IndexOutOfBoundsException.class);
    thrown.expectMessage(&quot;Index: 0, Size: 0&quot;);
    list.get(0); // execution will never get past this line
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;利用&lt;code&gt;@Rule&lt;/code&gt;，我们可以对异常的提示信息进行检查。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;expectMessage&lt;/code&gt;方法还支持使用&lt;code&gt;CoreMatchers.containsString&lt;/code&gt;来进行提示信息的匹配判断,如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; thrown.expectMessage(CoreMatchers.containsString(&quot;Size: 0&quot;));
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;&lt;a name=&quot;3&quot;&gt;&lt;/a&gt;三、测试的超时时间&lt;/h3&gt;

&lt;p&gt;有时，我们需要控制程序的执行时间，当超出预设的超时时间，那么就判断测试失败。JUnit4框架也提供了这种检查，看下面例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test(timeout=1000)
public void testWithTimeout() {
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过&lt;code&gt;@Test&lt;/code&gt;注释的一个可选参数&lt;code&gt;timeout&lt;/code&gt;的数值(单位毫秒)，我们可以告诉框架，预设的超时时间是多少。当测试运行中，执行时间超出了这个预设值，框架就会抛出&lt;code&gt;TimeoutException&lt;/code&gt;异常，标记这个测试失败了。&lt;/p&gt;

&lt;p&gt;我们也可以使用规则，来为整个测试类里面所有测试方法设置一个统一的超时时间，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class HasGlobalTimeout {
    public static String log;

    @Rule
    public Timeout globalTimeout = new Timeout(10000); // 10 seconds max per method tested

    @Test
    public void testInfiniteLoop1() {
        log += &quot;ran1&quot;;
        for (;;) {
        }
    }

    @Test
    public void testInfiniteLoop2() {
        log += &quot;ran2&quot;;
        for (;;) {
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;a name=&quot;4&quot;&gt;&lt;/a&gt;四、测试前后&lt;/h3&gt;

&lt;p&gt;每个测试之前，我们可能需要做一些数据准备操作，再每个测试之后，我们可能需要将测试数据进行恢复。那么，JUnit4框架如何提供什么样的方式，来实现我们的需求呢？&lt;/p&gt;

&lt;p&gt;没错，JUnit4提供了四个注释，来标注测试类中的某些方法，是用来做测试前后的准备或者恢复操作的。这四个注释分别为:&lt;code&gt;@Before&lt;/code&gt;、&lt;code&gt;@After&lt;/code&gt;、&lt;code&gt;@BeforeClass&lt;/code&gt;和&lt;code&gt;@AfterClass&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;看下面这个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package test;

import java.io.Closeable;
import java.io.IOException;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

public class TestFixturesExample {
  static class ExpensiveManagedResource implements Closeable {
    @Override
    public void close() throws IOException {}
  }

  static class ManagedResource implements Closeable {
    @Override
    public void close() throws IOException {}
  }

  @BeforeClass
  public static void setUpClass() {
    System.out.println(&quot;@BeforeClass setUpClass&quot;);
    MyExpensiveManagedResource = new ExpensiveManagedResource();
  }

  @AfterClass
  public static void tearDownClass() throws IOException {
    System.out.println(&quot;@AfterClass tearDownClass&quot;);
    MyExpensiveManagedResource.close();
    MyExpensiveManagedResource = null;
  }

  private ManagedResource myManagedResource;
  private static ExpensiveManagedResource MyExpensiveManagedResource;

  private void println(String string) {
    System.out.println(string);
  }

  @Before
  public void setUp() {
    this.println(&quot;@Before setUp&quot;);
    this.myManagedResource = new ManagedResource();
  }

  @After
  public void tearDown() throws IOException {
    this.println(&quot;@After tearDown&quot;);
    this.myManagedResource.close();
    this.myManagedResource = null;
  }

  @Test
  public void test1() {
    this.println(&quot;@Test test1()&quot;);
  }

  @Test
  public void test2() {
    this.println(&quot;@Test test2()&quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子的执行结果，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@BeforeClass setUpClass
@Before setUp
@Test test2()
@After tearDown
@Before setUp
@Test test1()
@After tearDown
@AfterClass tearDownClass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;@Before&lt;/code&gt;和&lt;code&gt;@After&lt;/code&gt;定义的方法，会在每个测试方法运行的前后执行一遍；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@BeforeClass&lt;/code&gt;和&lt;code&gt;@AfterClass&lt;/code&gt;定义的方法，会在整个测试类运行的开始和结束执行且仅执行一遍。&lt;/li&gt;
&lt;li&gt;一般来说，&lt;code&gt;@Before&lt;/code&gt;、&lt;code&gt;@After&lt;/code&gt;、&lt;code&gt;@BeforeClass&lt;/code&gt;和&lt;code&gt;@AfterClass&lt;/code&gt;提供的方法，是在某个测试类里面所使用的，无法被另外的测试类所公用，如果你想写一个类来处理数据，并被几个测试类所使用，那么你可以使用规则来实现。关于这一点，你可以看看我们后面的教程。&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;&lt;a name=&quot;5&quot;&gt;&lt;/a&gt;五、小结&lt;/h3&gt;

&lt;p&gt;在本文中，我们进一步介绍了JUnit4框架提供的一些功能，在继续的教程中，我们将介绍几个有特色的运行器，来提高测试效率。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>JUnit4 使用进阶一</title>
   <link href="http://www.blogways.net/blog/2013/04/15/junit-usage-1.html"/>
   <updated>2013-04-15T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/15/junit-usage-1</id>
   <content type="html">&lt;div class=&quot;code fl&quot;&gt;
    &lt;dl&gt;
    &lt;dt&gt;目录&lt;/dt&gt;
    &lt;dd&gt;
    &lt;ol&gt;
        &lt;li&gt;&lt;a href=&quot;#1&quot;&gt;简介&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#2&quot;&gt;下载安装&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#3&quot;&gt;一个简单的模版&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#4&quot;&gt;运行测试&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#5&quot;&gt;JUnit4的核心之一是断言&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#6&quot;&gt;小结&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
    &lt;/dd&gt;
    &lt;/dl&gt;
&lt;/div&gt;


&lt;h3&gt;&lt;a name=&quot;1&quot;&gt;&lt;/a&gt;一、简介&lt;/h3&gt;

&lt;p&gt;JUnit是一个Java语言的单元测试框架。它由Kent Beck和Erich Gamma建立，逐渐成为源于Kent Beck的sUnit的xUnit家族中为最成功的一个。来自JUnit的体验对测试驱动开发是很重要的，所以一些 JUnit知识经常 和测试驱动开发的讨论融合在一起。可以参考Kent Beck的 &lt;a href=&quot;http://book.douban.com/subject/1771049/&quot;&gt;《Test-Driven Development: By Example》&lt;/a&gt;一书（有中文版和影印版）。&lt;/p&gt;

&lt;p&gt;本文，对JUnit4的下载安装、基本测试方法及运行，配合实例进行基础介绍。帮助读者看完之后，就可以将JUnit4运用到单元测试中去。而JUnit4的更多功能可以参考后续的&lt;a href=&quot;junit-usage-2.html&quot;&gt;JUnit4使用进阶二&lt;/a&gt;。&lt;/p&gt;

&lt;h3&gt;&lt;a name=&quot;2&quot;&gt;&lt;/a&gt;二、下载安装&lt;/h3&gt;

&lt;p&gt;JUnit当前版本是4.11，如果，你的工程是使用Maven进行管理构建，那么只需要在工程的pom.xml文件中添加如下依赖信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;4.11&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;否则，在你的测试classpath中放置下面两个jar:&lt;code&gt;junit.jar&lt;/code&gt;和&lt;code&gt;hamcrest-core.jar&lt;/code&gt;，这两个jar可以在&lt;a href=&quot;http://search.maven.org/&quot;&gt;这里&lt;/a&gt;找到并下载。&lt;/p&gt;

&lt;h3&gt;&lt;a name=&quot;3&quot;&gt;&lt;/a&gt;三、一个简单的模版&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package com.example.foo;

import static org.junit.Assert.assertEquals;

import org.junit.Test;
import org.junit.Ignore;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

/**
 * Tests for {@link Foo}.
 *
 * @author user@example.com (John Doe)
 */
@RunWith(JUnit4.class)
public class FooTest {

    @Test
    public void thisAlwaysPasses() {
    }

    @Test
    @Ignore
    public void thisIsIgnored() {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个模版是不是很简单！&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;需要测试的方法，只需要通过&lt;code&gt;@Test&lt;/code&gt;标注出来就可以了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;测试类只需要添加&lt;code&gt;@RunWith&lt;/code&gt;注释，不再需要继承&lt;code&gt;junit.framework.TestCase&lt;/code&gt;这个父类了。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;当然了，JUnit4还提供了很多特色功能，后面我们会一一介绍。&lt;/p&gt;

&lt;h3&gt;&lt;a name=&quot;4&quot;&gt;&lt;/a&gt;四、运行测试&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在命令行，对写好的测试类，进行测试很简单，只需要下面一个命令就ok了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  java -cp .:/usr/share/java/junit.jar org.junit.runner.JUnitCore [test class name]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在IDE里面进行测试就更简单了，&lt;code&gt;Netbeans&lt;/code&gt;, &lt;code&gt;Eclipse&lt;/code&gt; 和 &lt;code&gt;IntelliJ Idea&lt;/code&gt;都内置了图形化的测试运行器。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;测试类如何运行，是由&lt;code&gt;@RunWith&lt;/code&gt;注释来决定。JUnit4当前版本的默认基本测试方式是&lt;code&gt;JUnit4.class&lt;/code&gt;。除此之外，还有一些其他特殊的，我们将在&lt;a href=&quot;junit-usage-4.html&quot;&gt;JUnit4 使用进阶四&lt;/a&gt;中进行介绍。&lt;/p&gt;

&lt;h3&gt;&lt;a name=&quot;5&quot;&gt;&lt;/a&gt;五、JUnit4的核心之一是断言&lt;/h3&gt;

&lt;p&gt;JUnit4框架主要是通过断言来判断运行结果正确与否，针对Java的原生类型(long,boolean,float...)或者Objects或者数组，JUnit都提供了对应的断言方法。&lt;/p&gt;

&lt;p&gt;下面，我们先来看个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import static org.hamcrest.CoreMatchers.allOf;
import static org.hamcrest.CoreMatchers.anyOf;
import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.not;
import static org.hamcrest.CoreMatchers.sameInstance;
import static org.hamcrest.CoreMatchers.startsWith;
import static org.junit.Assert.assertThat;
import static org.junit.matchers.JUnitMatchers.both;
import static org.junit.matchers.JUnitMatchers.containsString;
import static org.junit.matchers.JUnitMatchers.everyItem;
import static org.junit.matchers.JUnitMatchers.hasItems;

import java.util.Arrays;

import org.hamcrest.core.CombinableMatcher;
import org.junit.Test;

public class AssertTests {
  @Test
  public void testAssertArrayEquals() {
    byte[] expected = &quot;trial&quot;.getBytes();
    byte[] actual = &quot;trial&quot;.getBytes();
    org.junit.Assert.assertArrayEquals(&quot;failure - byte arrays not same&quot;, expected, actual);
  }

  @Test
  public void testAssertEquals() {
    org.junit.Assert.assertEquals(&quot;failure - strings not same&quot;, 5l, 5l);
  }

  @Test
  public void testAssertFalse() {
    org.junit.Assert.assertFalse(&quot;failure - should be false&quot;, false);
  }

  @Test
  public void testAssertNotNull() {
    org.junit.Assert.assertNotNull(&quot;should not be null&quot;, new Object());
  }

  @Test
  public void testAssertNotSame() {
    org.junit.Assert.assertNotSame(&quot;should not be same Object&quot;, new Object(), new Object());
  }

  @Test
  public void testAssertNull() {
    org.junit.Assert.assertNull(&quot;should be null&quot;, null);
  }

  @Test
  public void testAssertSame() {
    Integer aNumber = Integer.valueOf(768);
    org.junit.Assert.assertSame(&quot;should be same&quot;, aNumber, aNumber);
  }

  // JUnit Matchers assertThat
  @Test
  public void testAssertThatBothContainsString() {
    org.junit.Assert.assertThat(&quot;albumen&quot;, both(containsString(&quot;a&quot;)).and(containsString(&quot;b&quot;)));
  }

  @Test
  public void testAssertThathasItemsContainsString() {
    org.junit.Assert.assertThat(Arrays.asList(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;), hasItems(&quot;one&quot;, &quot;three&quot;));
  }

  @Test
  public void testAssertThatEveryItemContainsString() {
    org.junit.Assert.assertThat(Arrays.asList(new String[] { &quot;fun&quot;, &quot;ban&quot;, &quot;net&quot; }), everyItem(containsString(&quot;n&quot;)));
  }

  // Core Hamcrest Matchers with assertThat
  @Test
  public void testAssertThatHamcrestCoreMatchers() {
    assertThat(&quot;good&quot;, allOf(equalTo(&quot;good&quot;), startsWith(&quot;good&quot;)));
    assertThat(&quot;good&quot;, not(allOf(equalTo(&quot;bad&quot;), equalTo(&quot;good&quot;))));
    assertThat(&quot;good&quot;, anyOf(equalTo(&quot;bad&quot;), equalTo(&quot;good&quot;)));
    assertThat(7, not(CombinableMatcher.&amp;lt;Integer&amp;gt; either(equalTo(3)).or(equalTo(4))));
    assertThat(new Object(), not(sameInstance(new Object())));
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;assertEquals&lt;/code&gt;和&lt;code&gt;assertSame&lt;/code&gt; 的区别在于，前者是调用&lt;code&gt;期待值&lt;/code&gt;的&lt;code&gt;equals&lt;/code&gt;方法来判断&lt;code&gt;真实值&lt;/code&gt;(&lt;code&gt;expected.equals(actual)&lt;/code&gt;)，而后者是判断&lt;code&gt;期待值&lt;/code&gt;和&lt;code&gt;真实值&lt;/code&gt;是否是同一个对象(&lt;code&gt;expected == actual&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;例子中，这样调用&lt;code&gt;org.junit.Assert.assertEquals(&quot;failure - strings not same&quot;, 5l, 5l);&lt;/code&gt;是不是觉得有点累，没关系，我们可以通过JDK1.5中的静态导入(&lt;code&gt;import static&lt;/code&gt;)来简化这一切，看下面的代码。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;简化后的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package tangzhi.mytest;

import static org.hamcrest.CoreMatchers.allOf;
import static org.hamcrest.CoreMatchers.anyOf;
import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.not;
import static org.hamcrest.CoreMatchers.sameInstance;
import static org.hamcrest.CoreMatchers.startsWith;
import static org.junit.Assert.assertThat;
import static org.junit.matchers.JUnitMatchers.both;
import static org.junit.matchers.JUnitMatchers.containsString;
import static org.junit.matchers.JUnitMatchers.everyItem;
import static org.junit.matchers.JUnitMatchers.hasItems;

import static org.junit.Assert.*;

import java.util.Arrays;

import org.hamcrest.core.CombinableMatcher;
import org.junit.Test;

public class AppTest {
  @Test
  public void testAssertArrayEquals() {
    byte[] expected = &quot;trial&quot;.getBytes();
    byte[] actual = &quot;trial&quot;.getBytes();
    assertArrayEquals(&quot;failure - byte arrays not same&quot;, expected, actual);
  }

  @Test
  public void testAssertEquals() {
    assertEquals(&quot;failure - strings not same&quot;, 5l, 5l);
  }

  @Test
  public void testAssertFalse() {
    assertFalse(&quot;failure - should be false&quot;, false);
  }

  @Test
  public void testAssertNotNull() {
    assertNotNull(&quot;should not be null&quot;, new Object());
  }

  @Test
  public void testAssertNotSame() {
    assertNotSame(&quot;should not be same Object&quot;, new Object(), new Object());
  }

  @Test
  public void testAssertNull() {
    assertNull(&quot;should be null&quot;, null);
  }

  @Test
  public void testAssertSame() {
    Integer aNumber = Integer.valueOf(768);
    assertSame(&quot;should be same&quot;, aNumber, aNumber);
  }

  // JUnit Matchers assertThat
  @Test
  public void testAssertThatBothContainsString() {
    assertThat(&quot;albumen&quot;, both(containsString(&quot;a&quot;)).and(containsString(&quot;b&quot;)));
  }

  @Test
  public void testAssertThathasItemsContainsString() {
    assertThat(Arrays.asList(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;), hasItems(&quot;one&quot;, &quot;three&quot;));
  }

  @Test
  public void testAssertThatEveryItemContainsString() {
    assertThat(Arrays.asList(new String[] { &quot;fun&quot;, &quot;ban&quot;, &quot;net&quot; }), everyItem(containsString(&quot;n&quot;)));
  }

  // Core Hamcrest Matchers with assertThat
  @Test
  public void testAssertThatHamcrestCoreMatchers() {
    assertThat(&quot;good&quot;, allOf(equalTo(&quot;good&quot;), startsWith(&quot;good&quot;)));
    assertThat(&quot;good&quot;, not(allOf(equalTo(&quot;bad&quot;), equalTo(&quot;good&quot;))));
    assertThat(&quot;good&quot;, anyOf(equalTo(&quot;bad&quot;), equalTo(&quot;good&quot;)));
    assertThat(7, not(CombinableMatcher.&amp;lt;Integer&amp;gt; either(equalTo(3)).or(equalTo(4))));
    assertThat(new Object(), not(sameInstance(new Object())));
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的代码中，我们静态导入了&lt;code&gt;import static org.junit.Assert.*;&lt;/code&gt;后，在测试类中就可以直接使用&lt;code&gt;assertEquals&lt;/code&gt;这些方法了。是不是很方便！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;常用的断言方法有：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;assertTrue([message ,] condition);
assertFalse([message ,] condition);
assertEquals([message ,] expected, actual);
assertNotEquals([message ,] first, second);
assertArrayEquals([message ,] expecteds, actuals);
assertNotNull([message ,] object);
assertNull([message ,] object);
assertSame([message ,] expected, actual);
assertNotSame([message ,] unexpected, actual);
assertThat([message ,] actual, matcher);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;从上面的列表可以看出：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;大部分断言方法的参数顺序都是:&lt;code&gt;[Message] 期待值  真实值&lt;/code&gt;，第一个参数是个可选字符串，出错时的描述信息。第二个参数是期待值，第三个参数是真实值。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;只有一个断言方法&lt;code&gt;assertThat&lt;/code&gt;的参数顺序例外：可选的出错提示信息、真实值和一个&lt;code&gt;Matcher&lt;/code&gt;对象。它参数中的期待值与真实值的顺序，与其他断言方法的参数顺序正好相反。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;这个&lt;code&gt;assertThat&lt;/code&gt;方法是断言中的神器，后面我们会在&lt;a href=&quot;junit-usage-3.html&quot;&gt;进阶三&lt;/a&gt;介绍！敬请期待吧！&lt;/p&gt;

&lt;h3&gt;&lt;a name=&quot;6&quot;&gt;&lt;/a&gt;六、小结&lt;/h3&gt;

&lt;p&gt;前面我们介绍了JUnit4的基本知识。至此，你已经可以使用JUnit4进行代码测试了。如果你想知道更多信息，可以继续看看&lt;a href=&quot;junit-usage-2.html&quot;&gt;JUnit 使用进阶二&lt;/a&gt;。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>jekyll 教程入门</title>
   <link href="http://www.blogways.net/blog/2013/04/13/jekyll-usage.html"/>
   <updated>2013-04-13T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/13/jekyll-usage</id>
   <content type="html">&lt;h2&gt;jekyll 教程入门&lt;/h2&gt;

&lt;div class=&quot;code fl&quot;&gt;
    &lt;dl&gt;
    &lt;dt&gt;目录&lt;/dt&gt;
    &lt;dd&gt;
    &lt;ol&gt;
        &lt;li&gt;&lt;a href=&quot;#1&quot;&gt;安装jekyll&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#2&quot;&gt;搭建网站框架&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#3&quot;&gt;编写博文&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#4&quot;&gt;一些Jekyll网站例子及源码&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
    &lt;/dd&gt;
    &lt;/dl&gt;
&lt;/div&gt;


&lt;p&gt;&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki&quot;&gt;jekyll&lt;/a&gt; 是一款简单的博客系统，也可以说是一个静态网站生成器。她有一个模版目录，存放整个静态网站的模版文件，可以通过&lt;a href=&quot;https://github.com/shopify/liquid/wiki&quot;&gt;Liquid&lt;/a&gt;处理模版文件，把使用标记语言&lt;a href=&quot;http://en.wikipedia.org/wiki/Textile&quot;&gt;Textile&lt;/a&gt;或&lt;a href=&quot;http://en.wikipedia.org/wiki/Markdown&quot;&gt;Markdown&lt;/a&gt;编写的内容文件，按照模版格式，转换成最终的静态网站页面。大名鼎鼎的GitHub Pages就是通过她实现的。&lt;/p&gt;

&lt;p&gt;在这里，我们将告诉你如果使用jekyll搭建一个简单的博客网站。&lt;/p&gt;

&lt;h3&gt;&lt;a name=&quot;1&quot;&gt;&lt;/a&gt;一、安装jekyll&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;使用&lt;a href=&quot;http://rubygems.org/&quot;&gt;RubyGems&lt;/a&gt;安装jekyll。安装了Ruby之后，默认会自动安装RubyGems，也可以单独安装RubyGems.&lt;/p&gt;

&lt;p&gt;使用RubyGems安装jekyll很简单，命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem install jekyll 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果使用的标记语言是Markdown，则需要另外安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem install rdiscount
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果使用的标记语言是Textile,则需要另外安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem install RedCloth
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面三个可以一次性安装，如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem install jekyll rdiscount RedCloth
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是Mac环境下面，可能会出现版本问题，无法安装，可以参考我的另外一篇博文——&lt;a href=&quot;/2013/04/08/install-jekyll-on-mac.html&quot;&gt;MAC OS X 10.8 下安装jekyll&lt;/a&gt; 进行安装。&lt;/p&gt;

&lt;h3&gt;&lt;a name=&quot;2&quot;&gt;&lt;/a&gt;二、搭建博客网站框架&lt;/h3&gt;

&lt;p&gt;jekyll 的内核实际上就是一个格式文本转换引擎，她允许你使用标记语言Markdown或者Textile再或者原始的html语言，编写内容。她通过模版文件，将这些内容转换成最终的静态网页。&lt;/p&gt;

&lt;p&gt;一个简单的jekyll网站结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
|-- _config.yml
|-- _includes
|-- _layouts
|   |-- default.html
|   `-- post.html
|-- _posts
|   |-- 2007-10-29-why-every-programmer-should-play-nethack.textile
|   `-- 2009-04-26-barcamp-boston-4-roundup.textile
|-- _site
`-- index.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这基本结构中，有几个关键的文件或者目录，其作用如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;_config.yml&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; 这是jekyll的主要配置文件。这些配置选项，大部分都可以在启动jekyll时，作为命令行参数执行。只不过，把这些选项配置在文件中，就省去记住他们，且每次执行jekyll时命令也简单一点。&lt;/p&gt;

&lt;p&gt; 关于jekyll的参数，其实系统已经设置了&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Configuration&quot;&gt;默认值&lt;/a&gt;，如无特殊需要，空文件也可以。&lt;/p&gt;

&lt;p&gt; 个人推荐，可以添加两个参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; markdown: rdiscount
 pygments: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; &lt;strong&gt;&lt;code&gt;rdiscount&lt;/code&gt;&lt;/strong&gt;是markdown标记语言的一个转换引擎，比默认的&lt;code&gt;maruku&lt;/code&gt;性能要好一些。&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;&lt;code&gt;pygments&lt;/code&gt;&lt;/strong&gt;是支持语法高亮显示的工具。设置开通后，可以通过 &lt;code&gt;{\% highlight \%}&lt;/code&gt; 标签在博文中嵌入语法高亮的代码。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;_includes&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; 这个目录的存在是区分高手和普通用户的，嘿嘿。在网站设计中，页面的共有部分，可以存储成一个单独的文件。这样设计可以方便以后的维护。而这个单独的公用文件就存放在这个目录里面。这里面的公用文件，可以被&lt;code&gt;_layouts&lt;/code&gt;和&lt;code&gt;_post&lt;/code&gt;目录下面的文件嵌入。其嵌入方法，采用的是Liquid标签实现。比如：&lt;code&gt;{\% include file.ext \%}&lt;/code&gt;，就指在文件中嵌入公用文件&lt;code&gt;_includes/file.ext&lt;/code&gt;中的内容。&lt;/p&gt;

&lt;p&gt; 是不是很方便！？哈哈！&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;_layouts&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; 这个目录下存放的是整个网站的模版文件，可以是一个文件，也可以是一套文件。这个要看整个网站是怎么规划了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;_posts&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; 这个目录是存放你的博文的，整个网站搭建完成后，以后每次添加博文，只需要提交到这个目录下就可以了。&lt;/p&gt;

&lt;p&gt; 不过，编写的博文，必须符合一定的规则。见下面&lt;a href=&quot;#3&quot;&gt;编写博文&lt;/a&gt;小节内容。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;_site&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; 这个目录，是jekyll运行之后生成的。存放着整个网站的最终静态页面。其中的内容，不用去关心。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;index.html和其他的 HTML/Markdown/Textile文件&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; 这些文件如果包含&lt;code&gt;YAML&lt;/code&gt;信息块，那么jekyll运行时就会自动对他进行转换。你网站根目录，以及任何不在上述目录下的文件(包括&lt;code&gt;.html&lt;/code&gt;/&lt;code&gt;.markdown&lt;/code&gt;/&lt;code&gt;.md&lt;/code&gt;/&lt;code&gt;texitle&lt;/code&gt;文件，但不仅这些文件)。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;其他文件和目录&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; 除了上述文件和目录，你还可以添加一些其他的文件或者目录。比如，添加css目录，存放网站的css文件；添加images目录，存放网站涉及到的图片资源。噢，对了，你还可以在网站的根目录下一个网站图标文件&lt;code&gt;favicon.ico&lt;/code&gt;，这样别人访问你的网站时，体验会更好一点。设计优秀的网站图标，能帮助访问者，更容易记住你的网站哦！&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;&lt;a name=&quot;3&quot;&gt;&lt;/a&gt;三、编写博文&lt;/h3&gt;

&lt;p&gt;从上一小节的内容，我们知道&lt;code&gt;_posts&lt;/code&gt;目录下面存放的是我们的博文，这些博文必须满足一定的规则。这里，我将告诉大家相关的规则。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;博文的命名是有讲究的，必须符合&lt;code&gt;YEAR-MONTH-DAY-title.MARKUP&lt;/code&gt;这个格式。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博文的永久链接(PermaLink)生成规则很灵活，可以配置(在&lt;code&gt;_config.yml&lt;/code&gt;中)。系统内置三种格式：&lt;/p&gt;

&lt;p&gt; &lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt; 模版名 &lt;/th&gt;
 &lt;th&gt; 模版内容 &lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt; date &lt;/td&gt;
 &lt;td&gt; /:categories/:year/:month/:day/:title/  &lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt; pretty &lt;/td&gt;
 &lt;td&gt; /:categories/:year/:month/:day/:title/  &lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt; none &lt;/td&gt;
 &lt;td&gt; /:categories/:title.html &lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
 &lt;/table&gt;&lt;/p&gt;

&lt;p&gt; 目前系统默认格式是&lt;code&gt;date&lt;/code&gt;。你也可以修改，比如，在&lt;code&gt;_config.yml&lt;/code&gt;中配置&lt;code&gt;permalink: pretty&lt;/code&gt;。这样就会生成类似&lt;code&gt;/2009/04/29/slap-chop/index.html&lt;/code&gt;这样的文件url.除了内置的格式，也可以自定义格式，比如&lt;code&gt;permalink: /blog/:month-:day-:year/:title.html&lt;/code&gt;。是不是很酷？哈哈！&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;博文可以是用标记语言Markdown或者Textile再或者原始的html语言编写的文本。但是，博文的开头必须包含一个&lt;code&gt;YAML&lt;/code&gt;信息块。在这个&lt;code&gt;YAML&lt;/code&gt;信息块，包含一些信息。比如使用的模版，博文的标题等等。给个简单的例子吧，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ---
 layout: post
 title: jekyll 教程入门
 ---
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;到此，基本内容已经讲完了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;&lt;a name=&quot;4&quot;&gt;&lt;/a&gt;四、运行jekyll生成网站&lt;/h3&gt;

&lt;p&gt;在网站根目录下，运行&lt;code&gt;jekyll&lt;/code&gt;命令，就可以生成最终的静态网站内容目录&lt;code&gt;_site&lt;/code&gt;。如果，你还想通过浏览器访问，可以运行下面命令。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jekyll --server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，通过&lt;code&gt;http://localhost:4000&lt;/code&gt;就可以访问你做出来的网站了。&lt;/p&gt;

&lt;p&gt;如果你的博客网站是类似&lt;code&gt;http://localhost:4000/blog/index.html&lt;/code&gt;这样的路径。那么，在运行时，需要添加参数&lt;code&gt;base-url&lt;/code&gt;来实现，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jekyll --base-url '/blog' --server
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;a name=&quot;5&quot;&gt;&lt;/a&gt;五、一些Jekyll网站例子及源码&lt;/h3&gt;

&lt;p&gt;下面给一些建在GitHub上面的jekyll博客，及其源码。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://tom.preston-werner.com/&quot;&gt;tom.preston-werner.com&lt;/a&gt;——&lt;a href=&quot;http://github.com/mojombo/mojombo.github.io&quot;&gt;源码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://gitready.com/&quot;&gt;gitready.com&lt;/a&gt;——&lt;a href=&quot;http://github.com/gitready/gitready&quot;&gt;源码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zen.id.au/&quot;&gt;zen.id.au&lt;/a&gt;——&lt;a href=&quot;https://github.com/zensavona/zensavona.github.com&quot;&gt;源码&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>git服务器部署及使用</title>
   <link href="http://www.blogways.net/blog/2013/04/13/git.html"/>
   <updated>2013-04-13T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/13/git</id>
   <content type="html">&lt;h3&gt;一、概述&lt;/h3&gt;

&lt;p&gt;Git是用于Linux内核开发的版本控制工具。与CVS、Subversion一类的集中式版本控制工具不同，它采用了分布式版本库的作法，不需要服务器端软件，就可以运作版本控制，使得源代码的发布和交流极其方便。Git的速度很快，这对于诸如Linux kernel这样的大项目来说自然很重要。Git最为出色的是它的合并追踪（merge tracing）能力。&lt;/p&gt;

&lt;p&gt;实际上内核开发团队决定开始开发和使用Git来作为内核开发的版本控制系统的时候，世界开源社群的反对声音不少，最大的理由是Git太艰涩难懂，从Git的内部工作机制来说，的确是这样。但是随着开发的深入，Git的正常使用都由一些友善的命令稿来执行，使Git变得非常好用。现在，越来越多的著名项目采用Git来管理项目开发。&lt;/p&gt;

&lt;h3&gt;二、实现原理&lt;/h3&gt;

&lt;p&gt;Git和其他版本控制系统（如CVS）有不少的差别，Git本身关心档案的整体性是否有改变，但多数的CVS，或Subversion系统则在乎档案内容的差异。因此Git更像一个档案系统，直接在本机上取得资料，不必连线到host端取资料回来。&lt;/p&gt;

&lt;h3&gt;三、安装git&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;linux上安装：&lt;/p&gt;

&lt;p&gt; linux上安装git可以源代码安装和预编译好的Git二进制安装包安装两种方式，
 本次安装是在redHat上采用源码安装的:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;主机上建立一个用户git&lt;/li&gt;
&lt;li&gt;&lt;p&gt;root用户登录，修改/ect目录下sudoers文件，将git用户加入sudo列表&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下载源代码
  &lt;a href=&quot;http://git-scm.com/download&quot;&gt;http://git-scm.com/download&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;上传redHat主机解压编译并安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $tar -zxf git-1.7.2.2.tar.gz
  $ cd git-1.7.2.2
  $ make prefix=/usr/local all
  $ sudo make prefix=/usr/local install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中/usr/local为安装目录&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改git用户下 ~/.bash_profile文件（没有新建），添加PATH=$PATH:/usr/local/bin&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改git用户下.bashrc文件（没有新建），添加 PATH=$HOME/bin:$PATH&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;$git --version，显示git版本git version 1.8.1.6，表示git安装成功&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;windows上安装&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;下载msysGit安装包
&lt;a href=&quot;http://code.google.com/p/msysgit&quot;&gt; http://code.google.com/p/msysgit &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;安装msysGit，右键运行git Bash，输入git --version，
显示git version 1.7.11.msysgit.1，windows上git安装成功&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;四、git配置&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;linux 上git服务器配置：&lt;/p&gt;

&lt;p&gt; 首先我们都需要先配置下自己的 Git 工作环境。配置工作只需一次，以后升级时还会沿用现在的配置。当然，如果需要，你随时可以用相同的命令修改已有的配置。
 Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。
 而正是由这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。
 这些变量可以存放在以下三个不同的地方：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; • /etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用git config 时用
   --system 选项，读写的就是这个文件
 • ~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用git config 时用
   --global 选项，读写的就是这个文件
 • 当前项目的 git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：所以
   .git/config 里的配置会覆盖/etc/  gitconfig 中的同名变量
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;配置的是你个人的用户名称和电子邮件地址&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ git config --global user.name &quot;tangsz&quot;
  $ git config --global user.email &quot;tangsz@asiainfo-linkage.com&quot; 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;文本编辑器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ git config --global core.editor vi
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查看配置信息 git config --list&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;windows 上msysGit配置&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;生成公钥
      右键打开git Bash，输入ssh-keygen –C “你的email地址 “ –t rsa 就会为你生成一个 SSH Key，
      然后会询问一些保存文件的位置，设置密码神马的，直接回车，回车，回车，默认的就可以了，SSH 公
      钥默认储存在账户的主目录下的 ~/.ssh 目录something 和 something.pub 来命名的一对文件，
      这个 something 通常就是 id_dsa 或 id_rsa，有 .pub 后缀的文件就是公钥&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将公钥文件放到主机git用户.ssh目录下（没有此目录就新建），将公钥文件内容追加到  文件authorized_keys文件（没有就新建）尾部即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  cat /tmp/id_rsa.pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  这样后面windows与服务器交互clone、pull等操作时就不用频繁输入密码了&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;五、服务器上部署git&lt;/h3&gt;

&lt;p&gt;服务器上部署git仓库有很多种方式，这里简单介绍两种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;直接在服务器上需建立仓库目录执行 git init，通常我们在服务器上建立的仓库都是裸仓库-即一个不含工作目录的仓库，所以我们这里执行git --bare init建立裸仓库，--bare表示建立的是裸仓库&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;本机clone一个裸仓库移到服务器上，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ git clone --bare my_project my_project.git
  $ scp -r my_project.git user@192.168.4.19:/home/git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  user为服务器上建立的git用户，192.168.4.19为主机地址，/home/git为裸仓库存放目录，这样所有对该服务器有 SSH 访问权限，并可读取 /home/git 目录的用户都可以用下面的命令克隆该项目&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;注：裸仓库建立完后，更改裸仓库目录下config文件添加&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[receive]
    denyCurrentBranch = ignore)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;否则本机push操作会报master branch is currently checked out&lt;/p&gt;

&lt;h3&gt;六、git操作&lt;/h3&gt;

&lt;p&gt;git的操作需在实践中慢慢熟悉，这里简单介绍一些平时常用的：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;本地仓库操作&lt;/p&gt;

&lt;p&gt; windows下命令行操作仓库在安装msysGit后只需右键执行git Bash就可以操作了，
 也可以下载TortoiseGit通过可视化操作本地及远程仓库，此处就简单介绍命令行操作仓库，不做TortoiseGit操作介绍&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;克隆一个仓库：git有git、ssh、http(s)几种协议，这里用的是ssh git clone git:192.168.4.19：/home/git/my_project.git git为服务器用户名、192.168.4.19为服务器地址、/home/git/my_project.git为服务器仓库目录&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;git status  --检查文件&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;git add 文件名   --新增文件&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;git commit  --提交操作&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;git log  --查看日志&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;git commit --amend   --撤销提交&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;git mv file_from file_to  --文件改名&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;git diff  --查看working tree与index file的差别&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;git rm  --删除文件&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;远程仓库操作&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;git remote -v --查看远程仓库&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;git fetch [remote-name]  --获取remote-name库数据不merge&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;git push [remote-name] [branch-name]  --上传数据都remote-name库branch-name分支&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;git remote show origin      -- 查看origin库信息&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;git remote rename pb paul   ---把 pb 改成 paul&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;git pull     --从远程获取最新版本并merge到本地,相当于git fetch 和 git merge&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>创建SSH密钥，并连接GitHub</title>
   <link href="http://www.blogways.net/blog/2013/04/10/generating-ssh-keys-4-github.html"/>
   <updated>2013-04-10T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/10/generating-ssh-keys-4-github</id>
   <content type="html">&lt;div class=&quot;code fl&quot;&gt;
    &lt;dl&gt;
    &lt;dt&gt;目录&lt;/dt&gt;
    &lt;dd&gt;
    &lt;ol&gt;
        &lt;li&gt;&lt;a href=&quot;#1&quot;&gt;Windows环境下生成SSH Keys，并连接GitHub&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#2&quot;&gt;Mac环境下生成SSH Keys，并连接GitHub&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#3&quot;&gt;单机如何控制不同的SSH Keys连不同的Git环境?&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
    &lt;/dd&gt;
    &lt;/dl&gt;
&lt;/div&gt;


&lt;p&gt;我们可以使用SSH Keys在本机和GitHub之间建立一个安全的连接。下面，我们将手把手教您如何创建SSH Keys并将公钥加到你的GitHub账户中。&lt;/p&gt;

&lt;div class=&quot;clr&quot;&gt;&lt;/div&gt;


&lt;h3&gt;&lt;a name=&quot;1&quot;&gt;&lt;/a&gt;一、Windows环境下生成SSH key且连接GitHub&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4&gt;第一步、看看是否存在SSH密钥(keys)&lt;/h4&gt;

&lt;p&gt;首先，我们需要看看是否看看本机是否存在SSH keys,打开Git Bash,并运行:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cd ~/.ssh
# 检查你本机用户home目录下是否存在.ssh目录
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果，不存在此目录，则进行第二步操作，否则，你本机已经存在ssh公钥和私钥，可以略过第二步，直接进入第三步操作。&lt;/p&gt;

&lt;h4&gt;第二步、创建一对新的SSH密钥(keys)&lt;/h4&gt;

&lt;p&gt;输入如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ssh-keygen -t rsa -C &quot;your_email@example.com&quot;
#这将按照你提供的邮箱地址，创建一对密钥
Generating public/private rsa key pair.
Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;直接回车，则将密钥按默认文件进行存储。此时也可以输入特定的文件名，比如&lt;code&gt;/c/Users/you/.ssh/github_rsa&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;接着，根据提示，你需要输入密码和确认密码。相关提示如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Enter passphrase (empty for no passphrase): [Type a passphrase]
Enter same passphrase again: [Type passphrase again]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入完成之后，屏幕会显示如下信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Your identification has been saved in /c/Users/you/.ssh/id_rsa.
Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.
The key fingerprint is:
01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;第三步、在GitHub账户中添加你的公钥&lt;/h4&gt;

&lt;p&gt;运行如下命令，将公钥的内容复制到系统粘贴板(clipboard)中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;clip &amp;lt; ~/.ssh/id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;登陆GitHub,进入你的Account Settings. &lt;br/&gt;&lt;img src=&quot;/images/post/userbar-account-settings.png&quot; alt=&quot;Account Settings&quot; /&gt;&lt;/li&gt;
&lt;li&gt;在左边菜单，点击&quot;SSH Keys&quot;. &lt;br/&gt; &lt;img src=&quot;/images/post/settings-sidebar-ssh-keys.png&quot; alt=&quot;SSH Keys&quot; /&gt;&lt;/li&gt;
&lt;li&gt;点击&quot;Add SSH key&quot;按钮.&lt;br/&gt; &lt;img src=&quot;/images/post/ssh-add-ssh-key.png&quot; alt=&quot;Add SSH key&quot; /&gt;&lt;/li&gt;
&lt;li&gt;粘贴你的密钥到key输入框中.&lt;br/&gt; &lt;img src=&quot;/images/post/ssh-key-paste.png&quot; alt=&quot;Paste key&quot; /&gt;&lt;/li&gt;
&lt;li&gt;点击&quot;Add Key&quot;按钮。&lt;br/&gt; &lt;img src=&quot;/images/post/ssh-add-key.png&quot; alt=&quot;Add Key&quot; /&gt;&lt;/li&gt;
&lt;li&gt;再弹出窗口，输入你的GitHub密码，点击确认按钮。&lt;/li&gt;
&lt;li&gt;到此，大功告成了！&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;第四步、测试&lt;/h4&gt;

&lt;p&gt;为了确认我们可以通过SSH连接GitHub，我们输入下面命令。输入后，会要求我们提供验证密码，输入之前创建的密码就ok了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ssh -T git@github.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可能会看到告警信息，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The authenticity of host 'github.com (207.97.227.239)' can't be established.
RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.
Are you sure you want to continue connecting (yes/no)?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不用担心，直接输入yes。&lt;/p&gt;

&lt;p&gt;如果看到下面信息，就说明一切完美！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hi username! You've successfully authenticated, but GitHub does not provide shell access.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;a name=&quot;2&quot;&gt;&lt;/a&gt;二、Mac环境下生成SSH key且连接GitHub&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4&gt;第一步、看看是否存在SSH密钥(keys)&lt;/h4&gt;

&lt;p&gt;首先，我们需要看看是否看看本机是否存在SSH keys,打开终端(Terminal),并运行:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cd ~/.ssh
# 检查你本机用户home目录下是否存在.ssh目录
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果，不存在此目录，则进行第二步操作，否则，你本机已经存在ssh公钥和私钥，可以略过第二步，直接进入第三步操作。&lt;/p&gt;

&lt;h4&gt;第二步、创建一对新的SSH密钥(keys)&lt;/h4&gt;

&lt;p&gt;输入如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ssh-keygen -t rsa -C &quot;your_email@example.com&quot;
#这将按照你提供的邮箱地址，创建一对密钥
Generating public/private rsa key pair.
Enter file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;直接回车，则将密钥按默认文件进行存储。此时也可以输入特定的文件名，比如&lt;code&gt;/Users/you/.ssh/github_rsa&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;接着，根据提示，你需要输入密码和确认密码。相关提示如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Enter passphrase (empty for no passphrase): [Type a passphrase]
Enter same passphrase again: [Type passphrase again]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入完成之后，屏幕会显示如下信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Your identification has been saved in /Users/you/.ssh/id_rsa.
Your public key has been saved in /Users/you/.ssh/id_rsa.pub.
The key fingerprint is:
01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;第三步、在GitHub账户中添加你的公钥&lt;/h4&gt;

&lt;p&gt;运行如下命令，将公钥的内容复制到系统粘贴板(clipboard)中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pbcopy &amp;lt; ~/.ssh/id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;登陆GitHub,进入你的Account Settings. &lt;br/&gt;&lt;img src=&quot;/images/post/userbar-account-settings.png&quot; alt=&quot;Account Settings&quot; /&gt;&lt;/li&gt;
&lt;li&gt;在左边菜单，点击&quot;SSH Keys&quot;. &lt;br/&gt; &lt;img src=&quot;/images/post/settings-sidebar-ssh-keys.png&quot; alt=&quot;SSH Keys&quot; /&gt;&lt;/li&gt;
&lt;li&gt;点击&quot;Add SSH key&quot;按钮.&lt;br/&gt; &lt;img src=&quot;/images/post/ssh-add-ssh-key.png&quot; alt=&quot;Add SSH key&quot; /&gt;&lt;/li&gt;
&lt;li&gt;粘贴你的密钥到key输入框中.&lt;br/&gt; &lt;img src=&quot;/images/post/ssh-key-paste.png&quot; alt=&quot;Paste key&quot; /&gt;&lt;/li&gt;
&lt;li&gt;点击&quot;Add Key&quot;按钮。&lt;br/&gt; &lt;img src=&quot;/images/post/ssh-add-key.png&quot; alt=&quot;Add Key&quot; /&gt;&lt;/li&gt;
&lt;li&gt;再弹出窗口，输入你的GitHub密码，点击确认按钮。&lt;/li&gt;
&lt;li&gt;到此，大功告成了！&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;第四步、测试&lt;/h4&gt;

&lt;p&gt;为了确认我们可以通过SSH连接GitHub，我们输入下面命令。输入后，会要求我们提供验证密码，输入之前创建的密码就ok了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh -T git@github.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可能会看到告警信息，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The authenticity of host 'github.com (207.97.227.239)' can't be established.
RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.
Are you sure you want to continue connecting (yes/no)?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不用担心，直接输入yes。&lt;/p&gt;

&lt;p&gt;如果看到下面信息，就说明一切完美！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hi username! You've successfully authenticated, but GitHub does not provide shell access.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;【注意】&lt;/h4&gt;

&lt;p&gt;如果前面没有将生成的密钥存放在默认的文件&lt;code&gt;id_rsa&lt;/code&gt;中（而是&lt;code&gt;my_rsa&lt;/code&gt;中）,那么&lt;code&gt;ssh -T git@github.com&lt;/code&gt;命令就需要添加参数来执行。如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh -T -i my_rsa git@github.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;a name=&quot;3&quot;&gt;&lt;/a&gt;三、单机如何控制不同的SSH Keys连不同的Git环境?&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;其实，一套SSH密钥是可以用在不同的SSH环境的.&lt;/p&gt;

&lt;p&gt;但是如果由于某种要求，需要用不同的SSH密钥连接不同的Git环境。假设具体场景是，已经建了密钥github_rsa，还需要创建work_rsa连接工作环境git仓库，那么，可以按下面操作进行：&lt;/p&gt;

&lt;h4&gt;1. 创建另一对密钥work_rsa.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ssh-keygen -t rsa -C &quot;work@mail.com&quot;
#保存密钥为work_rsa
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;2. 添加新身份信息&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ssh-add ～/.ssh/work_rsa
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;3. 配置.ssh/config&lt;/h4&gt;

&lt;p&gt;我们需要通过Host别名，将不同的账号区分开来。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Host me.github.com
    HostName github.com
    PreferredAuthentications publickey
    IdentityFile ~/.ssh/github_rsa

Host work.comp.com
    HostName comp.com
    PreferredAuthentications publickey
    IdentityFile ~/.ssh/work_rsa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考文档:GitHub官方文档&lt;a href=&quot;https://help.github.com/articles/generating-ssh-keys&quot;&gt;Generating SSH Keys&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>MAC OS X 10.8 下安装jekyll</title>
   <link href="http://www.blogways.net/blog/2013/04/08/install-jekyll-on-mac.html"/>
   <updated>2013-04-08T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/08/install-jekyll-on-mac</id>
   <content type="html">&lt;h3&gt;一、概述&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki&quot;&gt;jekyll&lt;/a&gt; 是一款简单的博客系统，静态网站生成器。她有一个模版目录，存放整个静态网站的模版文件，可以通过&lt;a href=&quot;https://github.com/shopify/liquid/wiki&quot;&gt;Liquid&lt;/a&gt;处理模版文件，把使用标记语言&lt;a href=&quot;http://en.wikipedia.org/wiki/Textile&quot;&gt;Textile&lt;/a&gt;或&lt;a href=&quot;http://en.wikipedia.org/wiki/Markdown&quot;&gt;Markdown&lt;/a&gt;编写的内容文件，按照模版格式，转换成最终的静态网站页面。大名鼎鼎的GitHub Pages就是通过她实现的。&lt;/p&gt;

&lt;p&gt;本想在本机Macbook pro上装个jekyll,可是本机xcode自动安装了ruby 1.8.7版，导致无法通过当前版本的gem安装jekyll。使用 &lt;code&gt;gem update --system&lt;/code&gt; 命令对gem进行升级，可是貌似没有升级成功。&lt;/p&gt;

&lt;p&gt;所以，我先装了个brew，通过brew安装了最新的ruby，最后通过新版gem成功安装了jekyll.整个过程记录如下。&lt;/p&gt;

&lt;h3&gt;二、安装Homebrew&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://mxcl.github.io/homebrew/index_zh-cn.html&quot;&gt;Homebrew&lt;/a&gt;落户于gitHub上，安装是否简单，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ruby -e &quot;$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开Terminal, 粘贴上面的语句.该脚本首先将会解释它要做什么, 然后暂停下来, 直到您确认继续. 更多的安装选项在&lt;a href=&quot;https://github.com/mxcl/homebrew/wiki/Installation&quot;&gt;这里&lt;/a&gt;可以看到 (需要10.5).&lt;/p&gt;

&lt;h3&gt;三、安装最新版ruby&lt;/h3&gt;

&lt;p&gt;Homebrew安装完成之后，通过她安装最新版ruby.命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install ruby
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最新版ruby安装完成之后，会提示你最新版本安装在&lt;code&gt;/usr/local/opt/ruby/bin&lt;/code&gt;目录下面。原来的旧版仍然在&lt;code&gt;/usr/bin&lt;/code&gt;下面.&lt;/p&gt;

&lt;p&gt;可以修改环境变量PATH的值，将新版本的路径在查找路径中前置。修改&lt;code&gt;~/.bash_profile&lt;/code&gt;文件，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export PATH=/usr/local/opt/ruby/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改后&lt;code&gt;source ~/.bash_profile&lt;/code&gt;或者重新打开一个Terminal，新版Ruby就生效了。&lt;/p&gt;

&lt;p&gt;可以通过&lt;code&gt;ruby --version&lt;/code&gt;查看版本号，我的新版信息如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ruby 2.0.0p0 (2013-02-24 revision 39474) [x86_64-darwin12.3.0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果，版本不对，就使用&lt;code&gt;which ruby&lt;/code&gt;看看，当前生效的ruby是否在&lt;code&gt;/usr/local/opt/ruby/bin&lt;/code&gt;下，不对，就修改环境变量PATH,如上。&lt;/p&gt;

&lt;h3&gt;四、安装jekyll&lt;/h3&gt;

&lt;p&gt;有了最新版的ruby,安装jekyll就简单了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem install jekyll 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果使用的标记语言是Markdown，则需要另外安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem install rdiscount
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果使用的标记语言是Textile,则需要另外安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem install RedCloth
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面三个可以一次性安装，如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gem install jekyll rdiscount RedCloth
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明：这里安装的jekyll、rdiscount、redcloth都安装在本机的&lt;code&gt;/usr/local/opt/ruby/bin&lt;/code&gt;目录下面。&lt;/p&gt;

&lt;h3&gt;五、运行例子——jekyll作者提供的例子tpw&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;获取源码，并运行jekyll，命令如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; cd ~
 mkdir webroot
 cd webroot
 git clone https://github.com/mojombo/tpw.git
 cd tpw
 jekyll --server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 界面显示启动信息，提示端口为4000&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在浏览器访问&lt;code&gt;localhost:4000&lt;/code&gt;，显示博客列表。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;相当完美！&lt;/li&gt;
&lt;li&gt;[说明]新版本的jekyll的命令发生了变化。&lt;code&gt;jekyll build&lt;/code&gt;用来编译程序；&lt;code&gt;jekyll serve&lt;/code&gt;用来编译并启动一个web服务。&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 
</feed>
